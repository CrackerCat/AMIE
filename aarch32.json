{
  "instructions": {
    "base": {
      "ADC_i": {
        "authored": "Add with Carry (immediate) adds an immediate value and the Carry flag value to a\nregister value, and writes the result to the destination register.\n\nIf the destination register is not the PC, the ADCS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The ADC variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The ADCS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "ADC, ADCS (immediate)",
        "templates": {
          "A1": [
            "ADC{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "ADCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ],
          "T1": [
            "ADC{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "ADCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ]
        }
      },
      "ADC_r": {
        "authored": "Add with Carry (register) adds a register value, the Carry flag value, and an\noptionally-shifted register value, and writes the result to the destination\nregister.\n\nIf the destination register is not the PC, the ADCS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The ADC variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The ADCS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "ADC, ADCS (register)",
        "templates": {
          "A1": [
            "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "ADC<c>{<q>} {<Rdn>,} <Rdn>, <Rm>",
            "ADCS{<q>} {<Rdn>,} <Rdn>, <Rm>"
          ],
          "T2": [
            "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ADC<c>.W {<Rd>,} <Rn>, <Rm>",
            "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ADCS.W {<Rd>,} <Rn>, <Rm>",
            "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "ADC_rr": {
        "authored": "Add with Carry (register-shifted register) adds a register value, the Carry flag\nvalue, and a register-shifted register value.  It writes the result to the\ndestination register, and can optionally update the condition flags based on the\nresult.",
        "heading": "ADC, ADCS (register-shifted register)",
        "templates": {
          "A1": [
            "ADCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>",
            "ADC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "ADD_ADR": {
        "authored": " adds an immediate value to the Align(PC, 4) value to form a PC-relative\naddress, and writes the result to the destination register.  ARM recommends\nthat, where possible, software avoids using this alias",
        "heading": "ADD (immediate, to PC)",
        "templates": {
          "A1": [
            "ADD{<c>}{<q>} <Rd>, PC, #<const>"
          ],
          "T1": [
            "ADD{<c>}{<q>} <Rd>, PC, #<imm8>"
          ],
          "T3": [
            "ADDW{<c>}{<q>} <Rd>, PC, #<imm12>",
            "ADD{<c>}{<q>} <Rd>, PC, #<imm12>"
          ]
        }
      },
      "ADD_SP_i": {
        "authored": "Add to SP (immediate) adds an immediate value to the SP value, and writes the\nresult to the destination register.\n\nIf the destination register is not the PC, the ADDS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. However, when the destination register is the PC:\n  - The ADD variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The ADDS variant of the instruction performs an exception return without the\nuse of the stack. ARM deprecates use of this instruction. However, in this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "ADD, ADDS (SP plus immediate)",
        "templates": {
          "A1": [
            "ADD{<c>}{<q>} {<Rd>,} SP, #<const>",
            "ADDS{<c>}{<q>} {<Rd>,} SP, #<const>"
          ],
          "T1": [
            "ADD{<c>}{<q>} <Rd>, SP, #<imm8>"
          ],
          "T2": [
            "ADD{<c>}{<q>} {SP,} SP, #<imm7>"
          ],
          "T3": [
            "ADD{<c>}.W {<Rd>,} SP, #<const>",
            "ADD{<c>}{<q>} {<Rd>,} SP, #<const>",
            "ADDS{<c>}{<q>} {<Rd>,} SP, #<const>"
          ],
          "T4": [
            "ADD{<c>}{<q>} {<Rd>,} SP, #<imm12>",
            "ADDW{<c>}{<q>} {<Rd>,} SP, #<imm12>"
          ]
        }
      },
      "ADD_SP_r": {
        "authored": "Add to SP (register) adds an optionally-shifted register value to the SP value,\nand writes the result to the destination register.\n\nIf the destination register is not the PC, the ADDS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The ADD variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The ADDS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "ADD, ADDS (SP plus register)",
        "templates": {
          "A1": [
            "ADD{<c>}{<q>} {<Rd>,} SP, <Rm> , RRX",
            "ADD{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}",
            "ADDS{<c>}{<q>} {<Rd>,} SP, <Rm> , RRX",
            "ADDS{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "ADD{<c>}{<q>} {<Rdm>,} SP, <Rdm>"
          ],
          "T2": [
            "ADD{<c>}{<q>} {SP,} SP, <Rm>"
          ],
          "T3": [
            "ADD{<c>}{<q>} {<Rd>,} SP, <Rm>, RRX",
            "ADD{<c>}.W {<Rd>,} SP, <Rm>",
            "ADD{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}",
            "ADDS{<c>}{<q>} {<Rd>,} SP, <Rm>, RRX",
            "ADDS{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "ADD_i": {
        "authored": "Add (immediate) adds an immediate value to a register value, and writes the\nresult to the destination register.\n\nIf the destination register is not the PC, the ADDS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. If the destination register is the PC:\n  - The ADD variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The ADDS variant of the instruction performs an exception return without the\nuse of the stack. ARM deprecates use of this instruction. However, in this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "ADD, ADDS (immediate)",
        "templates": {
          "A1": [
            "ADD{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "ADDS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ],
          "T1": [
            "ADD<c>{<q>} <Rd>, <Rn>, #<imm3>",
            "ADDS{<q>} <Rd>, <Rn>, #<imm3>"
          ],
          "T2": [
            "ADD<c>{<q>} <Rdn>, #<imm8>",
            "ADD<c>{<q>} {<Rdn>,} <Rdn>, #<imm8>",
            "ADDS{<q>} <Rdn>, #<imm8>",
            "ADDS{<q>} {<Rdn>,} <Rdn>, #<imm8>"
          ],
          "T3": [
            "ADD<c>.W {<Rd>,} <Rn>, #<const>",
            "ADD{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "ADDS.W {<Rd>,} <Rn>, #<const>",
            "ADDS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ],
          "T4": [
            "ADD{<c>}{<q>} {<Rd>,} <Rn>, #<imm12>",
            "ADDW{<c>}{<q>} {<Rd>,} <Rn>, #<imm12>"
          ]
        }
      },
      "ADD_r": {
        "authored": "Add (register) adds a register value and an optionally-shifted register value,\nand writes the result to the destination register.\n\nIf the destination register is not the PC, the ADDS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. If the destination register is the PC:\n  - The ADD variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The ADDS variant of the instruction performs an exception return without the\nuse of the stack. ARM deprecates use of this instruction. However, in this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "ADD, ADDS (register)",
        "templates": {
          "A1": [
            "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "ADD<c>{<q>} <Rd>, <Rn>, <Rm>",
            "ADDS{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T2": [
            "ADD<c>{<q>} <Rdn>, <Rm>",
            "ADD{<c>}{<q>} {<Rdn>,} <Rdn>, <Rm>"
          ],
          "T3": [
            "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ADD<c>.W {<Rd>,} <Rn>, <Rm>",
            "ADD{<c>}.W {<Rd>,} <Rn>, <Rm>",
            "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ADDS.W {<Rd>,} <Rn>, <Rm>",
            "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "ADD_rr": {
        "authored": "Add (register-shifted register) adds a register value and a register-shifted\nregister value. It writes the result to the destination register, and can\noptionally update the condition flags based on the result.",
        "heading": "ADD, ADDS (register-shifted register)",
        "templates": {
          "A1": [
            "ADDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>",
            "ADD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "ADR": {
        "authored": "Form PC-relative address adds an immediate value to the PC value to form a PC-\nrelative address, and writes the result to the destination register.",
        "heading": "ADR",
        "templates": {
          "A1": [
            "ADR{<c>}{<q>} <Rd>, <label>"
          ],
          "A2": [
            "ADR{<c>}{<q>} <Rd>, <label>"
          ],
          "T1": [
            "ADR{<c>}{<q>} <Rd>, <label>"
          ],
          "T2": [
            "ADR{<c>}{<q>} <Rd>, <label>"
          ],
          "T3": [
            "ADR{<c>}.W <Rd>, <label>",
            "ADR{<c>}{<q>} <Rd>, <label>"
          ]
        }
      },
      "AND_i": {
        "authored": "Bitwise AND (immediate) performs a bitwise AND of a register value and an\nimmediate value, and writes the result to the destination register.\n\nIf the destination register is not the PC, the ANDS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The AND variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The ANDS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "AND, ANDS (immediate)",
        "templates": {
          "A1": [
            "AND{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "ANDS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ],
          "T1": [
            "AND{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "ANDS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ]
        }
      },
      "AND_r": {
        "authored": "Bitwise AND (register) performs a bitwise AND of a register value and an\noptionally-shifted register value, and writes the result to the destination\nregister.\n\nIf the destination register is not the PC, the ANDS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The AND variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The ANDS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "AND, ANDS (register)",
        "templates": {
          "A1": [
            "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "AND<c>{<q>} {<Rdn>,} <Rdn>, <Rm>",
            "ANDS{<q>} {<Rdn>,} <Rdn>, <Rm>"
          ],
          "T2": [
            "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "AND<c>.W {<Rd>,} <Rn>, <Rm>",
            "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ANDS.W {<Rd>,} <Rn>, <Rm>",
            "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "AND_rr": {
        "authored": "Bitwise AND (register-shifted register) performs a bitwise AND of a register\nvalue and a register-shifted register value. It writes the result to the\ndestination register, and can optionally update the condition flags based on the\nresult.",
        "heading": "AND, ANDS (register-shifted register)",
        "templates": {
          "A1": [
            "ANDS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>",
            "AND{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "ASRS_MOV_r": {
        "authored": "Arithmetic Shift Right, setting flags (immediate) shifts a register value right\nby an immediate number of bits, shifting in copies of its sign bit, and writes\nthe result to the destination register.\n\nIf the destination register is not the PC, this instruction updates the\ncondition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n  - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n  - The instruction is undefined in Hyp mode.\n  - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "ASRS (immediate)",
        "templates": {
          "A1": [
            "ASRS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T2": [
            "ASRS{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T3": [
            "ASRS.W {<Rd>,} <Rm>, #<imm>",
            "ASRS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ]
        }
      },
      "ASRS_MOV_rr": {
        "authored": " shifts a register value right by a variable number of bits, shifting in copies\nof its sign bit, writes the result to the destination register, and updates the\ncondition flags based on the result. The variable number of bits is read from\nthe bottom byte of a register",
        "heading": "ASRS (register)",
        "templates": {
          "A1": [
            "ASRS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ],
          "T1": [
            "ASRS{<q>} {<Rdm>,} <Rdm>, <Rs>"
          ],
          "T2": [
            "ASRS.W {<Rd>,} <Rm>, <Rs>",
            "ASRS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ]
        }
      },
      "ASR_MOV_r": {
        "authored": "Arithmetic Shift Right (immediate) shifts a register value right by an immediate\nnumber of bits, shifting in copies of its sign bit, and writes the result to the\ndestination register.",
        "heading": "ASR (immediate)",
        "templates": {
          "A1": [
            "ASR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T2": [
            "ASR<c>{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T3": [
            "ASR<c>.W {<Rd>,} <Rm>, #<imm>",
            "ASR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ]
        }
      },
      "ASR_MOV_rr": {
        "authored": " shifts a register value right by a variable number of bits, shifting in copies\nof its sign bit, and writes the result to the destination register. The variable\nnumber of bits is read from the bottom byte of a register",
        "heading": "ASR (register)",
        "templates": {
          "A1": [
            "ASR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ],
          "T1": [
            "ASR<c>{<q>} {<Rdm>,} <Rdm>, <Rs>"
          ],
          "T2": [
            "ASR<c>.W {<Rd>,} <Rm>, <Rs>",
            "ASR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ]
        }
      },
      "B": {
        "authored": "Branch causes a branch to a target address.",
        "heading": "B",
        "templates": {
          "A1": [
            "B{<c>}{<q>} <label>"
          ],
          "T1": [
            "B<c>{<q>} <label>"
          ],
          "T2": [
            "B{<c>}{<q>} <label>"
          ],
          "T3": [
            "B<c>.W <label>",
            "B<c>{<q>} <label>"
          ],
          "T4": [
            "B{<c>}.W <label>",
            "B{<c>}{<q>} <label>"
          ]
        }
      },
      "BFC": {
        "authored": "Bit Field Clear clears any number of adjacent bits at any position in a\nregister, without affecting the other bits in the register.",
        "heading": "BFC",
        "templates": {
          "A1": [
            "BFC{<c>}{<q>} <Rd>, #<lsb>, #<width>"
          ],
          "T1": [
            "BFC{<c>}{<q>} <Rd>, #<lsb>, #<width>"
          ]
        }
      },
      "BFI": {
        "authored": "Bit Field Insert copies any number of low order bits from a register into the\nsame number of adjacent bits at any position in the destination register.",
        "heading": "BFI",
        "templates": {
          "A1": [
            "BFI{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>"
          ],
          "T1": [
            "BFI{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>"
          ]
        }
      },
      "BIC_i": {
        "authored": "Bitwise Bit Clear (immediate) performs a bitwise AND of a register value and the\ncomplement of an immediate value, and writes the result to the destination\nregister.\n\nIf the destination register is not the PC, the BICS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The BIC variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The BICS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "BIC, BICS (immediate)",
        "templates": {
          "A1": [
            "BIC{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "BICS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ],
          "T1": [
            "BIC{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "BICS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ]
        }
      },
      "BIC_r": {
        "authored": "Bitwise Bit Clear (register) performs a bitwise AND of a register value and the\ncomplement of an optionally-shifted register value, and writes the result to the\ndestination register.\n\nIf the destination register is not the PC, the BICS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The BIC variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The BICS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "BIC, BICS (register)",
        "templates": {
          "A1": [
            "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "BIC<c>{<q>} {<Rdn>,} <Rdn>, <Rm>",
            "BICS{<q>} {<Rdn>,} <Rdn>, <Rm>"
          ],
          "T2": [
            "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "BIC<c>.W {<Rd>,} <Rn>, <Rm>",
            "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "BICS.W {<Rd>,} <Rn>, <Rm>",
            "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "BIC_rr": {
        "authored": "Bitwise Bit Clear (register-shifted register) performs a bitwise AND of a\nregister value and the complement of a register-shifted register value. It\nwrites the result to the destination register, and can optionally update the\ncondition flags based on the result.",
        "heading": "BIC, BICS (register-shifted register)",
        "templates": {
          "A1": [
            "BICS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>",
            "BIC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "BKPT": {
        "authored": "Breakpoint causes a Breakpoint Instruction exception.\n\nBreakpoint is always unconditional, even when inside an IT block.",
        "heading": "BKPT",
        "templates": {
          "A1": [
            "BKPT{<q>} {#}<imm>"
          ],
          "T1": [
            "BKPT{<q>} {#}<imm>"
          ]
        }
      },
      "BLX_r": {
        "authored": "Branch with Link and Exchange (register) calls a subroutine at an address\nspecified in the register, and if necessary changes to the instruction set\nindicated by bit[0] of the register value. If the value in bit[0] is 0, the\ninstruction set after the branch will be A32. If the value in bit[0] is 1, the\ninstruction set after the branch will be T32.",
        "heading": "BLX (register)",
        "templates": {
          "A1": [
            "BLX{<c>}{<q>} <Rm>"
          ],
          "T1": [
            "BLX{<c>}{<q>} <Rm>"
          ]
        }
      },
      "BL_i": {
        "authored": "Branch with Link calls a subroutine at a PC-relative address, and setting LR to\nthe return address.\n\nBranch with Link and Exchange Instruction Sets (immediate) calls a subroutine at\na PC-relative address, setting LR to the return address, and changes the\ninstruction set from A32 to T32, or from T32 to A32.",
        "heading": "BL, BLX (immediate)",
        "templates": {
          "A1": [
            "BL{<c>}{<q>} <label>"
          ],
          "A2": [
            "BLX{<c>}{<q>} <label>"
          ],
          "T1": [
            "BL{<c>}{<q>} <label>"
          ],
          "T2": [
            "BLX{<c>}{<q>} <label>"
          ]
        }
      },
      "BX": {
        "authored": "Branch and Exchange causes a branch to an address and instruction set specified\nby a register.",
        "heading": "BX",
        "templates": {
          "A1": [
            "BX{<c>}{<q>} <Rm>"
          ],
          "T1": [
            "BX{<c>}{<q>} <Rm>"
          ]
        }
      },
      "BXJ": {
        "authored": "Branch and Exchange, previously Branch and Exchange Jazelle.\n\nIn ARMv8, BXJ behaves as a BX instruction, see BX. This means it causes a branch\nto an address and instruction set specified by a register.",
        "heading": "BXJ",
        "templates": {
          "A1": [
            "BXJ{<c>}{<q>} <Rm>"
          ],
          "T1": [
            "BXJ{<c>}{<q>} <Rm>"
          ]
        }
      },
      "CBNZ": {
        "authored": "Compare and Branch on Nonzero and Compare and Branch on Zero compare the value\nin a register with zero, and conditionally branch forward a constant value. They\ndo not affect the condition flags.",
        "heading": "CBNZ, CBZ",
        "templates": {
          "T1": [
            "CBNZ{<q>} <Rn>, <label>",
            "CBZ{<q>} <Rn>, <label>"
          ]
        }
      },
      "CLREX": {
        "authored": "Clear-Exclusive clears the local monitor of the executing PE.",
        "heading": "CLREX",
        "templates": {
          "A1": [
            "CLREX{<c>}{<q>}"
          ],
          "T1": [
            "CLREX{<c>}{<q>}"
          ]
        }
      },
      "CLZ": {
        "authored": "Count Leading Zeros returns the number of binary zero bits before the first\nbinary one bit in a value.",
        "heading": "CLZ",
        "templates": {
          "A1": [
            "CLZ{<c>}{<q>} <Rd>, <Rm>"
          ],
          "T1": [
            "CLZ{<c>}{<q>} <Rd>, <Rm>"
          ]
        }
      },
      "CMN_i": {
        "authored": "Compare Negative (immediate) adds a register value and an immediate value. It\nupdates the condition flags based on the result, and discards the result.",
        "heading": "CMN (immediate)",
        "templates": {
          "A1": [
            "CMN{<c>}{<q>} <Rn>, #<const>"
          ],
          "T1": [
            "CMN{<c>}{<q>} <Rn>, #<const>"
          ]
        }
      },
      "CMN_r": {
        "authored": "Compare Negative (register) adds a register value and an optionally-shifted\nregister value. It updates the condition flags based on the result, and discards\nthe result.",
        "heading": "CMN (register)",
        "templates": {
          "A1": [
            "CMN{<c>}{<q>} <Rn>, <Rm>, RRX",
            "CMN{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "CMN{<c>}{<q>} <Rn>, <Rm>"
          ],
          "T2": [
            "CMN{<c>}{<q>} <Rn>, <Rm>, RRX",
            "CMN{<c>}.W <Rn>, <Rm>",
            "CMN{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "CMN_rr": {
        "authored": "Compare Negative (register-shifted register) adds a register value and a\nregister-shifted register value. It updates the condition flags based on the\nresult, and discards the result.",
        "heading": "CMN (register-shifted register)",
        "templates": {
          "A1": [
            "CMN{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "CMP_i": {
        "authored": "Compare (immediate) subtracts an immediate value from a register value. It\nupdates the condition flags based on the result, and discards the result.",
        "heading": "CMP (immediate)",
        "templates": {
          "A1": [
            "CMP{<c>}{<q>} <Rn>, #<const>"
          ],
          "T1": [
            "CMP{<c>}{<q>} <Rn>, #<imm8>"
          ],
          "T2": [
            "CMP{<c>}.W <Rn>, #<const>",
            "CMP{<c>}{<q>} <Rn>, #<const>"
          ]
        }
      },
      "CMP_r": {
        "authored": "Compare (register) subtracts an optionally-shifted register value from a\nregister value. It updates the condition flags based on the result, and discards\nthe result.",
        "heading": "CMP (register)",
        "templates": {
          "A1": [
            "CMP{<c>}{<q>} <Rn>, <Rm>, RRX",
            "CMP{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "CMP{<c>}{<q>} <Rn>, <Rm>"
          ],
          "T2": [
            "CMP{<c>}{<q>} <Rn>, <Rm>"
          ],
          "T3": [
            "CMP{<c>}{<q>} <Rn>, <Rm>, RRX",
            "CMP{<c>}.W <Rn>, <Rm>",
            "CMP{<c>}{<q>} <Rn>, <Rm>, <shift> #<amount>"
          ]
        }
      },
      "CMP_rr": {
        "authored": "Compare (register-shifted register) subtracts a register-shifted register value\nfrom a register value. It updates the condition flags based on the result, and\ndiscards the result.",
        "heading": "CMP (register-shifted register)",
        "templates": {
          "A1": [
            "CMP{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "CPS": {
        "authored": "Change PE State changes one or more of the PSTATE.{A, I, F} interrupt mask bits\nand, optionally, the PSTATE.M mode field, without changing any other PSTATE\nbits.\n\nCPS is treated as NOP if executed in User mode unless it is defined as being\nconstrained unpredictable elsewhere in this section.\n\nThe PE checks whether the value being written to PSTATE.M is legal. See Illegal\nchanges to PSTATE.M.",
        "heading": "CPS, CPSID, CPSIE",
        "templates": {
          "A1": [
            "CPS{<q>} #<mode>",
            "CPSID{<q>} <iflags>",
            "CPSID{<q>} <iflags> , #<mode>",
            "CPSIE{<q>} <iflags>",
            "CPSIE{<q>} <iflags> , #<mode>"
          ],
          "T1": [
            "CPSID{<q>} <iflags>",
            "CPSIE{<q>} <iflags>"
          ],
          "T2": [
            "CPS{<q>} #<mode>",
            "CPSID.W <iflags>",
            "CPSID{<q>} <iflags>, #<mode>",
            "CPSIE.W <iflags>",
            "CPSIE{<q>} <iflags>, #<mode>"
          ]
        }
      },
      "CRC32": {
        "authored": "CRC32 performs a cyclic redundancy check (CRC) calculation on a value held in a\ngeneral-purpose register. It takes an input CRC value in the first source\noperand, performs a CRC on the input value in the second source operand, and\nreturns the output CRC value. The second source operand can be 8, 16, or 32\nbits. To align with common usage, the bit order of the values is reversed as\npart of the operation, and the polynomial 0x04C11DB7 is used for the CRC\ncalculation.\n\nIn ARMv8-A, this is an optional instruction, and in ARMv8.1 it is mandatory for\nall implementations to implement it.\n\nID_ISAR5.CRC32 indicates whether this instruction is supported in the T32 and\nA32 instruction sets.",
        "heading": "CRC32",
        "templates": {
          "A1": [
            "CRC32B{<q>} <Rd>, <Rn>, <Rm>",
            "CRC32H{<q>} <Rd>, <Rn>, <Rm>",
            "CRC32W{<q>} <Rd>, <Rn>, <Rm>"
          ],
          "T1": [
            "CRC32B{<q>} <Rd>, <Rn>, <Rm>",
            "CRC32H{<q>} <Rd>, <Rn>, <Rm>",
            "CRC32W{<q>} <Rd>, <Rn>, <Rm>"
          ]
        }
      },
      "CRC32C": {
        "authored": "CRC32C performs a cyclic redundancy check (CRC) calculation on a value held in a\ngeneral-purpose register. It takes an input CRC value in the first source\noperand, performs a CRC on the input value in the second source operand, and\nreturns the output CRC value. The second source operand can be 8, 16, or 32\nbits. To align with common usage, the bit order of the values is reversed as\npart of the operation, and the polynomial 0x1EDC6F41 is used for the CRC\ncalculation.\n\nIn ARMv8-A, this is an optional instruction, and in ARMv8.1 it is mandatory for\nall implementations to implement it.\n\nID_ISAR5.CRC32 indicates whether this instruction is supported in the T32 and\nA32 instruction sets.",
        "heading": "CRC32C",
        "templates": {
          "A1": [
            "CRC32CB{<q>} <Rd>, <Rn>, <Rm>",
            "CRC32CH{<q>} <Rd>, <Rn>, <Rm>",
            "CRC32CW{<q>} <Rd>, <Rn>, <Rm>"
          ],
          "T1": [
            "CRC32CB{<q>} <Rd>, <Rn>, <Rm>",
            "CRC32CH{<q>} <Rd>, <Rn>, <Rm>",
            "CRC32CW{<q>} <Rd>, <Rn>, <Rm>"
          ]
        }
      },
      "CSDB": {
        "authored": "Consumption of Speculative Data Barrier is a memory barrier that controls\nspeculative execution and data value prediction.\n\nNo instruction other than branch instructions and instructions that write to the\nPC appearing in program order after the CSDB can be speculatively executed using\nthe results of any:\n  - Data value predictions of any instructions.\n  - PSTATE.{N,Z,C,V} predictions of any instructions other than conditional\nbranch instructions and conditional instructions that write to the PC appearing\nin program order before the CSDB that have not been architecturally resolved.\n\nFor purposes of the definition of CSDB, PSTATE.{N,Z,C,V} is not considered a\ndata value. This definition permits:\n  - Control flow speculation before and after the CSDB.\n  - Speculative execution of conditional data processing instructions after the\nCSDB, unless they use the results of data value or PSTATE.{N,Z,C,V} predictions\nof instructions appearing in program order before the CSDB that have not been\narchitecturally resolved.",
        "heading": "CSDB",
        "templates": {
          "A1": [
            "CSDB{<c>}{<q>}"
          ],
          "T1": [
            "CSDB{<c>}.W"
          ]
        }
      },
      "DBG": {
        "authored": "In ARMv8, DBG executes as a NOP. ARM deprecates any use of the DBG instruction.",
        "heading": "DBG",
        "templates": {
          "A1": [
            "DBG{<c>}{<q>} #<option>"
          ],
          "T1": [
            "DBG{<c>}{<q>} #<option>"
          ]
        }
      },
      "DCPS": {
        "authored": "DCPSx, Debug Change PE State to ELx, where x is 1, 2, or 3.\n\nWhen executed in Debug state, the target Exception level of the instruction is:\n  - ELx, if the instruction is executed at an Exception level lower than ELx.\n  - Otherwise, the Exception level at which the instruction is executed.\n\nOn executing a DCPSx instruction in Debug state when the instruction is not\nundefined:\n  - If the instruction is executed at an Exception level that is lower than the\ntarget Exception level the PE enters the target Exception level, Elx, and:\n    - If ELx is using AArch64, the PE selects SP_ELx.\n    - If the target Exception level is EL1 using AArch32 the PE enters\nSupervisor mode.\n    - If the instruction was executed in Non-secure state and the target\nException level is EL2 using AArch32 the PE enters Hyp mode.\n    - If the target Exception level is EL3 using AArch32 the PE enters\nSupervisor mode and SCR.NS is set to 0.\n  - Otherwise, there is no change to the Exception level and:\n    - If the instruction was executed at EL1 the PE enters Supervisor mode.\n    - If the instruction was executed at EL2 the PE remains in Hyp mode.\n    - If the instruction was a DCPS1 instruction executed at EL3 the PE enters\nSupervisor mode and SCR.NS is set to 0.\n    - If the instruction was a DCPS3 instruction executed at EL3 the PE enters\nMonitor mode and SCR.NS is set to 0.\n\nThese instructions are always undefined in Non-debug state.\n\nDCPS1 is undefined at EL0 in Non-secure state if either:\n  - EL2 is implemented and using AArch64 and HCR_EL2.TGE == 1.\n  - EL2 is implemented and using AArch32 and HCR.TGE == 1.\n\nDCPS2 is undefined at all Exception levels if EL2 is not implemented.\n\nDCPS2 is undefined in the following states if EL2 is implemented:\n  - At EL0 and EL1 in Secure state if Secure EL2 is disabled.\n  - At EL3 if EL3 is using AArch32.\n\nDCPS3 is undefined at all Exception levels if either:\n  - EDSCR.SDD == 1.\n  - EL3 is not implemented.\n\nOn executing a DCPSx instruction that is not undefined and targets ELx:\n  - If ELx is using AArch64:\n    - ELR_ELx, SPSR_ELx, and ESR_ELx become unknown.\n    - DLR_EL0 and DSPSR_EL0 become unknown.\n  - If ELx is using AArch32 DLR and DSPSR become unknown and:\n    - If the target Exception level is EL1 or EL3, the LR and SPSR of the target\nPE mode become unknown.\n    - If the target Exception level is EL2, then ELR_hyp, SPSR_hyp, and HSR\nbecome unknown.\n\nFor more information on the operation of these instructions, see DCPS.",
        "heading": "DCPS1, DCPS2, DCPS3",
        "templates": {
          "T1": [
            "DCPS1",
            "DCPS2",
            "DCPS3"
          ]
        }
      },
      "DMB": {
        "authored": "Data Memory Barrier is a memory barrier that ensures the ordering of\nobservations of memory accesses, see Data Memory Barrier (DMB).",
        "heading": "DMB",
        "templates": {
          "A1": [
            "DMB{<c>}{<q>} {<option>}"
          ],
          "T1": [
            "DMB{<c>}{<q>} {<option>}"
          ]
        }
      },
      "DSB": {
        "authored": "Data Synchronization Barrier is a memory barrier that ensures the completion of\nmemory accesses, see Data Synchronization Barrier (DSB).",
        "heading": "DSB",
        "templates": {
          "A1": [
            "DSB{<c>}{<q>} {<option>}"
          ],
          "T1": [
            "DSB{<c>}{<q>} {<option>}"
          ]
        }
      },
      "EOR_i": {
        "authored": "Bitwise Exclusive OR (immediate) performs a bitwise Exclusive OR of a register\nvalue and an immediate value, and writes the result to the destination register.\n\nIf the destination register is not the PC, the EORS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The EOR variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The EORS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "EOR, EORS (immediate)",
        "templates": {
          "A1": [
            "EOR{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "EORS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ],
          "T1": [
            "EOR{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "EORS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ]
        }
      },
      "EOR_r": {
        "authored": "Bitwise Exclusive OR (register) performs a bitwise Exclusive OR of a register\nvalue and an optionally-shifted register value, and writes the result to the\ndestination register.\n\nIf the destination register is not the PC, the EORS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The EOR variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The EORS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "EOR, EORS (register)",
        "templates": {
          "A1": [
            "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "EOR<c>{<q>} {<Rdn>,} <Rdn>, <Rm>",
            "EORS{<q>} {<Rdn>,} <Rdn>, <Rm>"
          ],
          "T2": [
            "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "EOR<c>.W {<Rd>,} <Rn>, <Rm>",
            "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "EORS.W {<Rd>,} <Rn>, <Rm>",
            "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "EOR_rr": {
        "authored": "Bitwise Exclusive OR (register-shifted register) performs a bitwise Exclusive OR\nof a register value and a register-shifted register value. It writes the result\nto the destination register, and can optionally update the condition flags based\non the result.",
        "heading": "EOR, EORS (register-shifted register)",
        "templates": {
          "A1": [
            "EORS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>",
            "EOR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "ERET": {
        "authored": "Exception Return.\n\nThe PE branches to the address held in the register holding the preferred return\naddress, and restores PSTATE from SPSR_<current_mode>.\n\nThe register holding the preferred return address is:\n  - ELR_hyp, when executing in Hyp mode.\n  - LR, when executing in a mode other than Hyp mode, User mode, or System mode.\n\nThe PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n\nException Return is constrained unpredictable in User mode and System mode.\n\nIn Debug state, the T1 encoding of ERET executes the DRPS operation.",
        "heading": "ERET",
        "templates": {
          "A1": [
            "ERET{<c>}{<q>}"
          ],
          "T1": [
            "ERET{<c>}{<q>}"
          ]
        }
      },
      "ESB": {
        "authored": "Error Synchronization Barrier is an error synchronization event that might also\nupdate DISR and VDISR. This instruction can be used at all Exception levels and\nin Debug state.\n\nIn Debug state, this instruction behaves as if SError interrupts are masked at\nall Exception levels. See Error Synchronization Barrier in the ARM(R)\nReliability, Availability, and Serviceability (RAS) Specification, ARMv8, for\nARMv8-A architecture profile.\n\nIf the RAS Extension is not implemented, this instruction executes as a NOP.",
        "heading": "ESB",
        "templates": {
          "A1": [
            "ESB{<c>}{<q>}"
          ],
          "T1": [
            "ESB{<c>}.W"
          ]
        }
      },
      "HLT": {
        "authored": "Halting breakpoint causes a software breakpoint to occur.\n\nHalting breakpoint is always unconditional, even inside an IT block.",
        "heading": "HLT",
        "templates": {
          "A1": [
            "HLT{<q>} {#}<imm>"
          ],
          "T1": [
            "HLT{<q>} {#}<imm>"
          ]
        }
      },
      "HVC": {
        "authored": "Hypervisor Call causes a Hypervisor Call exception. For more information see\nHypervisor Call (HVC) exception.  Non-secure software executing at EL1 can use\nthis instruction to call the hypervisor to request a service.\n\nThe HVC instruction is:\n  - undefined in Secure state, and in User mode in Non-secure state.\n  - When SCR.HCE is set to 0, undefined in Non-secure EL1 modes and constrained\nunpredictable in Hyp mode.\n\nOn executing an HVC instruction, the HSR, Hyp Syndrome Register reports the\nexception as a Hypervisor Call exception, using the EC value 0x12, and captures\nthe value of the immediate argument, see Use of the HSR.",
        "heading": "HVC",
        "templates": {
          "A1": [
            "HVC{<q>} {#}<imm16>"
          ],
          "T1": [
            "HVC{<q>} {#}<imm16>"
          ]
        }
      },
      "ISB": {
        "authored": "Instruction Synchronization Barrier flushes the pipeline in the PE and is a\ncontext synchronization event. For more information, see Instruction\nSynchronization Barrier (ISB).",
        "heading": "ISB",
        "templates": {
          "A1": [
            "ISB{<c>}{<q>} {<option>}"
          ],
          "T1": [
            "ISB{<c>}{<q>} {<option>}"
          ]
        }
      },
      "IT": {
        "authored": "If-Then makes up to four following instructions (the IT block) conditional. The\nconditions for the instructions in the IT block are the same as, or the inverse\nof, the condition the IT instruction specifies for the first instruction in the\nblock.\n\nThe IT instruction itself does not affect the condition flags, but the execution\nof the instructions in the IT block can change the condition flags.\n\n16-bit instructions in the IT block, other than CMP, CMN and TST, do not set the\ncondition flags. An IT instruction with the AL condition can change the behavior\nwithout conditional execution.\n\nThe architecture permits exception return to an instruction in the IT block only\nif the restoration of the CPSR restores ITSTATE to a state consistent with the\nconditions specified by the IT instruction.  Any other exception return to an\ninstruction in an IT block is unpredictable. Any branch to a target instruction\nin an IT block is not permitted, and if such a branch is made it is\nunpredictable what condition is used when executing that target instruction and\nany subsequent instruction in the IT block.\n\nMany uses of the IT instruction are deprecated for performance reasons, and an\nimplementation might include ITD controls that can disable those uses of IT,\nmaking them undefined.\n\nFor more information see Conditional execution and Conditional instructions. The\nfirst of these sections includes more information about the ITD controls.",
        "heading": "IT",
        "templates": {
          "T1": [
            "IT{<x>{<y>{<z>}}}{<q>} <cond>"
          ]
        }
      },
      "LDA": {
        "authored": "Load-Acquire Word loads a word from memory and writes it to a register. The\ninstruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "LDA",
        "templates": {
          "A1": [
            "LDA{<c>}{<q>} <Rt>, [<Rn>]"
          ],
          "T1": [
            "LDA{<c>}{<q>} <Rt>, [<Rn>]"
          ]
        }
      },
      "LDAB": {
        "authored": "Load-Acquire Byte loads a byte from memory, zero-extends it to form a 32-bit\nword and writes it to a register. The instruction also has memory ordering\nsemantics as described in Load-Acquire, Store-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "LDAB",
        "templates": {
          "A1": [
            "LDAB{<c>}{<q>} <Rt>, [<Rn>]"
          ],
          "T1": [
            "LDAB{<c>}{<q>} <Rt>, [<Rn>]"
          ]
        }
      },
      "LDAEX": {
        "authored": "Load-Acquire Exclusive Word loads a word from memory, writes it to a register\nand:\n  - If the address has the Shared Memory attribute, marks the physical address\nas exclusive access for the executing PE in a global monitor.\n  - Causes the executing PE to indicate an active exclusive access in the local\nmonitor.\n\nThe instruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "LDAEX",
        "templates": {
          "A1": [
            "LDAEX{<c>}{<q>} <Rt>, [<Rn>]"
          ],
          "T1": [
            "LDAEX{<c>}{<q>} <Rt>, [<Rn>]"
          ]
        }
      },
      "LDAEXB": {
        "authored": "Load-Acquire Exclusive Byte loads a byte from memory, zero-extends it to form a\n32-bit word, writes it to a register and:\n  - If the address has the Shared Memory attribute, marks the physical address\nas exclusive access for the executing PE in a global monitor.\n  - Causes the executing PE to indicate an active exclusive access in the local\nmonitor.\n\nThe instruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "LDAEXB",
        "templates": {
          "A1": [
            "LDAEXB{<c>}{<q>} <Rt>, [<Rn>]"
          ],
          "T1": [
            "LDAEXB{<c>}{<q>} <Rt>, [<Rn>]"
          ]
        }
      },
      "LDAEXD": {
        "authored": "Load-Acquire Exclusive Doubleword loads a doubleword from memory, writes it to\ntwo registers and:\n  - If the address has the Shared Memory attribute, marks the physical address\nas exclusive access for the executing PE in a global monitor\n  - Causes the executing PE to indicate an active exclusive access in the local\nmonitor.\n\nThe instruction also acts as a barrier instruction with the ordering\nrequirements described in Load-Acquire, Store-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "LDAEXD",
        "templates": {
          "A1": [
            "LDAEXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]"
          ],
          "T1": [
            "LDAEXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]"
          ]
        }
      },
      "LDAEXH": {
        "authored": "Load-Acquire Exclusive Halfword loads a halfword from memory, zero-extends it to\nform a 32-bit word, writes it to a register and:\n  - If the address has the Shared Memory attribute, marks the physical address\nas exclusive access for the executing PE in a global monitor.\n  - Causes the executing PE to indicate an active exclusive access in the local\nmonitor.\n\nThe instruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "LDAEXH",
        "templates": {
          "A1": [
            "LDAEXH{<c>}{<q>} <Rt>, [<Rn>]"
          ],
          "T1": [
            "LDAEXH{<c>}{<q>} <Rt>, [<Rn>]"
          ]
        }
      },
      "LDAH": {
        "authored": "Load-Acquire Halfword loads a halfword from memory, zero-extends it to form a\n32-bit word and writes it to a register. The instruction also has memory\nordering semantics as described in Load-Acquire, Store-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "LDAH",
        "templates": {
          "A1": [
            "LDAH{<c>}{<q>} <Rt>, [<Rn>]"
          ],
          "T1": [
            "LDAH{<c>}{<q>} <Rt>, [<Rn>]"
          ]
        }
      },
      "LDC_i": {
        "authored": "Load data to System register (immediate) calculates an address from a base\nregister value and an immediate offset, loads a word from memory, and writes it\nto the DBGDTRTXint System register. It can use offset, post-indexed, pre-\nindexed, or unindexed addressing. For information about memory accesses see\nMemory accesses.\n\nIn an implementation that includes EL2, the permitted LDC access to DBGDTRTXint\ncan be trapped to Hyp mode, meaning that an attempt to execute an LDC\ninstruction in a Non-secure mode other than Hyp mode, that would be permitted in\nthe absence of the Hyp trap controls, generates a Hyp Trap exception.  For more\ninformation, see Trapping general Non-secure System register accesses to debug\nregisters.\n\nFor simplicity, the LDC pseudocode does not show this possible trap to Hyp mode.",
        "heading": "LDC (immediate)",
        "templates": {
          "A1": [
            "LDC{<c>}{<q>} p14, c5, [<Rn>{, #{+/-}<imm>}]",
            "LDC{<c>}{<q>} p14, c5, [<Rn>], #{+/-}<imm>",
            "LDC{<c>}{<q>} p14, c5, [<Rn>, #{+/-}<imm>]!",
            "LDC{<c>}{<q>} p14, c5, [<Rn>], <option>"
          ],
          "T1": [
            "LDC{<c>}{<q>} p14, c5, [<Rn>{, #{+/-}<imm>}]",
            "LDC{<c>}{<q>} p14, c5, [<Rn>], #{+/-}<imm>",
            "LDC{<c>}{<q>} p14, c5, [<Rn>, #{+/-}<imm>]!",
            "LDC{<c>}{<q>} p14, c5, [<Rn>], <option>"
          ]
        }
      },
      "LDC_l": {
        "authored": "Load data to System register (literal) calculates an address from the PC value\nand an immediate offset, loads a word from memory, and writes it to the\nDBGDTRTXint System register. For information about memory accesses see Memory\naccesses.\n\nIn an implementation that includes EL2, the permitted LDC access to DBGDTRTXint\ncan be trapped to Hyp mode, meaning that an attempt to execute an LDC\ninstruction in a Non-secure mode other than Hyp mode, that would be permitted in\nthe absence of the Hyp trap controls, generates a Hyp Trap exception.  For more\ninformation, see Trapping general Non-secure System register accesses to debug\nregisters.\n\nFor simplicity, the LDC pseudocode does not show this possible trap to Hyp mode.",
        "heading": "LDC (literal)",
        "templates": {
          "A1": [
            "LDC{<c>}{<q>} p14, c5, <label>",
            "LDC{<c>}{<q>} p14, c5, [PC, #{+/-}<imm>]",
            "LDC{<c>}{<q>} p14, c5, [PC], <option>"
          ],
          "T1": [
            "LDC{<c>}{<q>} p14, c5, <label>",
            "LDC{<c>}{<q>} p14, c5, [PC, #{+/-}<imm>]"
          ]
        }
      },
      "LDM": {
        "authored": "Load Multiple (Increment After, Full Descending) loads multiple registers from\nconsecutive memory locations using an address from a base register. The\nconsecutive memory locations start at this address, and the address just above\nthe highest of those locations can optionally be written back to the base\nregister.\n\nThe lowest-numbered register is loaded from the lowest memory address, through\nto the highest-numbered register from the highest memory address. See also\nEncoding of lists of general-purpose registers and the PC.\n\nARMv8.2 permits the deprecation of some Load Multiple ordering behaviors in\nAArch32 state, for more information see ARMv8.2-LSMAOC. The registers loaded can\ninclude the PC, causing a branch to a loaded address. This is an interworking\nbranch, see Pseudocode description of operations on the AArch32 general-purpose\nregisters and the PC. Related system instructions are LDM (User registers) and\nLDM (exception return).",
        "heading": "LDM, LDMIA, LDMFD",
        "templates": {
          "A1": [
            "LDM{IA}{<c>}{<q>} <Rn>{!}, <registers>",
            "LDMFD{<c>}{<q>} <Rn>{!}, <registers>"
          ],
          "T1": [
            "LDM{IA}{<c>}{<q>} <Rn>{!}, <registers>",
            "LDMFD{<c>}{<q>} <Rn>{!}, <registers>"
          ],
          "T2": [
            "LDM{IA}{<c>}.W <Rn>{!}, <registers>",
            "LDMFD{<c>}.W <Rn>{!}, <registers>",
            "LDM{IA}{<c>}{<q>} <Rn>{!}, <registers>",
            "LDMFD{<c>}{<q>} <Rn>{!}, <registers>"
          ]
        }
      },
      "LDMDA": {
        "authored": "Load Multiple Decrement After (Full Ascending) loads multiple registers from\nconsecutive memory locations using an address from a base register. The\nconsecutive memory locations end at this address, and the address just below the\nlowest of those locations can optionally be written back to the base register.\n\nThe lowest-numbered register is loaded from the lowest memory address, through\nto the highest-numbered register from the highest memory address. See also\nEncoding of lists of general-purpose registers and the PC.\n\nARMv8.2 permits the deprecation of some Load Multiple ordering behaviors in\nAArch32 state, for more information see ARMv8.2-LSMAOC. The registers loaded can\ninclude the PC, causing a branch to a loaded address. This is an interworking\nbranch, see Pseudocode description of operations on the AArch32 general-purpose\nregisters and the PC. Related system instructions are LDM (User registers) and\nLDM (exception return).",
        "heading": "LDMDA, LDMFA",
        "templates": {
          "A1": [
            "LDMDA{<c>}{<q>} <Rn>{!}, <registers>",
            "LDMFA{<c>}{<q>} <Rn>{!}, <registers>"
          ]
        }
      },
      "LDMDB": {
        "authored": "Load Multiple Decrement Before (Empty Ascending) loads multiple registers from\nconsecutive memory locations using an address from a base register. The\nconsecutive memory locations end just below this address, and the address of the\nlowest of those locations can optionally be written back to the base register.\n\nThe lowest-numbered register is loaded from the lowest memory address, through\nto the highest-numbered register from the highest memory address. See also\nEncoding of lists of general-purpose registers and the PC.\n\nARMv8.2 permits the deprecation of some Load Multiple ordering behaviors in\nAArch32 state, for more information see ARMv8.2-LSMAOC. The registers loaded can\ninclude the PC, causing a branch to a loaded address. This is an interworking\nbranch, see Pseudocode description of operations on the AArch32 general-purpose\nregisters and the PC. Related system instructions are LDM (User registers) and\nLDM (exception return).",
        "heading": "LDMDB, LDMEA",
        "templates": {
          "A1": [
            "LDMDB{<c>}{<q>} <Rn>{!}, <registers>",
            "LDMEA{<c>}{<q>} <Rn>{!}, <registers>"
          ],
          "T1": [
            "LDMDB{<c>}{<q>} <Rn>{!}, <registers>",
            "LDMEA{<c>}{<q>} <Rn>{!}, <registers>"
          ]
        }
      },
      "LDMIB": {
        "authored": "Load Multiple Increment Before (Empty Descending) loads multiple registers from\nconsecutive memory locations using an address from a base register. The\nconsecutive memory locations start just above this address, and the address of\nthe last of those locations can optionally be written back to the base register.\n\nThe lowest-numbered register is loaded from the lowest memory address, through\nto the highest-numbered register from the highest memory address. See also\nEncoding of lists of general-purpose registers and the PC.\n\nARMv8.2 permits the deprecation of some Load Multiple ordering behaviors in\nAArch32 state, for more information see ARMv8.2-LSMAOC. The registers loaded can\ninclude the PC, causing a branch to a loaded address. This is an interworking\nbranch, see Pseudocode description of operations on the AArch32 general-purpose\nregisters and the PC. Related system instructions are LDM (User registers) and\nLDM (exception return).",
        "heading": "LDMIB, LDMED",
        "templates": {
          "A1": [
            "LDMIB{<c>}{<q>} <Rn>{!}, <registers>",
            "LDMED{<c>}{<q>} <Rn>{!}, <registers>"
          ]
        }
      },
      "LDM_e": {
        "authored": "Load Multiple (exception return) loads multiple registers from consecutive\nmemory locations using an address from a base register. The SPSR of the current\nmode is copied to the CPSR. An address adjusted by the size of the data loaded\ncan optionally be written back to the base register.\n\nThe registers loaded include the PC. The word loaded for the PC is treated as an\naddress and a branch occurs to that address.\n\nLoad Multiple (exception return) is:\n  - undefined in Hyp mode.\n  - unpredictable in debug state, and in User mode and System mode.",
        "heading": "LDM (exception return)",
        "templates": {
          "A1": [
            "LDM{<amode>}{<c>}{<q>} <Rn>{!}, <registers_with_pc>^"
          ]
        }
      },
      "LDM_u": {
        "authored": "In an EL1 mode other than System mode, Load Multiple (User registers) loads\nmultiple User mode registers from consecutive memory locations using an address\nfrom a base register. The registers loaded cannot include the PC. The PE reads\nthe base register value normally, using the current mode to determine the\ncorrect Banked version of the register. This instruction cannot writeback to the\nbase register.\n\nLoad Multiple (User registers) is undefined in Hyp mode, and unpredictable in\nUser and System modes.\n\nARMv8.2 permits the deprecation of some Load Multiple ordering behaviors in\nAArch32 state, for more information see ARMv8.2-LSMAOC.",
        "heading": "LDM (User registers)",
        "templates": {
          "A1": [
            "LDM{<amode>}{<c>}{<q>} <Rn>, <registers_without_pc>^"
          ]
        }
      },
      "LDRBT": {
        "authored": "Load Register Byte Unprivileged loads a byte from memory, zero-extends it to\nform a 32-bit word, and writes it to a register. For information about memory\naccesses see Memory accesses.\n\nThe memory access is restricted as if the PE were running in User mode. This\nmakes no difference if the PE is actually running in User mode.\n\nLDRBT is unpredictable in Hyp mode.\n\nThe T32 instruction uses an offset addressing mode, that calculates the address\nused for the memory access from a base register value and an immediate offset,\nand leaves the base register unchanged.\n\nThe A32 instruction uses a post-indexed addressing mode, that uses a base\nregister value as the address for the memory access, and calculates a new\naddress from a base register value and an offset and writes it back to the base\nregister. The offset can be an immediate value or an optionally-shifted register\nvalue.",
        "heading": "LDRBT",
        "templates": {
          "A1": [
            "LDRBT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
          ],
          "A2": [
            "LDRBT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}"
          ],
          "T1": [
            "LDRBT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ]
        }
      },
      "LDRB_i": {
        "authored": "Load Register Byte (immediate) calculates an address from a base register value\nand an immediate offset, loads a byte from memory, zero-extends it to form a\n32-bit word, and writes it to a register. It can use offset, post-indexed, or\npre-indexed addressing.  For information about memory accesses see Memory\naccesses.",
        "heading": "LDRB (immediate)",
        "templates": {
          "A1": [
            "LDRB{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]",
            "LDRB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "LDRB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ],
          "T1": [
            "LDRB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T2": [
            "LDRB{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]",
            "LDRB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T3": [
            "LDRB{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]",
            "LDRB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "LDRB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ]
        }
      },
      "LDRB_l": {
        "authored": "Load Register Byte (literal) calculates an address from the PC value and an\nimmediate offset, loads a byte from memory, zero-extends it to form a 32-bit\nword, and writes it to a register. For information about memory accesses see\nMemory accesses.",
        "heading": "LDRB (literal)",
        "templates": {
          "A1": [
            "LDRB{<c>}{<q>} <Rt>, <label>",
            "LDRB{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]"
          ],
          "T1": [
            "LDRB{<c>}{<q>} <Rt>, <label>",
            "LDRB{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]"
          ]
        }
      },
      "LDRB_r": {
        "authored": "Load Register Byte (register) calculates an address from a base register value\nand an offset register value, loads a byte from memory, zero-extends it to form\na 32-bit word, and writes it to a register. The offset register value can\noptionally be shifted.  For information about memory accesses see Memory\naccesses.",
        "heading": "LDRB (register)",
        "templates": {
          "A1": [
            "LDRB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]",
            "LDRB{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}",
            "LDRB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]!"
          ],
          "T1": [
            "LDRB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
          ],
          "T2": [
            "LDRB{<c>}.W <Rt>, [<Rn>, {+}<Rm>]",
            "LDRB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
          ]
        }
      },
      "LDRD_i": {
        "authored": "Load Register Dual (immediate) calculates an address from a base register value\nand an immediate offset, loads two words from memory, and writes them to two\nregisters. It can use offset, post-indexed, or pre-indexed addressing. For\ninformation about memory accesses see Memory accesses.",
        "heading": "LDRD (immediate)",
        "templates": {
          "A1": [
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #{+/-}<imm>}]",
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #{+/-}<imm>",
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #{+/-}<imm>]!"
          ],
          "T1": [
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #{+/-}<imm>}]",
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #{+/-}<imm>",
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #{+/-}<imm>]!"
          ]
        }
      },
      "LDRD_l": {
        "authored": "Load Register Dual (literal) calculates an address from the PC value and an\nimmediate offset, loads two words from memory, and writes them to two registers.\nFor information about memory accesses see Memory accesses.",
        "heading": "LDRD (literal)",
        "templates": {
          "A1": [
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, <label>",
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, [PC, #{+/-}<imm>]"
          ],
          "T1": [
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, <label>",
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, [PC, #{+/-}<imm>]"
          ]
        }
      },
      "LDRD_r": {
        "authored": "Load Register Dual (register) calculates an address from a base register value\nand a register offset, loads two words from memory, and writes them to two\nregisters. It can use offset, post-indexed, or pre-indexed addressing. For\ninformation about memory accesses see Memory accesses.",
        "heading": "LDRD (register)",
        "templates": {
          "A1": [
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, {+/-}<Rm>]",
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], {+/-}<Rm>",
            "LDRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, {+/-}<Rm>]!"
          ]
        }
      },
      "LDREX": {
        "authored": "Load Register Exclusive calculates an address from a base register value and an\nimmediate offset, loads a word from memory, writes it to a register and:\n  - If the address has the Shared Memory attribute, marks the physical address\nas exclusive access for the executing PE in a global monitor.\n  - Causes the executing PE to indicate an active exclusive access in the local\nmonitor.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "LDREX",
        "templates": {
          "A1": [
            "LDREX{<c>}{<q>} <Rt>, [<Rn> {, {#}<imm>}]"
          ],
          "T1": [
            "LDREX{<c>}{<q>} <Rt>, [<Rn> {, #<imm>}]"
          ]
        }
      },
      "LDREXB": {
        "authored": "Load Register Exclusive Byte derives an address from a base register value,\nloads a byte from memory, zero-extends it to form a 32-bit word, writes it to a\nregister and:\n  - If the address has the Shared Memory attribute, marks the physical address\nas exclusive access for the executing PE in a global monitor.\n  - Causes the executing PE to indicate an active exclusive access in the local\nmonitor.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "LDREXB",
        "templates": {
          "A1": [
            "LDREXB{<c>}{<q>} <Rt>, [<Rn>]"
          ],
          "T1": [
            "LDREXB{<c>}{<q>} <Rt>, [<Rn>]"
          ]
        }
      },
      "LDREXD": {
        "authored": "Load Register Exclusive Doubleword derives an address from a base register\nvalue, loads a 64-bit doubleword from memory, writes it to two registers and:\n  - If the address has the Shared Memory attribute, marks the physical address\nas exclusive access for the executing PE in a global monitor.\n  - Causes the executing PE to indicate an active exclusive access in the local\nmonitor.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "LDREXD",
        "templates": {
          "A1": [
            "LDREXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]"
          ],
          "T1": [
            "LDREXD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>]"
          ]
        }
      },
      "LDREXH": {
        "authored": "Load Register Exclusive Halfword derives an address from a base register value,\nloads a halfword from memory, zero-extends it to form a 32-bit word, writes it\nto a register and:\n  - If the address has the Shared Memory attribute, marks the physical address\nas exclusive access for the executing PE in a global monitor.\n  - Causes the executing PE to indicate an active exclusive access in the local\nmonitor.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "LDREXH",
        "templates": {
          "A1": [
            "LDREXH{<c>}{<q>} <Rt>, [<Rn>]"
          ],
          "T1": [
            "LDREXH{<c>}{<q>} <Rt>, [<Rn>]"
          ]
        }
      },
      "LDRHT": {
        "authored": "Load Register Halfword Unprivileged loads a halfword from memory, zero-extends\nit to form a 32-bit word, and writes it to a register. For information about\nmemory accesses see Memory accesses.\n\nThe memory access is restricted as if the PE were running in User mode. This\nmakes no difference if the PE is actually running in User mode.\n\nLDRHT is unpredictable in Hyp mode.\n\nThe T32 instruction uses an offset addressing mode, that calculates the address\nused for the memory access from a base register value and an immediate offset,\nand leaves the base register unchanged.\n\nThe A32 instruction uses a post-indexed addressing mode, that uses a base\nregister value as the address for the memory access, and calculates a new\naddress from a base register value and an offset and writes it back to the base\nregister. The offset can be an immediate value or a register value.",
        "heading": "LDRHT",
        "templates": {
          "A1": [
            "LDRHT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
          ],
          "A2": [
            "LDRHT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>"
          ],
          "T1": [
            "LDRHT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ]
        }
      },
      "LDRH_i": {
        "authored": "Load Register Halfword (immediate) calculates an address from a base register\nvalue and an immediate offset, loads a halfword from memory, zero-extends it to\nform a 32-bit word, and writes it to a register. It can use offset, post-\nindexed, or pre-indexed addressing.  For information about memory accesses see\nMemory accesses.",
        "heading": "LDRH (immediate)",
        "templates": {
          "A1": [
            "LDRH{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]",
            "LDRH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "LDRH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ],
          "T1": [
            "LDRH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T2": [
            "LDRH{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]",
            "LDRH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T3": [
            "LDRH{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]",
            "LDRH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "LDRH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ]
        }
      },
      "LDRH_l": {
        "authored": "Load Register Halfword (literal) calculates an address from the PC value and an\nimmediate offset, loads a halfword from memory, zero-extends it to form a 32-bit\nword, and writes it to a register. For information about memory accesses see\nMemory accesses.",
        "heading": "LDRH (literal)",
        "templates": {
          "A1": [
            "LDRH{<c>}{<q>} <Rt>, <label>",
            "LDRH{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]"
          ],
          "T1": [
            "LDRH{<c>}{<q>} <Rt>, <label>",
            "LDRH{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]"
          ]
        }
      },
      "LDRH_r": {
        "authored": "Load Register Halfword (register) calculates an address from a base register\nvalue and an offset register value, loads a halfword from memory, zero-extends\nit to form a 32-bit word, and writes it to a register. The offset register value\ncan be shifted left by 0, 1, 2, or 3 bits. For information about memory accesses\nsee Memory accesses.",
        "heading": "LDRH (register)",
        "templates": {
          "A1": [
            "LDRH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]",
            "LDRH{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>",
            "LDRH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]!"
          ],
          "T1": [
            "LDRH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
          ],
          "T2": [
            "LDRH{<c>}.W <Rt>, [<Rn>, {+}<Rm>]",
            "LDRH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
          ]
        }
      },
      "LDRSBT": {
        "authored": "Load Register Signed Byte Unprivileged loads a byte from memory, sign-extends it\nto form a 32-bit word, and writes it to a register. For information about memory\naccesses see Memory accesses.\n\nThe memory access is restricted as if the PE were running in User mode. This\nmakes no difference if the PE is actually running in User mode.\n\nLDRSBT is unpredictable in Hyp mode.\n\nThe T32 instruction uses an offset addressing mode, that calculates the address\nused for the memory access from a base register value and an immediate offset,\nand leaves the base register unchanged.\n\nThe A32 instruction uses a post-indexed addressing mode, that uses a base\nregister value as the address for the memory access, and calculates a new\naddress from a base register value and an offset and writes it back to the base\nregister. The offset can be an immediate value or a register value.",
        "heading": "LDRSBT",
        "templates": {
          "A1": [
            "LDRSBT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
          ],
          "A2": [
            "LDRSBT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>"
          ],
          "T1": [
            "LDRSBT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ]
        }
      },
      "LDRSB_i": {
        "authored": "Load Register Signed Byte (immediate) calculates an address from a base register\nvalue and an immediate offset, loads a byte from memory, sign-extends it to form\na 32-bit word, and writes it to a register. It can use offset, post-indexed, or\npre-indexed addressing.  For information about memory accesses see Memory\naccesses.",
        "heading": "LDRSB (immediate)",
        "templates": {
          "A1": [
            "LDRSB{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]",
            "LDRSB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "LDRSB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ],
          "T1": [
            "LDRSB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T2": [
            "LDRSB{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]",
            "LDRSB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "LDRSB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ]
        }
      },
      "LDRSB_l": {
        "authored": "Load Register Signed Byte (literal) calculates an address from the PC value and\nan immediate offset, loads a byte from memory, sign-extends it to form a 32-bit\nword, and writes it to a register. For information about memory accesses see\nMemory accesses.",
        "heading": "LDRSB (literal)",
        "templates": {
          "A1": [
            "LDRSB{<c>}{<q>} <Rt>, <label>",
            "LDRSB{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]"
          ],
          "T1": [
            "LDRSB{<c>}{<q>} <Rt>, <label>",
            "LDRSB{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]"
          ]
        }
      },
      "LDRSB_r": {
        "authored": "Load Register Signed Byte (register) calculates an address from a base register\nvalue and an offset register value, loads a byte from memory, sign-extends it to\nform a 32-bit word, and writes it to a register. The offset register value can\nbe shifted left by 0, 1, 2, or 3 bits. For information about memory accesses see\nMemory accesses.",
        "heading": "LDRSB (register)",
        "templates": {
          "A1": [
            "LDRSB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]",
            "LDRSB{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>",
            "LDRSB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]!"
          ],
          "T1": [
            "LDRSB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
          ],
          "T2": [
            "LDRSB{<c>}.W <Rt>, [<Rn>, {+}<Rm>]",
            "LDRSB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
          ]
        }
      },
      "LDRSHT": {
        "authored": "Load Register Signed Halfword Unprivileged loads a halfword from memory, sign-\nextends it to form a 32-bit word, and writes it to a register. For information\nabout memory accesses see Memory accesses.\n\nThe memory access is restricted as if the PE were running in User mode. This\nmakes no difference if the PE is actually running in User mode.\n\nLDRSHT is unpredictable in Hyp mode.\n\nThe T32 instruction uses an offset addressing mode, that calculates the address\nused for the memory access from a base register value and an immediate offset,\nand leaves the base register unchanged.\n\nThe A32 instruction uses a post-indexed addressing mode, that uses a base\nregister value as the address for the memory access, and calculates a new\naddress from a base register value and an offset and writes it back to the base\nregister. The offset can be an immediate value or a register value.",
        "heading": "LDRSHT",
        "templates": {
          "A1": [
            "LDRSHT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
          ],
          "A2": [
            "LDRSHT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>"
          ],
          "T1": [
            "LDRSHT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ]
        }
      },
      "LDRSH_i": {
        "authored": "Load Register Signed Halfword (immediate) calculates an address from a base\nregister value and an immediate offset, loads a halfword from memory, sign-\nextends it to form a 32-bit word, and writes it to a register. It can use\noffset, post-indexed, or pre-indexed addressing.  For information about memory\naccesses see Memory accesses.",
        "heading": "LDRSH (immediate)",
        "templates": {
          "A1": [
            "LDRSH{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]",
            "LDRSH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "LDRSH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ],
          "T1": [
            "LDRSH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T2": [
            "LDRSH{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]",
            "LDRSH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "LDRSH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ]
        }
      },
      "LDRSH_l": {
        "authored": "Load Register Signed Halfword (literal) calculates an address from the PC value\nand an immediate offset, loads a halfword from memory, sign-extends it to form a\n32-bit word, and writes it to a register. For information about memory accesses\nsee Memory accesses.",
        "heading": "LDRSH (literal)",
        "templates": {
          "A1": [
            "LDRSH{<c>}{<q>} <Rt>, <label>",
            "LDRSH{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]"
          ],
          "T1": [
            "LDRSH{<c>}{<q>} <Rt>, <label>",
            "LDRSH{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]"
          ]
        }
      },
      "LDRSH_r": {
        "authored": "Load Register Signed Halfword (register) calculates an address from a base\nregister value and an offset register value, loads a halfword from memory, sign-\nextends it to form a 32-bit word, and writes it to a register. The offset\nregister value can be shifted left by 0, 1, 2, or 3 bits. For information about\nmemory accesses see Memory accesses.",
        "heading": "LDRSH (register)",
        "templates": {
          "A1": [
            "LDRSH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]",
            "LDRSH{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>",
            "LDRSH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]!"
          ],
          "T1": [
            "LDRSH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
          ],
          "T2": [
            "LDRSH{<c>}.W <Rt>, [<Rn>, {+}<Rm>]",
            "LDRSH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
          ]
        }
      },
      "LDRT": {
        "authored": "Load Register Unprivileged loads a word from memory, and writes it to a\nregister. For information about memory accesses see Memory accesses.\n\nThe memory access is restricted as if the PE were running in User mode. This\nmakes no difference if the PE is actually running in User mode.\n\nLDRT is unpredictable in Hyp mode.\n\nThe T32 instruction uses an offset addressing mode, that calculates the address\nused for the memory access from a base register value and an immediate offset,\nand leaves the base register unchanged.\n\nThe A32 instruction uses a post-indexed addressing mode, that uses a base\nregister value as the address for the memory access, and calculates a new\naddress from a base register value and an offset and writes it back to the base\nregister. The offset can be an immediate value or an optionally-shifted register\nvalue.",
        "heading": "LDRT",
        "templates": {
          "A1": [
            "LDRT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
          ],
          "A2": [
            "LDRT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}"
          ],
          "T1": [
            "LDRT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ]
        }
      },
      "LDR_i": {
        "authored": "Load Register (immediate) calculates an address from a base register value and\nan immediate offset, loads a word from memory, and writes it to a register. It\ncan use offset, post-indexed, or pre-indexed addressing. For information about\nmemory accesses see Memory accesses.",
        "heading": "LDR (immediate)",
        "templates": {
          "A1": [
            "LDR{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]",
            "LDR{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "LDR{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ],
          "T1": [
            "LDR{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T2": [
            "LDR{<c>}{<q>} <Rt>, [SP{, #{+}<imm>}]"
          ],
          "T3": [
            "LDR{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]",
            "LDR{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T4": [
            "LDR{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]",
            "LDR{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "LDR{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ]
        }
      },
      "LDR_l": {
        "authored": "Load Register (literal) calculates an address from the PC value and an immediate\noffset, loads a word from memory, and writes it to a register. For information\nabout memory accesses see Memory accesses.",
        "heading": "LDR (literal)",
        "templates": {
          "A1": [
            "LDR{<c>}{<q>} <Rt>, <label>",
            "LDR{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]"
          ],
          "T1": [
            "LDR{<c>}{<q>} <Rt>, <label>"
          ],
          "T2": [
            "LDR{<c>}.W <Rt>, <label>",
            "LDR{<c>}{<q>} <Rt>, <label>",
            "LDR{<c>}{<q>} <Rt>, [PC, #{+/-}<imm>]"
          ]
        }
      },
      "LDR_r": {
        "authored": "Load Register (register) calculates an address from a base register value and an\noffset register value, loads a word from memory, and writes it to a register.\nThe offset register value can optionally be shifted. For information about\nmemory accesses, see Memory accesses.\n\nThe T32 form of LDR (register) does not support register writeback.",
        "heading": "LDR (register)",
        "templates": {
          "A1": [
            "LDR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]",
            "LDR{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}",
            "LDR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]!"
          ],
          "T1": [
            "LDR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
          ],
          "T2": [
            "LDR{<c>}.W <Rt>, [<Rn>, {+}<Rm>]",
            "LDR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
          ]
        }
      },
      "LSLS_MOV_r": {
        "authored": "Logical Shift Left, setting flags (immediate) shifts a register value left by an\nimmediate number of bits, shifting in zeros, and writes the result to the\ndestination register.\n\nIf the destination register is not the PC, this instruction updates the\ncondition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n  - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n  - The instruction is undefined in Hyp mode.\n  - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "LSLS (immediate)",
        "templates": {
          "A1": [
            "LSLS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T2": [
            "LSLS{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T3": [
            "LSLS.W {<Rd>,} <Rm>, #<imm>",
            "LSLS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ]
        }
      },
      "LSLS_MOV_rr": {
        "authored": " shifts a register value left by a variable number of bits, shifting in zeros,\nwrites the result to the destination register, and updates the condition flags\nbased on the result. The variable number of bits is read from the bottom byte of\na register",
        "heading": "LSLS (register)",
        "templates": {
          "A1": [
            "LSLS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ],
          "T1": [
            "LSLS{<q>} {<Rdm>,} <Rdm>, <Rs>"
          ],
          "T2": [
            "LSLS.W {<Rd>,} <Rm>, <Rs>",
            "LSLS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ]
        }
      },
      "LSL_MOV_r": {
        "authored": "Logical Shift Left (immediate) shifts a register value left by an immediate\nnumber of bits, shifting in zeros, and writes the result to the destination\nregister.",
        "heading": "LSL (immediate)",
        "templates": {
          "A1": [
            "LSL{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T2": [
            "LSL<c>{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T3": [
            "LSL<c>.W {<Rd>,} <Rm>, #<imm>",
            "LSL{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ]
        }
      },
      "LSL_MOV_rr": {
        "authored": " shifts a register value left by a variable number of bits, shifting in zeros,\nand writes the result to the destination register. The variable number of bits\nis read from the bottom byte of a register",
        "heading": "LSL (register)",
        "templates": {
          "A1": [
            "LSL{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ],
          "T1": [
            "LSL<c>{<q>} {<Rdm>,} <Rdm>, <Rs>"
          ],
          "T2": [
            "LSL<c>.W {<Rd>,} <Rm>, <Rs>",
            "LSL{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ]
        }
      },
      "LSRS_MOV_r": {
        "authored": "Logical Shift Right, setting flags (immediate) shifts a register value right by\nan immediate number of bits, shifting in zeros, and writes the result to the\ndestination register.\n\nIf the destination register is not the PC, this instruction updates the\ncondition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n  - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n  - The instruction is undefined in Hyp mode.\n  - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "LSRS (immediate)",
        "templates": {
          "A1": [
            "LSRS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T2": [
            "LSRS{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T3": [
            "LSRS.W {<Rd>,} <Rm>, #<imm>",
            "LSRS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ]
        }
      },
      "LSRS_MOV_rr": {
        "authored": " shifts a register value right by an immediate number of bits, shifting in\nzeros, writes the result to the destination register, and updates the condition\nflags based on the result. The variable number of bits is read from the bottom\nbyte of a register",
        "heading": "LSRS (register)",
        "templates": {
          "A1": [
            "LSRS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ],
          "T1": [
            "LSRS{<q>} {<Rdm>,} <Rdm>, <Rs>"
          ],
          "T2": [
            "LSRS.W {<Rd>,} <Rm>, <Rs>",
            "LSRS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ]
        }
      },
      "LSR_MOV_r": {
        "authored": "Logical Shift Right (immediate) shifts a register value right by an immediate\nnumber of bits, shifting in zeros, and writes the result to the destination\nregister.",
        "heading": "LSR (immediate)",
        "templates": {
          "A1": [
            "LSR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T2": [
            "LSR<c>{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T3": [
            "LSR<c>.W {<Rd>,} <Rm>, #<imm>",
            "LSR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ]
        }
      },
      "LSR_MOV_rr": {
        "authored": " shifts a register value right by a variable number of bits, shifting in zeros,\nand writes the result to the destination register. The variable number of bits\nis read from the bottom byte of a register",
        "heading": "LSR (register)",
        "templates": {
          "A1": [
            "LSR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ],
          "T1": [
            "LSR<c>{<q>} {<Rdm>,} <Rdm>, <Rs>"
          ],
          "T2": [
            "LSR<c>.W {<Rd>,} <Rm>, <Rs>",
            "LSR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ]
        }
      },
      "MCR": {
        "authored": "Move to System register from general-purpose register or execute a System\ninstruction. This instruction copies the value of a general-purpose register to\na System register, or executes a System instruction.\n\nThe System register and System instruction descriptions identify valid encodings\nfor this instruction. Other encodings are undefined. For more information see\nAbout the AArch32 System register interface and General behavior of System\nregisters.\n\nIn an implementation that includes EL2, MCR accesses to System registers can be\ntrapped to Hyp mode, meaning that an attempt to execute an MCR instruction in a\nNon-secure mode other than Hyp mode, that would be permitted in the absence of\nthe Hyp trap controls, generates a Hyp Trap exception.  For more information,\nsee EL2 configurable instruction enables, disables, and traps.\n\nBecause of the range of possible traps to Hyp mode, the MCR pseudocode does not\nshow these possible traps.",
        "heading": "MCR",
        "templates": {
          "A1": [
            "MCR{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}"
          ],
          "T1": [
            "MCR{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}"
          ]
        }
      },
      "MCRR": {
        "authored": "Move to System register from two general-purpose registers. This instruction\ncopies the values of two general-purpose registers to a System register.\n\nThe System register descriptions identify valid encodings for this instruction.\nOther encodings are undefined. For more information see About the AArch32 System\nregister interface and General behavior of System registers.\n\nIn an implementation that includes EL2, MCRR accesses to System registers can be\ntrapped to Hyp mode, meaning that an attempt to execute an MCRR instruction in a\nNon-secure mode other than Hyp mode, that would be permitted in the absence of\nthe Hyp trap controls, generates a Hyp Trap exception.  For more information,\nsee EL2 configurable instruction enables, disables, and traps.\n\nBecause of the range of possible traps to Hyp mode, the MCRR pseudocode does not\nshow these possible traps.",
        "heading": "MCRR",
        "templates": {
          "A1": [
            "MCRR{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>"
          ],
          "T1": [
            "MCRR{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>"
          ]
        }
      },
      "MLA": {
        "authored": "Multiply Accumulate multiplies two register values, and adds a third register\nvalue. The least significant 32 bits of the result are written to the\ndestination register. These 32 bits do not depend on whether the source register\nvalues are considered to be signed values or unsigned values.\n\nIn an A32 instruction, the condition flags can optionally be updated based on\nthe result. Use of this option adversely affects performance on many\nimplementations.",
        "heading": "MLA, MLAS",
        "templates": {
          "A1": [
            "MLAS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "MLA{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ],
          "T1": [
            "MLA{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ]
        }
      },
      "MLS": {
        "authored": "Multiply and Subtract multiplies two register values, and subtracts the product\nfrom a third register value. The least significant 32 bits of the result are\nwritten to the destination register. These 32 bits do not depend on whether the\nsource register values are considered to be signed values or unsigned values.",
        "heading": "MLS",
        "templates": {
          "A1": [
            "MLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ],
          "T1": [
            "MLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ]
        }
      },
      "MOVT": {
        "authored": "Move Top writes an immediate value to the top halfword of the destination\nregister. It does not affect the contents of the bottom halfword.",
        "heading": "MOVT",
        "templates": {
          "A1": [
            "MOVT{<c>}{<q>} <Rd>, #<imm16>"
          ],
          "T1": [
            "MOVT{<c>}{<q>} <Rd>, #<imm16>"
          ]
        }
      },
      "MOV_i": {
        "authored": "Move (immediate) writes an immediate value to the destination register.\n\nIf the destination register is not the PC, the MOVS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The MOV variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The MOVS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "MOV, MOVS (immediate)",
        "templates": {
          "A1": [
            "MOV{<c>}{<q>} <Rd>, #<const>",
            "MOVS{<c>}{<q>} <Rd>, #<const>"
          ],
          "A2": [
            "MOV{<c>}{<q>} <Rd>, #<imm16>",
            "MOVW{<c>}{<q>} <Rd>, #<imm16>"
          ],
          "T1": [
            "MOV<c>{<q>} <Rd>, #<imm8>",
            "MOVS{<q>} <Rd>, #<imm8>"
          ],
          "T2": [
            "MOV<c>.W <Rd>, #<const>",
            "MOV{<c>}{<q>} <Rd>, #<const>",
            "MOVS.W <Rd>, #<const>",
            "MOVS{<c>}{<q>} <Rd>, #<const>"
          ],
          "T3": [
            "MOV{<c>}{<q>} <Rd>, #<imm16>",
            "MOVW{<c>}{<q>} <Rd>, #<imm16>"
          ]
        }
      },
      "MOV_r": {
        "authored": "Move (register) copies a value from a register to the destination register.\n\nIf the destination register is not the PC, the MOVS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. If the destination register is the PC:\n  - The MOV variant of the instruction is a branch. In the T32 instruction set\n(encoding T1) this is a simple branch, and in the A32 instruction set it is an\ninterworking branch, see Pseudocode description of operations on the AArch32\ngeneral-purpose registers and the PC.\n  - The MOVS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "MOV, MOVS (register)",
        "templates": {
          "A1": [
            "MOV{<c>}{<q>} <Rd>, <Rm>, RRX",
            "MOV{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}",
            "MOVS{<c>}{<q>} <Rd>, <Rm>, RRX",
            "MOVS{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "MOV{<c>}{<q>} <Rd>, <Rm>"
          ],
          "T2": [
            "MOV<c>{<q>} <Rd>, <Rm> {, <shift> #<amount>}",
            "MOVS{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
          ],
          "T3": [
            "MOV{<c>}{<q>} <Rd>, <Rm>, RRX",
            "MOV{<c>}.W <Rd>, <Rm> {, LSL #0}",
            "MOV<c>.W <Rd>, <Rm> {, <shift> #<amount>}",
            "MOV{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}",
            "MOVS{<c>}{<q>} <Rd>, <Rm>, RRX",
            "MOVS.W <Rd>, <Rm> {, <shift> #<amount>}",
            "MOVS{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "MOV_rr": {
        "authored": "Move (register-shifted register) copies a register-shifted register value to the\ndestination register. It can optionally update the condition flags based on the\nvalue.",
        "heading": "MOV, MOVS (register-shifted register)",
        "templates": {
          "A1": [
            "MOVS{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>",
            "MOV{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>"
          ],
          "T1": [
            "MOV<c>{<q>} <Rdm>, <Rdm>, ASR <Rs>",
            "MOVS{<q>} <Rdm>, <Rdm>, ASR <Rs>",
            "MOV<c>{<q>} <Rdm>, <Rdm>, LSL <Rs>",
            "MOVS{<q>} <Rdm>, <Rdm>, LSL <Rs>",
            "MOV<c>{<q>} <Rdm>, <Rdm>, LSR <Rs>",
            "MOVS{<q>} <Rdm>, <Rdm>, LSR <Rs>",
            "MOV<c>{<q>} <Rdm>, <Rdm>, ROR <Rs>",
            "MOVS{<q>} <Rdm>, <Rdm>, ROR <Rs>"
          ],
          "T2": [
            "MOVS.W <Rd>, <Rm>, <type> <Rs>",
            "MOVS{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>",
            "MOV<c>.W <Rd>, <Rm>, <type> <Rs>",
            "MOV{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "MRC": {
        "authored": "Move to general-purpose register from System register. This instruction copies\nthe value of a System register to a general-purpose register.\n\nThe System register descriptions identify valid encodings for this instruction.\nOther encodings are undefined. For more information see About the AArch32 System\nregister interface and General behavior of System registers.\n\nIn an implementation that includes EL2, MRC accesses to system control registers\ncan be trapped to Hyp mode, meaning that an attempt to execute an MRC\ninstruction in a Non-secure mode other than Hyp mode, that would be permitted in\nthe absence of the Hyp trap controls, generates a Hyp Trap exception.  For more\ninformation, see EL2 configurable instruction enables, disables, and traps.\n\nBecause of the range of possible traps to Hyp mode, the MRC pseudocode does not\nshow these possible traps.",
        "heading": "MRC",
        "templates": {
          "A1": [
            "MRC{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}"
          ],
          "T1": [
            "MRC{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <CRn>, <CRm>{, {#}<opc2>}"
          ]
        }
      },
      "MRRC": {
        "authored": "Move to two general-purpose registers from System register. This instruction\ncopies the value of a System register to two general-purpose registers.\n\nThe System register descriptions identify valid encodings for this instruction.\nOther encodings are undefined. For more information see About the AArch32 System\nregister interface and General behavior of System registers.\n\nIn an implementation that includes EL2, MRRC accesses to System registers can be\ntrapped to Hyp mode, meaning that an attempt to execute an MRRC instruction in a\nNon-secure mode other than Hyp mode, that would be permitted in the absence of\nthe Hyp trap controls, generates a Hyp Trap exception.  For more information,\nsee EL2 configurable instruction enables, disables, and traps.\n\nBecause of the range of possible traps to Hyp mode, the MRRC pseudocode does not\nshow these possible traps.",
        "heading": "MRRC",
        "templates": {
          "A1": [
            "MRRC{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>"
          ],
          "T1": [
            "MRRC{<c>}{<q>} <coproc>, {#}<opc1>, <Rt>, <Rt2>, <CRm>"
          ]
        }
      },
      "MRS": {
        "authored": "Move Special register to general-purpose register moves the value of the APSR,\nCPSR, or SPSR_<current_mode> into a general-purpose register.\n\nARM recommends the APSR form when only the N, Z, C, V, Q, and GE[3:0] bits are\nbeing written. For more information, see APSR.\n\nAn MRS that accesses the SPSRs is unpredictable if executed in User mode or\nSystem mode.\n\nAn MRS that is executed in User mode and accesses the CPSR returns an unknown\nvalue for the CPSR.{E, A, I, F, M} fields.",
        "heading": "MRS",
        "templates": {
          "A1": [
            "MRS{<c>}{<q>} <Rd>, <spec_reg>"
          ],
          "T1": [
            "MRS{<c>}{<q>} <Rd>, <spec_reg>"
          ]
        }
      },
      "MRS_br": {
        "authored": "Move to Register from Banked or Special register moves the value from the Banked\ngeneral-purpose register or Saved Program Status Registers (SPSRs) of the\nspecified mode, or the value of ELR_hyp, to a general-purpose register.\n\nMRS (Banked register) is unpredictable if executed in User mode.\n\nWhen EL3 is using AArch64, if an MRS (Banked register) instruction that is\nexecuted in a Secure EL1 mode would access SPSR_mon, SP_mon, or LR_mon, it is\ntrapped to EL3.\n\nThe effect of using an MRS (Banked register) instruction with a register\nargument that is not valid for the current mode is unpredictable. For more\ninformation see Usage restrictions on the Banked register transfer instructions.",
        "heading": "MRS (Banked register)",
        "templates": {
          "A1": [
            "MRS{<c>}{<q>} <Rd>, <banked_reg>"
          ],
          "T1": [
            "MRS{<c>}{<q>} <Rd>, <banked_reg>"
          ]
        }
      },
      "MSR_br": {
        "authored": "Move to Banked or Special register from general-purpose register moves the value\nof a general-purpose register to the Banked general-purpose register or Saved\nProgram Status Registers (SPSRs) of the specified mode, or to ELR_hyp.\n\nMSR (Banked register) is unpredictable if executed in User mode.\n\nWhen EL3 is using AArch64, if an MSR (Banked register) instruction that is\nexecuted in a Secure EL1 mode would access SPSR_mon, SP_mon, or LR_mon, it is\ntrapped to EL3.\n\nThe effect of using an MSR (Banked register) instruction with a register\nargument that is not valid for the current mode is unpredictable. For more\ninformation see Usage restrictions on the Banked register transfer instructions.",
        "heading": "MSR (Banked register)",
        "templates": {
          "A1": [
            "MSR{<c>}{<q>} <banked_reg>, <Rn>"
          ],
          "T1": [
            "MSR{<c>}{<q>} <banked_reg>, <Rn>"
          ]
        }
      },
      "MSR_i": {
        "authored": "Move immediate value to Special register moves selected bits of an immediate\nvalue to the corresponding bits in the APSR, CPSR, or SPSR_<current_mode>.\n\nBecause of the Do-Not-Modify nature of its reserved bits, the immediate form of\nMSR is normally only useful at the Application level for writing to APSR_nzcvq\n(CPSR_f).\n\nIf an MSR (immediate) moves selected bits of an immediate value to the CPSR, the\nPE checks whether the value being written to PSTATE.M is legal. See Illegal\nchanges to PSTATE.M.\n\nAn MSR (immediate) executed in User mode:\n  - Is constrained unpredictable if it attempts to update the SPSR.\n  - Otherwise, does not update any CPSR field that is accessible only at EL1 or\nhigher,\n\nAn MSR (immediate) executed in System mode is constrained unpredictable if it\nattempts to update the SPSR.\n\nThe CPSR.E bit is writable from any mode using an MSR instruction.  ARM\ndeprecates using this to change its value.",
        "heading": "MSR (immediate)",
        "templates": {
          "A1": [
            "MSR{<c>}{<q>} <spec_reg>, #<imm>"
          ]
        }
      },
      "MSR_r": {
        "authored": "Move general-purpose register to Special register moves selected bits of a\ngeneral-purpose register to the APSR, CPSR or SPSR_<current_mode>.\n\nBecause of the Do-Not-Modify nature of its reserved bits, a read-modify-write\nsequence is normally required when the MSR instruction is being used at\nApplication level and its destination is not APSR_nzcvq (CPSR_f).\n\nIf an MSR (register) moves selected bits of an immediate value to the CPSR, the\nPE checks whether the value being written to PSTATE.M is legal. See Illegal\nchanges to PSTATE.M.\n\nAn MSR (register) executed in User mode:\n  - Is unpredictable if it attempts to update the SPSR.\n  - Otherwise, does not update any CPSR field that is accessible only at EL1 or\nhigher.\n\nAn MSR (register) executed in System mode is unpredictable if it attempts to\nupdate the SPSR.\n\nThe CPSR.E bit is writable from any mode using an MSR instruction.  ARM\ndeprecates using this to change its value.",
        "heading": "MSR (register)",
        "templates": {
          "A1": [
            "MSR{<c>}{<q>} <spec_reg>, <Rn>"
          ],
          "T1": [
            "MSR{<c>}{<q>} <spec_reg>, <Rn>"
          ]
        }
      },
      "MUL": {
        "authored": "Multiply multiplies two register values. The least significant 32 bits of the\nresult are written to the destination register. These 32 bits do not depend on\nwhether the source register values are considered to be signed values or\nunsigned values.\n\nOptionally, it can update the condition flags based on the result. In the T32\ninstruction set, this option is limited to only a few forms of the instruction.\nUse of this option adversely affects performance on many implementations.",
        "heading": "MUL, MULS",
        "templates": {
          "A1": [
            "MULS{<c>}{<q>} <Rd>, <Rn>{, <Rm>}",
            "MUL{<c>}{<q>} <Rd>, <Rn>{, <Rm>}"
          ],
          "T1": [
            "MUL<c>{<q>} <Rdm>, <Rn>{, <Rdm>}",
            "MULS{<q>} <Rdm>, <Rn>{, <Rdm>}"
          ],
          "T2": [
            "MUL<c>.W <Rd>, <Rn>{, <Rm>}",
            "MUL{<c>}{<q>} <Rd>, <Rn>{, <Rm>}"
          ]
        }
      },
      "MVN_i": {
        "authored": "Bitwise NOT (immediate) writes the bitwise inverse of an immediate value to the\ndestination register.\n\nIf the destination register is not the PC, the MVNS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The MVN variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The MVNS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "MVN, MVNS (immediate)",
        "templates": {
          "A1": [
            "MVN{<c>}{<q>} <Rd>, #<const>",
            "MVNS{<c>}{<q>} <Rd>, #<const>"
          ],
          "T1": [
            "MVN{<c>}{<q>} <Rd>, #<const>",
            "MVNS{<c>}{<q>} <Rd>, #<const>"
          ]
        }
      },
      "MVN_r": {
        "authored": "Bitwise NOT (register) writes the bitwise inverse of a register value to the\ndestination register.\n\nIf the destination register is not the PC, the MVNS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The MVN variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The MVNS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "MVN, MVNS (register)",
        "templates": {
          "A1": [
            "MVN{<c>}{<q>} <Rd>, <Rm>, RRX",
            "MVN{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}",
            "MVNS{<c>}{<q>} <Rd>, <Rm>, RRX",
            "MVNS{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "MVN<c>{<q>} <Rd>, <Rm>",
            "MVNS{<q>} <Rd>, <Rm>"
          ],
          "T2": [
            "MVN{<c>}{<q>} <Rd>, <Rm>, RRX",
            "MVN<c>.W <Rd>, <Rm>",
            "MVN{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}",
            "MVNS{<c>}{<q>} <Rd>, <Rm>, RRX",
            "MVNS.W <Rd>, <Rm>",
            "MVNS{<c>}{<q>} <Rd>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "MVN_rr": {
        "authored": "Bitwise NOT (register-shifted register) writes the bitwise inverse of a\nregister-shifted register value to the destination register. It can optionally\nupdate the condition flags based on the result.",
        "heading": "MVN, MVNS (register-shifted register)",
        "templates": {
          "A1": [
            "MVNS{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>",
            "MVN{<c>}{<q>} <Rd>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "NOP": {
        "authored": "No Operation does nothing. This instruction can be used for instruction\nalignment purposes.\n\nThe timing effects of including a NOP instruction in a program are not\nguaranteed. It can increase execution time, leave it unchanged, or even reduce\nit. Therefore, NOP instructions are not suitable for timing loops.",
        "heading": "NOP",
        "templates": {
          "A1": [
            "NOP{<c>}{<q>}"
          ],
          "T1": [
            "NOP{<c>}{<q>}"
          ],
          "T2": [
            "NOP{<c>}.W"
          ]
        }
      },
      "ORN_i": {
        "authored": "Bitwise OR NOT (immediate) performs a bitwise (inclusive) OR of a register value\nand the complement of an immediate value, and writes the result to the\ndestination register. It can optionally update the condition flags based on the\nresult.",
        "heading": "ORN, ORNS (immediate)",
        "templates": {
          "T1": [
            "ORNS{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "ORN{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ]
        }
      },
      "ORN_r": {
        "authored": "Bitwise OR NOT (register) performs a bitwise (inclusive) OR of a register value\nand the complement of an optionally-shifted register value, and writes the\nresult to the destination register. It can optionally update the condition flags\nbased on the result.",
        "heading": "ORN, ORNS (register)",
        "templates": {
          "T1": [
            "ORN{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ORN{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "ORNS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ORNS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "ORR_i": {
        "authored": "Bitwise OR (immediate) performs a bitwise (inclusive) OR of a register value and\nan immediate value, and writes the result to the destination register.\n\nIf the destination register is not the PC, the ORRS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The ORR variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The ORRS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "ORR, ORRS (immediate)",
        "templates": {
          "A1": [
            "ORR{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "ORRS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ],
          "T1": [
            "ORR{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "ORRS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ]
        }
      },
      "ORR_r": {
        "authored": "Bitwise OR (register) performs a bitwise (inclusive) OR of a register value and\nan optionally-shifted register value, and writes the result to the destination\nregister.\n\nIf the destination register is not the PC, the ORRS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The ORR variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The ORRS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "ORR, ORRS (register)",
        "templates": {
          "A1": [
            "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "ORR<c>{<q>} {<Rdn>,} <Rdn>, <Rm>",
            "ORRS{<q>} {<Rdn>,} <Rdn>, <Rm>"
          ],
          "T2": [
            "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ORR<c>.W {<Rd>,} <Rn>, <Rm>",
            "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "ORRS.W {<Rd>,} <Rn>, <Rm>",
            "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "ORR_rr": {
        "authored": "Bitwise OR (register-shifted register) performs a bitwise (inclusive) OR of a\nregister value and a register-shifted register value, and writes the result to\nthe destination register. It can optionally update the condition flags based on\nthe result.",
        "heading": "ORR, ORRS (register-shifted register)",
        "templates": {
          "A1": [
            "ORRS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>",
            "ORR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "PKH": {
        "authored": "Pack Halfword combines one halfword of its first operand with the other halfword\nof its shifted second operand.",
        "heading": "PKHBT, PKHTB",
        "templates": {
          "A1": [
            "PKHBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, LSL #<imm>}",
            "PKHTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ASR #<imm>}"
          ],
          "T1": [
            "PKHBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, LSL #<imm>}",
            "PKHTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ASR #<imm>}"
          ]
        }
      },
      "PLD_i": {
        "authored": "Preload Data (immediate) signals the memory system that data memory accesses\nfrom a specified address are likely in the near future. The memory system can\nrespond by taking actions that are expected to speed up the memory accesses when\nthey do occur, such as preloading the cache line containing the specified\naddress into the data cache.\n\nThe PLD instruction signals that the likely memory access is a read, and the\nPLDW instruction signals that it is a write.\n\nThe effect of a PLD or PLDW instruction is implementation defined.  For more\ninformation, see Preloading caches.",
        "heading": "PLD, PLDW (immediate)",
        "templates": {
          "A1": [
            "PLD{<c>}{<q>} [<Rn> {, #{+/-}<imm>}]",
            "PLDW{<c>}{<q>} [<Rn> {, #{+/-}<imm>}]"
          ],
          "T1": [
            "PLD{<c>}{<q>} [<Rn> {, #{+}<imm>}]",
            "PLDW{<c>}{<q>} [<Rn> {, #{+}<imm>}]"
          ],
          "T2": [
            "PLD{<c>}{<q>} [<Rn> {, #-<imm>}]",
            "PLDW{<c>}{<q>} [<Rn> {, #-<imm>}]"
          ]
        }
      },
      "PLD_l": {
        "authored": "Preload Data (literal) signals the memory system that data memory accesses from\na specified address are likely in the near future. The memory system can respond\nby taking actions that are expected to speed up the memory accesses when they do\noccur, such as preloading the cache line containing the specified address into\nthe data cache.\n\nThe effect of a PLD instruction is implementation defined.  For more\ninformation, see Preloading caches.",
        "heading": "PLD (literal)",
        "templates": {
          "A1": [
            "PLD{<c>}{<q>} <label>",
            "PLD{<c>}{<q>} [PC, #{+/-}<imm>]"
          ],
          "T1": [
            "PLD{<c>}{<q>} <label>",
            "PLD{<c>}{<q>} [PC, #{+/-}<imm>]"
          ]
        }
      },
      "PLD_r": {
        "authored": "Preload Data (register) signals the memory system that data memory accesses from\na specified address are likely in the near future. The memory system can respond\nby taking actions that are expected to speed up the memory accesses when they do\noccur, such as preloading the cache line containing the specified address into\nthe data cache.\n\nThe PLD instruction signals that the likely memory access is a read, and the\nPLDW instruction signals that it is a write.\n\nThe effect of a PLD or PLDW instruction is implementation defined.  For more\ninformation, see Preloading caches.",
        "heading": "PLD, PLDW (register)",
        "templates": {
          "A1": [
            "PLD{<c>}{<q>} [<Rn>, {+/-}<Rm> {, <shift> #<amount>}]",
            "PLD{<c>}{<q>} [<Rn>, {+/-}<Rm> , RRX]",
            "PLDW{<c>}{<q>} [<Rn>, {+/-}<Rm> {, <shift> #<amount>}]",
            "PLDW{<c>}{<q>} [<Rn>, {+/-}<Rm> , RRX]"
          ],
          "T1": [
            "PLD{<c>}{<q>} [<Rn>, {+}<Rm> {, LSL #<amount>}]",
            "PLDW{<c>}{<q>} [<Rn>, {+}<Rm> {, LSL #<amount>}]"
          ]
        }
      },
      "PLI_i": {
        "authored": "Preload Instruction signals the memory system that instruction memory accesses\nfrom a specified address are likely in the near future. The memory system can\nrespond by taking actions that are expected to speed up the memory accesses when\nthey do occur, such as pre-loading the cache line containing the specified\naddress into the instruction cache.\n\nThe effect of a PLI instruction is implementation defined. For more information,\nsee Preloading caches.",
        "heading": "PLI (immediate, literal)",
        "templates": {
          "A1": [
            "PLI{<c>}{<q>} [<Rn> {, #{+/-}<imm>}]",
            "PLI{<c>}{<q>} <label>",
            "PLI{<c>}{<q>} [PC, #{+/-}<imm>]"
          ],
          "T1": [
            "PLI{<c>}{<q>} [<Rn> {, #{+}<imm>}]"
          ],
          "T2": [
            "PLI{<c>}{<q>} [<Rn> {, #-<imm>}]"
          ],
          "T3": [
            "PLI{<c>}{<q>} <label>",
            "PLI{<c>}{<q>} [PC, #{+/-}<imm>]"
          ]
        }
      },
      "PLI_r": {
        "authored": "Preload Instruction signals the memory system that instruction memory accesses\nfrom a specified address are likely in the near future. The memory system can\nrespond by taking actions that are expected to speed up the memory accesses when\nthey do occur, such as pre-loading the cache line containing the specified\naddress into the instruction cache.\n\nThe effect of a PLI instruction is implementation defined. For more information,\nsee Preloading caches.",
        "heading": "PLI (register)",
        "templates": {
          "A1": [
            "PLI{<c>}{<q>} [<Rn>, {+/-}<Rm> , RRX]",
            "PLI{<c>}{<q>} [<Rn>, {+/-}<Rm> {, <shift> #<amount>}]"
          ],
          "T1": [
            "PLI{<c>}{<q>} [<Rn>, {+}<Rm> {, LSL #<amount>}]"
          ]
        }
      },
      "POP": {
        "authored": "Pop Multiple Registers from Stack loads multiple general-purpose registers from\nthe stack, loading from consecutive memory locations starting at the address in\nSP, and updates SP to point just above the loaded data.\n\nThe lowest-numbered register is loaded from the lowest memory address, through\nto the highest-numbered register from the highest memory address. See also\nEncoding of lists of general-purpose registers and the PC.\n\nThe registers loaded can include the PC, causing a branch to a loaded address.\nThis is an interworking branch, see Pseudocode description of operations on the\nAArch32 general-purpose registers and the PC.",
        "heading": "POP",
        "templates": {
          "T1": [
            "POP{<c>}{<q>} <registers>",
            "LDM{<c>}{<q>} SP!, <registers>"
          ]
        }
      },
      "POP_LDM": {
        "authored": " loads multiple general-purpose registers from the stack, loading from\nconsecutive memory locations starting at the address in SP, and updates SP to\npoint just above the loaded data",
        "heading": "POP (multiple registers)",
        "templates": {
          "A1": [
            "POP{<c>}{<q>} <registers>"
          ],
          "T2": [
            "POP{<c>}.W <registers>",
            "POP{<c>}{<q>} <registers>"
          ]
        }
      },
      "POP_LDR_i": {
        "authored": " loads a single general-purpose register from the stack, loading from the\naddress in SP, and updates SP to point just above the loaded data",
        "heading": "POP (single register)",
        "templates": {
          "A1": [
            "POP{<c>}{<q>} <single_register_list>"
          ],
          "T4": [
            "POP{<c>}{<q>} <single_register_list>"
          ]
        }
      },
      "PSSBB": {
        "authored": "Physical Speculative Store Bypass Barrier is a memory barrier which prevents\nspeculative loads from bypassing earlier stores to the same physical address.\n\nThe semantics of the Physical Speculative Store Bypass Barrier are:\n  - When a load to a location appears in program order after the PSSBB, then the\nload does not speculatively read an entry earlier in the coherence order for\nthat location than the entry generated by the latest store satisfying all of the\nfollowing conditions:\n    - The store is to the same location as the load.\n    - The store appears in program order before the PSSBB.\n  - When a load to a location appears in program order before the PSSBB, then\nthe load does not speculatively read data from any store satisfying all of the\nfollowing conditions:\n    - The store is to the same location as the load.\n    - The store appears in program order after the PSSBB.",
        "heading": "PSSBB",
        "templates": {
          "A1": [
            "PSSBB{<q>}"
          ],
          "T1": [
            "PSSBB{<q>}"
          ]
        }
      },
      "PUSH": {
        "authored": "Push Multiple Registers to Stack stores multiple general-purpose registers to\nthe stack, storing to consecutive memory locations ending just below the address\nin SP, and updates SP to point to the start of the stored data.\n\nThe lowest-numbered register is stored to the lowest memory address, through to\nthe highest-numbered register to the highest memory address. See also Encoding\nof lists of general-purpose registers and the PC.",
        "heading": "PUSH",
        "templates": {
          "T1": [
            "PUSH{<c>}{<q>} <registers>",
            "STMDB{<c>}{<q>} SP!, <registers>"
          ]
        }
      },
      "PUSH_STMDB": {
        "authored": " stores multiple general-purpose registers to the stack, storing to consecutive\nmemory locations ending just below the address in SP, and updates SP to point to\nthe start of the stored data",
        "heading": "PUSH (multiple registers)",
        "templates": {
          "A1": [
            "PUSH{<c>}{<q>} <registers>"
          ],
          "T1": [
            "PUSH{<c>}.W <registers>",
            "PUSH{<c>}{<q>} <registers>"
          ]
        }
      },
      "PUSH_STR_i": {
        "authored": " stores a single general-purpose register to the stack, storing to the 32-bit\nword below the address in SP, and updates SP to point to the start of the stored\ndata",
        "heading": "PUSH (single register)",
        "templates": {
          "A1": [
            "PUSH{<c>}{<q>} <single_register_list>"
          ],
          "T4": [
            "PUSH{<c>}{<q>} <single_register_list>"
          ]
        }
      },
      "QADD": {
        "authored": "Saturating Add adds two register values, saturates the result to the 32-bit\nsigned integer range -2^31 to (2^31 - 1), and writes the result to the\ndestination register. If saturation occurs, it sets PSTATE.Q to 1.",
        "heading": "QADD",
        "templates": {
          "A1": [
            "QADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
          ],
          "T1": [
            "QADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
          ]
        }
      },
      "QADD16": {
        "authored": "Saturating Add 16 performs two 16-bit integer additions, saturates the results\nto the 16-bit signed integer range -2^15 <= x <= 2^15 - 1, and writes the\nresults to the destination register.",
        "heading": "QADD16",
        "templates": {
          "A1": [
            "QADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "QADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "QADD8": {
        "authored": "Saturating Add 8 performs four 8-bit integer additions, saturates the results to\nthe 8-bit signed integer range -2^7 <= x <= 2^7 - 1, and writes the results to\nthe destination register.",
        "heading": "QADD8",
        "templates": {
          "A1": [
            "QADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "QADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "QASX": {
        "authored": "Saturating Add and Subtract with Exchange exchanges the two halfwords of the\nsecond operand, performs one 16-bit integer addition and one 16-bit subtraction,\nsaturates the results to the 16-bit signed integer range -2^15 <= x <= 2^15 - 1,\nand writes the results to the destination register.",
        "heading": "QASX",
        "templates": {
          "A1": [
            "QASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "QASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "QDADD": {
        "authored": "Saturating Double and Add adds a doubled register value to another register\nvalue, and writes the result to the destination register. Both the doubling and\nthe addition have their results saturated to the 32-bit signed integer range\n-2^31 <= x <= 2^31 - 1. If saturation occurs in either operation, it sets\nPSTATE.Q to 1.",
        "heading": "QDADD",
        "templates": {
          "A1": [
            "QDADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
          ],
          "T1": [
            "QDADD{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
          ]
        }
      },
      "QDSUB": {
        "authored": "Saturating Double and Subtract subtracts a doubled register value from another\nregister value, and writes the result to the destination register. Both the\ndoubling and the subtraction have their results saturated to the 32-bit signed\ninteger range -2^31 <= x <= 2^31 - 1. If saturation occurs in either operation,\nit sets PSTATE.Q to 1.",
        "heading": "QDSUB",
        "templates": {
          "A1": [
            "QDSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
          ],
          "T1": [
            "QDSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
          ]
        }
      },
      "QSAX": {
        "authored": "Saturating Subtract and Add with Exchange exchanges the two halfwords of the\nsecond operand, performs one 16-bit integer subtraction and one 16-bit addition,\nsaturates the results to the 16-bit signed integer range -2^15 <= x <= 2^15 - 1,\nand writes the results to the destination register.",
        "heading": "QSAX",
        "templates": {
          "A1": [
            "QSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "QSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "QSUB": {
        "authored": "Saturating Subtract subtracts one register value from another register value,\nsaturates the result to the 32-bit signed integer range -2^31 <= x <= 2^31 - 1,\nand writes the result to the destination register. If saturation occurs, it sets\nPSTATE.Q to 1.",
        "heading": "QSUB",
        "templates": {
          "A1": [
            "QSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
          ],
          "T1": [
            "QSUB{<c>}{<q>} {<Rd>,} <Rm>, <Rn>"
          ]
        }
      },
      "QSUB16": {
        "authored": "Saturating Subtract 16 performs two 16-bit integer subtractions, saturates the\nresults to the 16-bit signed integer range -2^15 <= x <= 2^15 - 1, and writes\nthe results to the destination register.",
        "heading": "QSUB16",
        "templates": {
          "A1": [
            "QSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "QSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "QSUB8": {
        "authored": "Saturating Subtract 8 performs four 8-bit integer subtractions, saturates the\nresults to the 8-bit signed integer range -2^7 <= x <= 2^7 - 1, and writes the\nresults to the destination register.",
        "heading": "QSUB8",
        "templates": {
          "A1": [
            "QSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "QSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "RBIT": {
        "authored": "Reverse Bits reverses the bit order in a 32-bit register.",
        "heading": "RBIT",
        "templates": {
          "A1": [
            "RBIT{<c>}{<q>} <Rd>, <Rm>"
          ],
          "T1": [
            "RBIT{<c>}{<q>} <Rd>, <Rm>"
          ]
        }
      },
      "REV": {
        "authored": "Byte-Reverse Word reverses the byte order in a 32-bit register.",
        "heading": "REV",
        "templates": {
          "A1": [
            "REV{<c>}{<q>} <Rd>, <Rm>"
          ],
          "T1": [
            "REV{<c>}{<q>} <Rd>, <Rm>"
          ],
          "T2": [
            "REV{<c>}.W <Rd>, <Rm>",
            "REV{<c>}{<q>} <Rd>, <Rm>"
          ]
        }
      },
      "REV16": {
        "authored": "Byte-Reverse Packed Halfword reverses the byte order in each16-bit halfword of a\n32-bit register.",
        "heading": "REV16",
        "templates": {
          "A1": [
            "REV16{<c>}{<q>} <Rd>, <Rm>"
          ],
          "T1": [
            "REV16{<c>}{<q>} <Rd>, <Rm>"
          ],
          "T2": [
            "REV16{<c>}.W <Rd>, <Rm>",
            "REV16{<c>}{<q>} <Rd>, <Rm>"
          ]
        }
      },
      "REVSH": {
        "authored": "Byte-Reverse Signed Halfword reverses the byte order in the lower 16-bit\nhalfword of a 32-bit register, and sign-extends the result to 32 bits.",
        "heading": "REVSH",
        "templates": {
          "A1": [
            "REVSH{<c>}{<q>} <Rd>, <Rm>"
          ],
          "T1": [
            "REVSH{<c>}{<q>} <Rd>, <Rm>"
          ],
          "T2": [
            "REVSH{<c>}.W <Rd>, <Rm>",
            "REVSH{<c>}{<q>} <Rd>, <Rm>"
          ]
        }
      },
      "RFE": {
        "authored": "Return From Exception loads two consecutive memory locations using an address in\na base register:\n  - The word loaded from the lower address is treated as an instruction address.\nThe PE branches to it.\n  - The word loaded from the higher address is used to restore PSTATE. This word\nmust be in the format of an SPSR.\n\nAn address adjusted by the size of the data loaded can optionally be written\nback to the base register.\n\nThe PE checks the value of the word loaded from the higher address for an\nillegal return event. See Illegal return events from AArch32 state.\n\nRFE is undefined in Hyp mode and constrained unpredictable in User mode.",
        "heading": "RFE, RFEDA, RFEDB, RFEIA, RFEIB",
        "templates": {
          "A1": [
            "RFEDA{<c>}{<q>} <Rn>{!}",
            "RFEDB{<c>}{<q>} <Rn>{!}",
            "RFE{IA}{<c>}{<q>} <Rn>{!}",
            "RFEIB{<c>}{<q>} <Rn>{!}"
          ],
          "T1": [
            "RFEDB{<c>}{<q>} <Rn>{!}"
          ],
          "T2": [
            "RFE{IA}{<c>}{<q>} <Rn>{!}"
          ]
        }
      },
      "RORS_MOV_r": {
        "authored": "Rotate Right, setting flags (immediate) provides the value of the contents of a\nregister rotated by a constant value. The bits that are rotated off the right\nend are inserted into the vacated bit positions on the left.\n\nIf the destination register is not the PC, this instruction updates the\ncondition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n  - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n  - The instruction is undefined in Hyp mode.\n  - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "RORS (immediate)",
        "templates": {
          "A1": [
            "RORS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T3": [
            "RORS{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ]
        }
      },
      "RORS_MOV_rr": {
        "authored": " provides the value of the contents of a register rotated by a variable number\nof bits, and updates the condition flags based on the result. The bits that are\nrotated off the right end are inserted into the vacated bit positions on the\nleft. The variable number of bits is read from the bottom byte of a register",
        "heading": "RORS (register)",
        "templates": {
          "A1": [
            "RORS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ],
          "T1": [
            "RORS{<q>} {<Rdm>,} <Rdm>, <Rs>"
          ],
          "T2": [
            "RORS.W {<Rd>,} <Rm>, <Rs>",
            "RORS{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ]
        }
      },
      "ROR_MOV_r": {
        "authored": "Rotate Right (immediate) provides the value of the contents of a register\nrotated by a constant value. The bits that are rotated off the right end are\ninserted into the vacated bit positions on the left.",
        "heading": "ROR (immediate)",
        "templates": {
          "A1": [
            "ROR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ],
          "T3": [
            "ROR{<c>}{<q>} {<Rd>,} <Rm>, #<imm>"
          ]
        }
      },
      "ROR_MOV_rr": {
        "authored": " provides the value of the contents of a register rotated by a variable number\nof bits. The bits that are rotated off the right end are inserted into the\nvacated bit positions on the left. The variable number of bits is read from the\nbottom byte of a register",
        "heading": "ROR (register)",
        "templates": {
          "A1": [
            "ROR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ],
          "T1": [
            "ROR<c>{<q>} {<Rdm>,} <Rdm>, <Rs>"
          ],
          "T2": [
            "ROR<c>.W {<Rd>,} <Rm>, <Rs>",
            "ROR{<c>}{<q>} {<Rd>,} <Rm>, <Rs>"
          ]
        }
      },
      "RRXS_MOV_r": {
        "authored": "Rotate Right with Extend, setting flags provides the value of the contents of a\nregister shifted right by one place, with the Carry flag shifted into bit[31].\n\nIf the destination register is not the PC, this instruction updates the\ncondition flags based on the result, and bit[0] is shifted into the Carry flag.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n  - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n  - The instruction is undefined in Hyp mode.\n  - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "RRXS",
        "templates": {
          "A1": [
            "RRXS{<c>}{<q>} {<Rd>,} <Rm>"
          ],
          "T3": [
            "RRXS{<c>}{<q>} {<Rd>,} <Rm>"
          ]
        }
      },
      "RRX_MOV_r": {
        "authored": "Rotate Right with Extend provides the value of the contents of a register\nshifted right by one place, with the Carry flag shifted into bit[31].",
        "heading": "RRX",
        "templates": {
          "A1": [
            "RRX{<c>}{<q>} {<Rd>,} <Rm>"
          ],
          "T3": [
            "RRX{<c>}{<q>} {<Rd>,} <Rm>"
          ]
        }
      },
      "RSB_i": {
        "authored": "Reverse Subtract (immediate) subtracts a register value from an immediate value,\nand writes the result to the destination register.\n\nIf the destination register is not the PC, the RSBS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The RSB variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The RSBS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "RSB, RSBS (immediate)",
        "templates": {
          "A1": [
            "RSB{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "RSBS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ],
          "T1": [
            "RSB<c>{<q>} {<Rd>, }<Rn>, #0",
            "RSBS{<q>} {<Rd>, }<Rn>, #0"
          ],
          "T2": [
            "RSB<c>.W {<Rd>,} <Rn>, #0",
            "RSB{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "RSBS.W {<Rd>,} <Rn>, #0",
            "RSBS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ]
        }
      },
      "RSB_r": {
        "authored": "Reverse Subtract (register) subtracts a register value from an optionally-\nshifted register value, and writes the result to the destination register.\n\nIf the destination register is not the PC, the RSBS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The RSB variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The RSBS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "RSB, RSBS (register)",
        "templates": {
          "A1": [
            "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "RSB_rr": {
        "authored": "Reverse Subtract (register-shifted register) subtracts a register value from a\nregister-shifted register value, and writes the result to the destination\nregister. It can optionally update the condition flags based on the result.",
        "heading": "RSB, RSBS (register-shifted register)",
        "templates": {
          "A1": [
            "RSBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>",
            "RSB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "RSC_i": {
        "authored": "Reverse Subtract with Carry (immediate) subtracts a register value and the value\nof NOT (Carry flag) from an immediate value, and writes the result to the\ndestination register.\n\nIf the destination register is not the PC, the RSCS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The RSC variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The RSCS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "RSC, RSCS (immediate)",
        "templates": {
          "A1": [
            "RSC{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "RSCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ]
        }
      },
      "RSC_r": {
        "authored": "Reverse Subtract with Carry (register) subtracts a register value and the value\nof NOT (Carry flag) from an optionally-shifted register value, and writes the\nresult to the destination register.\n\nIf the destination register is not the PC, the RSCS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The RSC variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The RSCS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "RSC, RSCS (register)",
        "templates": {
          "A1": [
            "RSC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "RSC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "RSCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "RSCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "RSC_rr": {
        "authored": "Reverse Subtract (register-shifted register) subtracts a register value and the\nvalue of NOT (Carry flag) from a register-shifted register value, and writes the\nresult to the destination register. It can optionally update the condition flags\nbased on the result.",
        "heading": "RSC, RSCS (register-shifted register)",
        "templates": {
          "A1": [
            "RSCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>",
            "RSC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "SADD16": {
        "authored": "Signed Add 16 performs two 16-bit signed integer additions, and writes the\nresults to the destination register. It sets PSTATE.GE according to the results\nof the additions.",
        "heading": "SADD16",
        "templates": {
          "A1": [
            "SADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SADD8": {
        "authored": "Signed Add 8 performs four 8-bit signed integer additions, and writes the\nresults to the destination register. It sets PSTATE.GE according to the results\nof the additions.",
        "heading": "SADD8",
        "templates": {
          "A1": [
            "SADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SASX": {
        "authored": "Signed Add and Subtract with Exchange exchanges the two halfwords of the second\noperand, performs one 16-bit integer addition and one 16-bit subtraction, and\nwrites the results to the destination register. It sets PSTATE.GE according to\nthe results.",
        "heading": "SASX",
        "templates": {
          "A1": [
            "SASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SB": {
        "authored": "Speculation Barrier is a barrier that controls speculation.\n\nThe semantics of the Speculation Barrier are that the execution, until the\nbarrier completes, of any instruction that appears later in the program order\nthan the barrier:\n  - Cannot be performed speculatively to the extent that such speculation can be\nobserved through side-channels as a result of control flow speculation or data\nvalue speculation.\n  - Can be speculatively executed as a result of predicting that a potentially\nexception generating instruction has not generated an exception.\n\nIn particular, any instruction that appears later in the program order than the\nbarrier cannot cause a speculative allocation into any caching structure where\nthe allocation of that entry could be indicative of any data value present in\nmemory or in the registers.\n\nThe SB instruction:\n  - Cannot be speculatively executed as a result of control flow speculation or\ndata value speculation.\n  - Can be speculatively executed as a result of predicting that a potentially\nexception generating instruction has not generated an exception. The potentially\nexception generating instruc$\n\nWhen the prediction of the instruction stream is not informed by data taken from\nthe register outputs of the speculative execution of instructions appearing in\nprogram order after an uncompleted SB instruction, the SB instruction has no\neffect on the use of prediction resources to predict the instruction stream that\nis being fetched.",
        "heading": "SB",
        "templates": {
          "A1": [
            "SB{<q>}"
          ],
          "T1": [
            "SB{<q>}"
          ]
        }
      },
      "SBC_i": {
        "authored": "Subtract with Carry (immediate) subtracts an immediate value and the value of\nNOT (Carry flag) from a register value, and writes the result to the destination\nregister.\n\nIf the destination register is not the PC, the SBCS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The SBC variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The SBCS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "SBC, SBCS (immediate)",
        "templates": {
          "A1": [
            "SBC{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "SBCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ],
          "T1": [
            "SBC{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "SBCS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ]
        }
      },
      "SBC_r": {
        "authored": "Subtract with Carry (register) subtracts an optionally-shifted register value\nand the value of NOT (Carry flag) from a register value, and writes the result\nto the destination register.\n\nIf the destination register is not the PC, the SBCS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. ARM deprecates any use of these encodings. However,\nwhen the destination register is the PC:\n  - The SBC variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The SBCS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "SBC, SBCS (register)",
        "templates": {
          "A1": [
            "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "SBC<c>{<q>} {<Rdn>,} <Rdn>, <Rm>",
            "SBCS{<q>} {<Rdn>,} <Rdn>, <Rm>"
          ],
          "T2": [
            "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "SBC<c>.W {<Rd>,} <Rn>, <Rm>",
            "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "SBCS.W {<Rd>,} <Rn>, <Rm>",
            "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "SBC_rr": {
        "authored": "Subtract with Carry (register-shifted register) subtracts a register-shifted\nregister value and the value of NOT (Carry flag) from a register value, and\nwrites the result to the destination register. It can optionally update the\ncondition flags based on the result.",
        "heading": "SBC, SBCS (register-shifted register)",
        "templates": {
          "A1": [
            "SBCS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>",
            "SBC{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "SBFX": {
        "authored": "Signed Bit Field Extract extracts any number of adjacent bits at any position\nfrom a register, sign-extends them to 32 bits, and writes the result to the\ndestination register.",
        "heading": "SBFX",
        "templates": {
          "A1": [
            "SBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>"
          ],
          "T1": [
            "SBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>"
          ]
        }
      },
      "SDIV": {
        "authored": "Signed Divide divides a 32-bit signed integer register value by a 32-bit signed\ninteger register value, and writes the result to the destination register. The\ncondition flags are not affected.",
        "heading": "SDIV",
        "templates": {
          "A1": [
            "SDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SEL": {
        "authored": "Select Bytes selects each byte of its result from either its first operand or\nits second operand, according to the values of the PSTATE.GE flags.",
        "heading": "SEL",
        "templates": {
          "A1": [
            "SEL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SEL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SETEND": {
        "authored": "Set Endianness writes a new value to PSTATE.E.",
        "heading": "SETEND",
        "templates": {
          "A1": [
            "SETEND{<q>} <endian_specifier>"
          ],
          "T1": [
            "SETEND{<q>} <endian_specifier>"
          ]
        }
      },
      "SETPAN": {
        "authored": "Set Privileged Access Never writes a new value to PSTATE.PAN.\n\nThis instruction is available only in privileged mode and it is a NOP when\nexecuted in User mode.",
        "heading": "SETPAN",
        "templates": {
          "A1": [
            "SETPAN{<q>} #<imm>"
          ],
          "T1": [
            "SETPAN{<q>} #<imm>"
          ]
        }
      },
      "SEV": {
        "authored": "Send Event is a hint instruction. It causes an event to be signaled to all PEs\nin the multiprocessor system. For more information, see Wait For Event and Send\nEvent.",
        "heading": "SEV",
        "templates": {
          "A1": [
            "SEV{<c>}{<q>}"
          ],
          "T1": [
            "SEV{<c>}{<q>}"
          ],
          "T2": [
            "SEV{<c>}.W"
          ]
        }
      },
      "SEVL": {
        "authored": "Send Event Local is a hint instruction that causes an event to be signaled\nlocally without requiring the event to be signaled to other PEs in the\nmultiprocessor system. It can prime a wait-loop which starts with a WFE\ninstruction.",
        "heading": "SEVL",
        "templates": {
          "A1": [
            "SEVL{<c>}{<q>}"
          ],
          "T1": [
            "SEVL{<c>}{<q>}"
          ],
          "T2": [
            "SEVL{<c>}.W"
          ]
        }
      },
      "SHADD16": {
        "authored": "Signed Halving Add 16 performs two signed 16-bit integer additions, halves the\nresults, and writes the results to the destination register.",
        "heading": "SHADD16",
        "templates": {
          "A1": [
            "SHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SHADD8": {
        "authored": "Signed Halving Add 8 performs four signed 8-bit integer additions, halves the\nresults, and writes the results to the destination register.",
        "heading": "SHADD8",
        "templates": {
          "A1": [
            "SHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SHASX": {
        "authored": "Signed Halving Add and Subtract with Exchange exchanges the two halfwords of the\nsecond operand, performs one signed 16-bit integer addition and one signed\n16-bit subtraction, halves the results, and writes the results to the\ndestination register.",
        "heading": "SHASX",
        "templates": {
          "A1": [
            "SHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SHSAX": {
        "authored": "Signed Halving Subtract and Add with Exchange exchanges the two halfwords of the\nsecond operand, performs one signed 16-bit integer subtraction and one signed\n16-bit addition, halves the results, and writes the results to the destination\nregister.",
        "heading": "SHSAX",
        "templates": {
          "A1": [
            "SHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SHSUB16": {
        "authored": "Signed Halving Subtract 16 performs two signed 16-bit integer subtractions,\nhalves the results, and writes the results to the destination register.",
        "heading": "SHSUB16",
        "templates": {
          "A1": [
            "SHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SHSUB8": {
        "authored": "Signed Halving Subtract 8 performs four signed 8-bit integer subtractions,\nhalves the results, and writes the results to the destination register.",
        "heading": "SHSUB8",
        "templates": {
          "A1": [
            "SHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SMC": {
        "authored": "Secure Monitor Call causes a Secure Monitor Call exception.  For more\ninformation see Secure Monitor Call (SMC) exception.\n\nSMC is available only for software executing at EL1 or higher. It is undefined\nin User mode.\n\nIf the values of HCR.TSC and SCR.SCD are both 0, execution of an SMC instruction\nat EL1 or higher generates a Secure Monitor Call exception that is taken to EL3.\nWhen EL3 is using AArch32 this exception is taken to Monitor mode. When EL3 is\nusing AArch64, it is the SCR_EL3.SMD bit, rather than the SCR.SCD bit, that can\nchange the effect of executing an SMC instruction.\n\nIf the value of HCR.TSC is 1, execution of an SMC instruction in a Non-secure\nEL1 mode generates an exception that is taken to EL2, regardless of the value of\nSCR.SCD. When EL2 is using AArch32, this is a Hyp Trap exception that is taken\nto Hyp mode. For more information see Traps to Hyp mode of Non-secure EL1\nexecution of SMC instructions.\n\nIf the value of HCR.TSC is 0 and the value of SCR.SCD is 1, the SMC instruction\nis:\n  - undefined in Non-secure state.\n  - constrained unpredictable if executed in Secure state at EL1 or higher.",
        "heading": "SMC",
        "templates": {
          "A1": [
            "SMC{<c>}{<q>} {#}<imm4>"
          ],
          "T1": [
            "SMC{<c>}{<q>} {#}<imm4>"
          ]
        }
      },
      "SMLABB": {
        "authored": "Signed Multiply Accumulate (halfwords) performs a signed multiply accumulate\noperation. The multiply acts on two signed 16-bit quantities, taken from either\nthe bottom or the top half of their respective source registers. The other\nhalves of these source registers are ignored.  The 32-bit product is added to a\n32-bit accumulate value and the result is written to the destination register.\n\nIf overflow occurs during the addition of the accumulate value, the instruction\nsets PSTATE.Q to 1. It is not possible for overflow to occur during the\nmultiplication.",
        "heading": "SMLABB, SMLABT, SMLATB, SMLATT",
        "templates": {
          "A1": [
            "SMLABB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMLABT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMLATB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMLATT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ],
          "T1": [
            "SMLABB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMLABT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMLATB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMLATT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ]
        }
      },
      "SMLAD": {
        "authored": "Signed Multiply Accumulate Dual performs two signed 16 x 16-bit multiplications.\nIt adds the products to a 32-bit accumulate operand.\n\nOptionally, the instruction can exchange the halfwords of the second operand\nbefore performing the arithmetic. This produces top x bottom and bottom x top\nmultiplication.\n\nThis instruction sets PSTATE.Q to 1 if the accumulate operation overflows.\nOverflow cannot occur during the multiplications.",
        "heading": "SMLAD, SMLADX",
        "templates": {
          "A1": [
            "SMLAD{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMLADX{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ],
          "T1": [
            "SMLAD{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMLADX{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ]
        }
      },
      "SMLAL": {
        "authored": "Signed Multiply Accumulate Long multiplies two signed 32-bit values to produce a\n64-bit value, and accumulates this with a 64-bit value.\n\nIn A32 instructions, the condition flags can optionally be updated based on the\nresult. Use of this option adversely affects performance on many\nimplementations.",
        "heading": "SMLAL, SMLALS",
        "templates": {
          "A1": [
            "SMLALS{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "SMLAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ],
          "T1": [
            "SMLAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ]
        }
      },
      "SMLALBB": {
        "authored": "Signed Multiply Accumulate Long (halfwords) multiplies two signed 16-bit values\nto produce a 32-bit value, and accumulates this with a 64-bit value. The\nmultiply acts on two signed 16-bit quantities, taken from either the bottom or\nthe top half of their respective source registers. The other halves of these\nsource registers are ignored. The 32-bit product is sign-extended and\naccumulated with a 64-bit accumulate value.\n\nOverflow is possible during this instruction, but only as a result of the 64-bit\naddition. This overflow is not detected if it occurs. Instead, the result wraps\naround modulo 2^64.",
        "heading": "SMLALBB, SMLALBT, SMLALTB, SMLALTT",
        "templates": {
          "A1": [
            "SMLALBB{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "SMLALBT{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "SMLALTB{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "SMLALTT{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ],
          "T1": [
            "SMLALBB{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "SMLALBT{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "SMLALTB{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "SMLALTT{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ]
        }
      },
      "SMLALD": {
        "authored": "Signed Multiply Accumulate Long Dual performs two signed 16 x 16-bit\nmultiplications. It adds the products to a 64-bit accumulate operand.\n\nOptionally, the instruction can exchange the halfwords of the second operand\nbefore performing the arithmetic. This produces top x bottom and bottom x top\nmultiplication.\n\nOverflow is possible during this instruction, but only as a result of the 64-bit\naddition. This overflow is not detected if it occurs. Instead, the result wraps\naround modulo 2^64.",
        "heading": "SMLALD, SMLALDX",
        "templates": {
          "A1": [
            "SMLALD{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "SMLALDX{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ],
          "T1": [
            "SMLALD{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "SMLALDX{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ]
        }
      },
      "SMLAWB": {
        "authored": "Signed Multiply Accumulate (word by halfword) performs a signed multiply\naccumulate operation. The multiply acts on a signed 32-bit quantity and a signed\n16-bit quantity. The signed 16-bit quantity is taken from either the bottom or\nthe top half of its source register. The other half of the second source\nregister is ignored. The top 32 bits of the 48-bit product are added to a 32-bit\naccumulate value and the result is written to the destination register. The\nbottom 16 bits of the 48-bit product are ignored.\n\nIf overflow occurs during the addition of the accumulate value, the instruction\nsets PSTATE.Q to 1. No overflow can occur during the multiplication.",
        "heading": "SMLAWB, SMLAWT",
        "templates": {
          "A1": [
            "SMLAWB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMLAWT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ],
          "T1": [
            "SMLAWB{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMLAWT{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ]
        }
      },
      "SMLSD": {
        "authored": "Signed Multiply Subtract Dual performs two signed 16 x 16-bit multiplications.\nIt adds the difference of the products to a 32-bit accumulate operand.\n\nOptionally, the instruction can exchange the halfwords of the second operand\nbefore performing the arithmetic. This produces top x bottom and bottom x top\nmultiplication.\n\nThis instruction sets PSTATE.Q to 1 if the accumulate operation overflows.\nOverflow cannot occur during the multiplications or subtraction.",
        "heading": "SMLSD, SMLSDX",
        "templates": {
          "A1": [
            "SMLSD{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMLSDX{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ],
          "T1": [
            "SMLSD{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMLSDX{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ]
        }
      },
      "SMLSLD": {
        "authored": "Signed Multiply Subtract Long Dual performs two signed 16 x 16-bit\nmultiplications. It adds the difference of the products to a 64-bit accumulate\noperand.\n\nOptionally, the instruction can exchange the halfwords of the second operand\nbefore performing the arithmetic. This produces top x bottom and bottom x top\nmultiplication.\n\nOverflow is possible during this instruction, but only as a result of the 64-bit\naddition. This overflow is not detected if it occurs. Instead, the result wraps\naround modulo 2^64.",
        "heading": "SMLSLD, SMLSLDX",
        "templates": {
          "A1": [
            "SMLSLD{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "SMLSLDX{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ],
          "T1": [
            "SMLSLD{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "SMLSLDX{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ]
        }
      },
      "SMMLA": {
        "authored": "Signed Most Significant Word Multiply Accumulate multiplies two signed 32-bit\nvalues, extracts the most significant 32 bits of the result, and adds an\naccumulate value.\n\nOptionally, the instruction can specify that the result is rounded instead of\nbeing truncated. In this case, the constant 0x80000000 is added to the product\nbefore the high word is extracted.",
        "heading": "SMMLA, SMMLAR",
        "templates": {
          "A1": [
            "SMMLA{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMMLAR{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ],
          "T1": [
            "SMMLA{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMMLAR{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ]
        }
      },
      "SMMLS": {
        "authored": "Signed Most Significant Word Multiply Subtract multiplies two signed 32-bit\nvalues, subtracts the result from a 32-bit accumulate value that is shifted left\nby 32 bits, and extracts the most significant 32 bits of the result of that\nsubtraction.\n\nOptionally, the instruction can specify that the result of the instruction is\nrounded instead of being truncated. In this case, the constant 0x80000000 is\nadded to the result of the subtraction before the high word is extracted.",
        "heading": "SMMLS, SMMLSR",
        "templates": {
          "A1": [
            "SMMLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMMLSR{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ],
          "T1": [
            "SMMLS{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>",
            "SMMLSR{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ]
        }
      },
      "SMMUL": {
        "authored": "Signed Most Significant Word Multiply multiplies two signed 32-bit values,\nextracts the most significant 32 bits of the result, and writes those bits to\nthe destination register.\n\nOptionally, the instruction can specify that the result is rounded instead of\nbeing truncated. In this case, the constant 0x80000000 is added to the product\nbefore the high word is extracted.",
        "heading": "SMMUL, SMMULR",
        "templates": {
          "A1": [
            "SMMUL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMMULR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SMMUL{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMMULR{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SMUAD": {
        "authored": "Signed Dual Multiply Add performs two signed 16 x 16-bit multiplications. It\nadds the products together, and writes the result to the destination register.\n\nOptionally, the instruction can exchange the halfwords of the second operand\nbefore performing the arithmetic. This produces top x bottom and bottom x top\nmultiplication.\n\nThis instruction sets PSTATE.Q to 1 if the addition overflows. The\nmultiplications cannot overflow.",
        "heading": "SMUAD, SMUADX",
        "templates": {
          "A1": [
            "SMUAD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMUADX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SMUAD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMUADX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SMULBB": {
        "authored": "Signed Multiply (halfwords) multiplies two signed 16-bit quantities, taken from\neither the bottom or the top half of their respective source registers. The\nother halves of these source registers are ignored. The 32-bit product is\nwritten to the destination register. No overflow is possible during this\ninstruction.",
        "heading": "SMULBB, SMULBT, SMULTB, SMULTT",
        "templates": {
          "A1": [
            "SMULBB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMULBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMULTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMULTT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SMULBB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMULBT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMULTB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMULTT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SMULL": {
        "authored": "Signed Multiply Long multiplies two 32-bit signed values to produce a 64-bit\nresult.\n\nIn A32 instructions, the condition flags can optionally be updated based on the\nresult. Use of this option adversely affects performance on many\nimplementations.",
        "heading": "SMULL, SMULLS",
        "templates": {
          "A1": [
            "SMULLS{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "SMULL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ],
          "T1": [
            "SMULL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ]
        }
      },
      "SMULWB": {
        "authored": "Signed Multiply (word by halfword) multiplies a signed 32-bit quantity and a\nsigned 16-bit quantity. The signed 16-bit quantity is taken from either the\nbottom or the top half of its source register. The other half of the second\nsource register is ignored. The top 32 bits of the 48-bit product are written to\nthe destination register. The bottom 16 bits of the 48-bit product are ignored.\nNo overflow is possible during this instruction.",
        "heading": "SMULWB, SMULWT",
        "templates": {
          "A1": [
            "SMULWB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMULWT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SMULWB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMULWT{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SMUSD": {
        "authored": "Signed Multiply Subtract Dual performs two signed 16 x 16-bit multiplications.\nIt subtracts one of the products from the other, and writes the result to the\ndestination register.\n\nOptionally, the instruction can exchange the halfwords of the second operand\nbefore performing the arithmetic. This produces top x bottom and bottom x top\nmultiplication.\n\nOverflow cannot occur.",
        "heading": "SMUSD, SMUSDX",
        "templates": {
          "A1": [
            "SMUSD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMUSDX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SMUSD{<c>}{<q>} {<Rd>,} <Rn>, <Rm>",
            "SMUSDX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SRS": {
        "authored": "Store Return State stores the LR_<current_mode> and SPSR_<current_mode> to the\nstack of a specified mode. For information about memory accesses see Memory\naccesses.\n\nSRS is undefined in Hyp mode.\n\nSRS is constrained unpredictable if it is executed in User or System mode, or if\nthe specified mode is any of the following:\n  - Not implemented.\n  - A mode that Table G1-5 does not show.\n  - Hyp mode.\n  - Monitor mode, if the SRS instruction is executed in Non-secure state.\n\nIf EL3 is using AArch64 and an SRS instruction that is executed in a Secure EL1\nmode specifies Monitor mode, it is trapped to EL3.\n\nSee Traps to EL3 of Secure monitor functionality from Secure EL1 using AArch32.",
        "heading": "SRS, SRSDA, SRSDB, SRSIA, SRSIB",
        "templates": {
          "A1": [
            "SRSDA{<c>}{<q>} SP{!}, #<mode>",
            "SRSDB{<c>}{<q>} SP{!}, #<mode>",
            "SRS{IA}{<c>}{<q>} SP{!}, #<mode>",
            "SRSIB{<c>}{<q>} SP{!}, #<mode>"
          ],
          "T1": [
            "SRSDB{<c>}{<q>} SP{!}, #<mode>"
          ],
          "T2": [
            "SRS{IA}{<c>}{<q>} SP{!}, #<mode>"
          ]
        }
      },
      "SSAT": {
        "authored": "Signed Saturate saturates an optionally-shifted signed value to a selectable\nsigned range.\n\nThis instruction sets PSTATE.Q to 1 if the operation saturates.",
        "heading": "SSAT",
        "templates": {
          "A1": [
            "SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn>, ASR #<amount>",
            "SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, LSL #<amount>}"
          ],
          "T1": [
            "SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn>, ASR #<amount>",
            "SSAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, LSL #<amount>}"
          ]
        }
      },
      "SSAT16": {
        "authored": "Signed Saturate 16 saturates two signed 16-bit values to a selected signed\nrange.\n\nThis instruction sets PSTATE.Q to 1 if the operation saturates.",
        "heading": "SSAT16",
        "templates": {
          "A1": [
            "SSAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>"
          ],
          "T1": [
            "SSAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>"
          ]
        }
      },
      "SSAX": {
        "authored": "Signed Subtract and Add with Exchange exchanges the two halfwords of the second\noperand, performs one 16-bit integer subtraction and one 16-bit addition, and\nwrites the results to the destination register. It sets PSTATE.GE according to\nthe results.",
        "heading": "SSAX",
        "templates": {
          "A1": [
            "SSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SSBB": {
        "authored": "Speculative Store Bypass Barrier is a memory barrier which prevents speculative\nloads from bypassing earlier stores to the same virtual address under certain\nconditions.\n\nThe semantics of the Speculative Store Bypass Barrier are:\n  - When a load to a location appears in program order after the SSBB, then the\nload does not speculatively read an entry earlier in the coherence order for\nthat location than the entry generated by the latest store satisfying all of the\nfollowing conditions:\n    - The store is to the same location as the load.\n    - The store uses the same virtual address as the load.\n    - The store appears in program order before the SSBB.\n  - When a load to a location appears in program order before the SSBB, then the\nload does not speculatively read data from any store satisfying all of the\nfollowing conditions:\n    - The store is to the same location as the load.\n    - The store uses the same virtual address as the load.\n    - The store appears in program order after the SSBB.",
        "heading": "SSBB",
        "templates": {
          "A1": [
            "SSBB{<q>}"
          ],
          "T1": [
            "SSBB{<q>}"
          ]
        }
      },
      "SSUB16": {
        "authored": "Signed Subtract 16 performs two 16-bit signed integer subtractions, and writes\nthe results to the destination register. It sets PSTATE.GE according to the\nresults of the subtractions.",
        "heading": "SSUB16",
        "templates": {
          "A1": [
            "SSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "SSUB8": {
        "authored": "Signed Subtract 8 performs four 8-bit signed integer subtractions, and writes\nthe results to the destination register. It sets PSTATE.GE according to the\nresults of the subtractions.",
        "heading": "SSUB8",
        "templates": {
          "A1": [
            "SSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "SSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "STC": {
        "authored": "Store data to System register calculates an address from a base register value\nand an immediate offset, and stores a word from the DBGDTRRXint System register\nto memory. It can use offset, post-indexed, pre-indexed, or unindexed\naddressing. For information about memory accesses see Memory accesses.\n\nIn an implementation that includes EL2, the permitted STC access to DBGDTRRXint\ncan be trapped to Hyp mode, meaning that an attempt to execute an STC\ninstruction in a Non-secure mode other than Hyp mode, that would be permitted in\nthe absence of the Hyp trap controls, generates a Hyp Trap exception.  For more\ninformation, see Trapping general Non-secure System register accesses to debug\nregisters.\n\nFor simplicity, the STC pseudocode does not show this possible trap to Hyp mode.",
        "heading": "STC",
        "templates": {
          "A1": [
            "STC{<c>}{<q>} p14, c5, [<Rn>{, #{+/-}<imm>}]",
            "STC{<c>}{<q>} p14, c5, [<Rn>], #{+/-}<imm>",
            "STC{<c>}{<q>} p14, c5, [<Rn>, #{+/-}<imm>]!",
            "STC{<c>}{<q>} p14, c5, [<Rn>], <option>"
          ],
          "T1": [
            "STC{<c>}{<q>} p14, c5, [<Rn>{, #{+/-}<imm>}]",
            "STC{<c>}{<q>} p14, c5, [<Rn>], #{+/-}<imm>",
            "STC{<c>}{<q>} p14, c5, [<Rn>, #{+/-}<imm>]!",
            "STC{<c>}{<q>} p14, c5, [<Rn>], <option>"
          ]
        }
      },
      "STL": {
        "authored": "Store-Release Word stores a word from a register to memory.  The instruction\nalso has memory ordering semantics as described in Load-Acquire, Store-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "STL",
        "templates": {
          "A1": [
            "STL{<c>}{<q>} <Rt>, [<Rn>]"
          ],
          "T1": [
            "STL{<c>}{<q>} <Rt>, [<Rn>]"
          ]
        }
      },
      "STLB": {
        "authored": "Store-Release Byte stores a byte from a register to memory.  The instruction\nalso has memory ordering semantics as described in Load-Acquire, Store-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "STLB",
        "templates": {
          "A1": [
            "STLB{<c>}{<q>} <Rt>, [<Rn>]"
          ],
          "T1": [
            "STLB{<c>}{<q>} <Rt>, [<Rn>]"
          ]
        }
      },
      "STLEX": {
        "authored": "Store-Release Exclusive Word stores a word from a register to memory if the\nexecuting PE has exclusive access to the memory at that address, and returns a\nstatus value of 0 if the store was successful, or of 1 if no store was\nperformed.\n\nThe instruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "STLEX",
        "templates": {
          "A1": [
            "STLEX{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
          ],
          "T1": [
            "STLEX{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
          ]
        }
      },
      "STLEXB": {
        "authored": "Store-Release Exclusive Byte stores a byte from a register to memory if the\nexecuting PE has exclusive access to the memory at that address, and returns a\nstatus value of 0 if the store was successful, or of 1 if no store was\nperformed.\n\nThe instruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "STLEXB",
        "templates": {
          "A1": [
            "STLEXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
          ],
          "T1": [
            "STLEXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
          ]
        }
      },
      "STLEXD": {
        "authored": "Store-Release Exclusive Doubleword stores a doubleword from two registers to\nmemory if the executing PE has exclusive access to the memory at that address,\nand returns a status value of 0 if the store was successful, or of 1 if no store\nwas performed.\n\nThe instruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "STLEXD",
        "templates": {
          "A1": [
            "STLEXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]"
          ],
          "T1": [
            "STLEXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]"
          ]
        }
      },
      "STLEXH": {
        "authored": "Store-Release Exclusive Halfword stores a halfword from a register to memory if\nthe executing PE has exclusive access to the memory at that address, and returns\na status value of 0 if the store was successful, or of 1 if no store was\nperformed.\n\nThe instruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "STLEXH",
        "templates": {
          "A1": [
            "STLEXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
          ],
          "T1": [
            "STLEXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
          ]
        }
      },
      "STLH": {
        "authored": "Store-Release Halfword stores a halfword from a register to memory. The\ninstruction also has memory ordering semantics as described in Load-Acquire,\nStore-Release.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "STLH",
        "templates": {
          "A1": [
            "STLH{<c>}{<q>} <Rt>, [<Rn>]"
          ],
          "T1": [
            "STLH{<c>}{<q>} <Rt>, [<Rn>]"
          ]
        }
      },
      "STM": {
        "authored": "Store Multiple (Increment After, Empty Ascending) stores multiple registers to\nconsecutive memory locations using an address from a base register. The\nconsecutive memory locations start at this address, and the address just above\nthe last of those locations can optionally be written back to the base register.\n\nThe lowest-numbered register is loaded from the lowest memory address, through\nto the highest-numbered register from the highest memory address. See also\nEncoding of lists of general-purpose registers and the PC.\n\nARMv8.2 permits the deprecation of some Store Multiple ordering behaviors in\nAArch32 state, for more information see ARMv8.2-LSMAOC. For details of related\nsystem instructions see STM (User registers).",
        "heading": "STM, STMIA, STMEA",
        "templates": {
          "A1": [
            "STM{IA}{<c>}{<q>} <Rn>{!}, <registers>",
            "STMEA{<c>}{<q>} <Rn>{!}, <registers>"
          ],
          "T1": [
            "STM{IA}{<c>}{<q>} <Rn>!, <registers>",
            "STMEA{<c>}{<q>} <Rn>!, <registers>"
          ],
          "T2": [
            "STM{IA}{<c>}.W <Rn>{!}, <registers>",
            "STMEA{<c>}.W <Rn>{!}, <registers>",
            "STM{IA}{<c>}{<q>} <Rn>{!}, <registers>",
            "STMEA{<c>}{<q>} <Rn>{!}, <registers>"
          ]
        }
      },
      "STMDA": {
        "authored": "Store Multiple Decrement After (Empty Descending) stores multiple registers to\nconsecutive memory locations using an address from a base register. The\nconsecutive memory locations end at this address, and the address just below the\nlowest of those locations can optionally be written back to the base register.\n\nThe lowest-numbered register is loaded from the lowest memory address, through\nto the highest-numbered register from the highest memory address. See also\nEncoding of lists of general-purpose registers and the PC.\n\nARMv8.2 permits the deprecation of some Store Multiple ordering behaviors in\nAArch32 state, for more information see ARMv8.2-LSMAOC. For details of related\nsystem instructions see STM (User registers).",
        "heading": "STMDA, STMED",
        "templates": {
          "A1": [
            "STMDA{<c>}{<q>} <Rn>{!}, <registers>",
            "STMED{<c>}{<q>} <Rn>{!}, <registers>"
          ]
        }
      },
      "STMDB": {
        "authored": "Store Multiple Decrement Before (Full Descending) stores multiple registers to\nconsecutive memory locations using an address from a base register. The\nconsecutive memory locations end just below this address, and the address of the\nfirst of those locations can optionally be written back to the base register.\n\nThe lowest-numbered register is loaded from the lowest memory address, through\nto the highest-numbered register from the highest memory address. See also\nEncoding of lists of general-purpose registers and the PC.\n\nARMv8.2 permits the deprecation of some Store Multiple ordering behaviors in\nAArch32 state, for more information see ARMv8.2-LSMAOC. For details of related\nsystem instructions see STM (User registers).",
        "heading": "STMDB, STMFD",
        "templates": {
          "A1": [
            "STMDB{<c>}{<q>} <Rn>{!}, <registers>",
            "STMFD{<c>}{<q>} <Rn>{!}, <registers>"
          ],
          "T1": [
            "STMDB{<c>}{<q>} <Rn>{!}, <registers>",
            "STMFD{<c>}{<q>} <Rn>{!}, <registers>"
          ]
        }
      },
      "STMIB": {
        "authored": "Store Multiple Increment Before (Full Ascending) stores multiple registers to\nconsecutive memory locations using an address from a base register. The\nconsecutive memory locations start just above this address, and the address of\nthe last of those locations can optionally be written back to the base register.\n\nThe lowest-numbered register is loaded from the lowest memory address, through\nto the highest-numbered register from the highest memory address. See also\nEncoding of lists of general-purpose registers and the PC.\n\nARMv8.2 permits the deprecation of some Store Multiple ordering behaviors in\nAArch32 state, for more information see ARMv8.2-LSMAOC. For details of related\nsystem instructions see STM (User registers).",
        "heading": "STMIB, STMFA",
        "templates": {
          "A1": [
            "STMIB{<c>}{<q>} <Rn>{!}, <registers>",
            "STMFA{<c>}{<q>} <Rn>{!}, <registers>"
          ]
        }
      },
      "STM_u": {
        "authored": "In an EL1 mode other than System mode, Store Multiple (User registers) stores\nmultiple User mode registers to consecutive memory locations using an address\nfrom a base register. The PE reads the base register value normally, using the\ncurrent mode to determine the correct Banked version of the register. This\ninstruction cannot writeback to the base register.\n\nStore Multiple (User registers) is undefined in Hyp mode, and constrained\nunpredictable in User or System modes.\n\nARMv8.2 permits the deprecation of some Store Multiple ordering behaviors in\nAArch32 state, for more information see ARMv8.2-LSMAOC.",
        "heading": "STM (User registers)",
        "templates": {
          "A1": [
            "STM{<amode>}{<c>}{<q>} <Rn>, <registers>^"
          ]
        }
      },
      "STRBT": {
        "authored": "Store Register Byte Unprivileged stores a byte from a register to memory. For\ninformation about memory accesses see Memory accesses.\n\nThe memory access is restricted as if the PE were running in User mode. This\nmakes no difference if the PE is actually running in User mode.\n\nSTRBT is unpredictable in Hyp mode.\n\nThe T32 instruction uses an offset addressing mode, that calculates the address\nused for the memory access from a base register value and an immediate offset,\nand leaves the base register unchanged.\n\nThe A32 instruction uses a post-indexed addressing mode, that uses a base\nregister value as the address for the memory access, and calculates a new\naddress from a base register value and an offset and writes it back to the base\nregister. The offset can be an immediate value or an optionally-shifted register\nvalue.",
        "heading": "STRBT",
        "templates": {
          "A1": [
            "STRBT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
          ],
          "A2": [
            "STRBT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}"
          ],
          "T1": [
            "STRBT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ]
        }
      },
      "STRB_i": {
        "authored": "Store Register Byte (immediate) calculates an address from a base register value\nand an immediate offset, and stores a byte from a register to memory. It can use\noffset, post-indexed, or pre-indexed addressing. For information about memory\naccesses see Memory accesses.",
        "heading": "STRB (immediate)",
        "templates": {
          "A1": [
            "STRB{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]",
            "STRB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "STRB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ],
          "T1": [
            "STRB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T2": [
            "STRB{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]",
            "STRB{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T3": [
            "STRB{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]",
            "STRB{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "STRB{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ]
        }
      },
      "STRB_r": {
        "authored": "Store Register Byte (register) calculates an address from a base register value\nand an offset register value, and stores a byte from a register to memory. The\noffset register value can optionally be shifted. For information about memory\naccesses see Memory accesses.",
        "heading": "STRB (register)",
        "templates": {
          "A1": [
            "STRB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]",
            "STRB{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}",
            "STRB{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]!"
          ],
          "T1": [
            "STRB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
          ],
          "T2": [
            "STRB{<c>}.W <Rt>, [<Rn>, {+}<Rm>]",
            "STRB{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
          ]
        }
      },
      "STRD_i": {
        "authored": "Store Register Dual (immediate) calculates an address from a base register value\nand an immediate offset, and stores two words from two registers to memory. It\ncan use offset, post-indexed, or pre-indexed addressing. For information about\nmemory accesses see Memory accesses.",
        "heading": "STRD (immediate)",
        "templates": {
          "A1": [
            "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #{+/-}<imm>}]",
            "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #{+/-}<imm>",
            "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #{+/-}<imm>]!"
          ],
          "T1": [
            "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn> {, #{+/-}<imm>}]",
            "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], #{+/-}<imm>",
            "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, #{+/-}<imm>]!"
          ]
        }
      },
      "STRD_r": {
        "authored": "Store Register Dual (register) calculates an address from a base register value\nand a register offset, and stores two words from two registers to memory. It can\nuse offset, post-indexed, or pre-indexed addressing. For information about\nmemory accesses see Memory accesses.",
        "heading": "STRD (register)",
        "templates": {
          "A1": [
            "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, {+/-}<Rm>]",
            "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>], {+/-}<Rm>",
            "STRD{<c>}{<q>} <Rt>, <Rt2>, [<Rn>, {+/-}<Rm>]!"
          ]
        }
      },
      "STREX": {
        "authored": "Store Register Exclusive calculates an address from a base register value and an\nimmediate offset, stores a word from a register to the calculated address if the\nPE has exclusive access to the memory at that address, and returns a status\nvalue of 0 if the store was successful, or of 1 if no store was performed.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "STREX",
        "templates": {
          "A1": [
            "STREX{<c>}{<q>} <Rd>, <Rt>, [<Rn> {, {#}<imm>}]"
          ],
          "T1": [
            "STREX{<c>}{<q>} <Rd>, <Rt>, [<Rn> {, #<imm>}]"
          ]
        }
      },
      "STREXB": {
        "authored": "Store Register Exclusive Byte derives an address from a base register value,\nstores a byte from a register to the derived address if the executing PE has\nexclusive access to the memory at that address, and returns a status value of 0\nif the store was successful, or of 1 if no store was performed.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "STREXB",
        "templates": {
          "A1": [
            "STREXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
          ],
          "T1": [
            "STREXB{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
          ]
        }
      },
      "STREXD": {
        "authored": "Store Register Exclusive Doubleword derives an address from a base register\nvalue, stores a 64-bit doubleword from two registers to the derived address if\nthe executing PE has exclusive access to the memory at that address, and returns\na status value of 0 if the store was successful, or of 1 if no store was\nperformed.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "STREXD",
        "templates": {
          "A1": [
            "STREXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]"
          ],
          "T1": [
            "STREXD{<c>}{<q>} <Rd>, <Rt>, <Rt2>, [<Rn>]"
          ]
        }
      },
      "STREXH": {
        "authored": "Store Register Exclusive Halfword derives an address from a base register value,\nstores a halfword from a register to the derived address if the executing PE has\nexclusive access to the memory at that address, and returns a status value of 0\nif the store was successful, or of 1 if no store was performed.\n\nFor more information about support for shared memory see Synchronization and\nsemaphores. For information about memory accesses see Memory accesses.",
        "heading": "STREXH",
        "templates": {
          "A1": [
            "STREXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
          ],
          "T1": [
            "STREXH{<c>}{<q>} <Rd>, <Rt>, [<Rn>]"
          ]
        }
      },
      "STRHT": {
        "authored": "Store Register Halfword Unprivileged stores a halfword from a register to\nmemory. For information about memory accesses see Memory accesses.\n\nThe memory access is restricted as if the PE were running in User mode. This\nmakes no difference if the PE is actually running in User mode.\n\nSTRHT is unpredictable in Hyp mode.\n\nThe T32 instruction uses an offset addressing mode, that calculates the address\nused for the memory access from a base register value and an immediate offset,\nand leaves the base register unchanged.\n\nThe A32 instruction uses a post-indexed addressing mode, that uses a base\nregister value as the address for the memory access, and calculates a new\naddress from a base register value and an offset and writes it back to the base\nregister. The offset can be an immediate value or a register value.",
        "heading": "STRHT",
        "templates": {
          "A1": [
            "STRHT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
          ],
          "A2": [
            "STRHT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>"
          ],
          "T1": [
            "STRHT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ]
        }
      },
      "STRH_i": {
        "authored": "Store Register Halfword (immediate) calculates an address from a base register\nvalue and an immediate offset, and stores a halfword from a register to memory.\nIt can use offset, post-indexed, or pre-indexed addressing. For information\nabout memory accesses see Memory accesses.",
        "heading": "STRH (immediate)",
        "templates": {
          "A1": [
            "STRH{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]",
            "STRH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "STRH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ],
          "T1": [
            "STRH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T2": [
            "STRH{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]",
            "STRH{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T3": [
            "STRH{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]",
            "STRH{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "STRH{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ]
        }
      },
      "STRH_r": {
        "authored": "Store Register Halfword (register) calculates an address from a base register\nvalue and an offset register value, and stores a halfword from a register to\nmemory. The offset register value can be shifted left by 0, 1, 2, or 3 bits. For\ninformation about memory accesses see Memory accesses.",
        "heading": "STRH (register)",
        "templates": {
          "A1": [
            "STRH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]",
            "STRH{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>",
            "STRH{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>]!"
          ],
          "T1": [
            "STRH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
          ],
          "T2": [
            "STRH{<c>}.W <Rt>, [<Rn>, {+}<Rm>]",
            "STRH{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
          ]
        }
      },
      "STRT": {
        "authored": "Store Register Unprivileged stores a word from a register to memory. For\ninformation about memory accesses see Memory accesses.\n\nThe memory access is restricted as if the PE were running in User mode. This\nmakes no difference if the PE is actually running in User mode.\n\nSTRT is unpredictable in Hyp mode.\n\nThe T32 instruction uses an offset addressing mode, that calculates the address\nused for the memory access from a base register value and an immediate offset,\nand leaves the base register unchanged.\n\nThe A32 instruction uses a post-indexed addressing mode, that uses a base\nregister value as the address for the memory access, and calculates a new\naddress from a base register value and an offset and writes it back to the base\nregister. The offset can be an immediate value or an optionally-shifted register\nvalue.",
        "heading": "STRT",
        "templates": {
          "A1": [
            "STRT{<c>}{<q>} <Rt>, [<Rn>] {, #{+/-}<imm>}"
          ],
          "A2": [
            "STRT{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}"
          ],
          "T1": [
            "STRT{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ]
        }
      },
      "STR_i": {
        "authored": "Store Register (immediate) calculates an address from a base register value and\nan immediate offset, and stores a word from a register to memory. It can use\noffset, post-indexed, or pre-indexed addressing. For information about memory\naccesses see Memory accesses.",
        "heading": "STR (immediate)",
        "templates": {
          "A1": [
            "STR{<c>}{<q>} <Rt>, [<Rn> {, #{+/-}<imm>}]",
            "STR{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "STR{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ],
          "T1": [
            "STR{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T2": [
            "STR{<c>}{<q>} <Rt>, [SP{, #{+}<imm>}]"
          ],
          "T3": [
            "STR{<c>}.W <Rt>, [<Rn> {, #{+}<imm>}]",
            "STR{<c>}{<q>} <Rt>, [<Rn> {, #{+}<imm>}]"
          ],
          "T4": [
            "STR{<c>}{<q>} <Rt>, [<Rn> {, #-<imm>}]",
            "STR{<c>}{<q>} <Rt>, [<Rn>], #{+/-}<imm>",
            "STR{<c>}{<q>} <Rt>, [<Rn>, #{+/-}<imm>]!"
          ]
        }
      },
      "STR_r": {
        "authored": "Store Register (register) calculates an address from a base register value and\nan offset register value, stores a word from a register to memory. The offset\nregister value can optionally be shifted. For information about memory accesses\nsee Memory accesses.",
        "heading": "STR (register)",
        "templates": {
          "A1": [
            "STR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]",
            "STR{<c>}{<q>} <Rt>, [<Rn>], {+/-}<Rm>{, <shift>}",
            "STR{<c>}{<q>} <Rt>, [<Rn>, {+/-}<Rm>{, <shift>}]!"
          ],
          "T1": [
            "STR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>]"
          ],
          "T2": [
            "STR{<c>}.W <Rt>, [<Rn>, {+}<Rm>]",
            "STR{<c>}{<q>} <Rt>, [<Rn>, {+}<Rm>{, LSL #<imm>}]"
          ]
        }
      },
      "SUB_ADR": {
        "authored": " subtracts an immediate value from the Align(PC, 4) value to form a PC-relative\naddress, and writes the result to the destination register.  ARM recommends\nthat, where possible, software avoids using this alias",
        "heading": "SUB (immediate, from PC)",
        "templates": {
          "A2": [
            "SUB{<c>}{<q>} <Rd>, PC, #<const>"
          ],
          "T2": [
            "SUB{<c>}{<q>} <Rd>, PC, #<imm12>"
          ]
        }
      },
      "SUB_SP_i": {
        "authored": "Subtract from SP (immediate) subtracts an immediate value from the SP value, and\nwrites the result to the destination register.\n\nIf the destination register is not the PC, the SUBS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. If the destination register is the PC:\n  - The SUB variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The SUBS variant of the instruction performs an exception return without the\nuse of the stack. ARM deprecates use of this instruction. However, in this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "SUB, SUBS (SP minus immediate)",
        "templates": {
          "A1": [
            "SUB{<c>}{<q>} {<Rd>,} SP, #<const>",
            "SUBS{<c>}{<q>} {<Rd>,} SP, #<const>"
          ],
          "T1": [
            "SUB{<c>}{<q>} {SP,} SP, #<imm7>"
          ],
          "T2": [
            "SUB{<c>}.W {<Rd>,} SP, #<const>",
            "SUB{<c>}{<q>} {<Rd>,} SP, #<const>",
            "SUBS{<c>}{<q>} {<Rd>,} SP, #<const>"
          ],
          "T3": [
            "SUB{<c>}{<q>} {<Rd>,} SP, #<imm12>",
            "SUBW{<c>}{<q>} {<Rd>,} SP, #<imm12>"
          ]
        }
      },
      "SUB_SP_r": {
        "authored": "Subtract from SP (register) subtracts an optionally-shifted register value from\nthe SP value, and writes the result to the destination register.\n\nIf the destination register is not the PC, the SUBS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. If the destination register is the PC:\n  - The SUB variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The SUBS variant of the instruction performs an exception return without the\nuse of the stack. ARM deprecates use of this instruction. However, in this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "SUB, SUBS (SP minus register)",
        "templates": {
          "A1": [
            "SUB{<c>}{<q>} {<Rd>,} SP, <Rm> , RRX",
            "SUB{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}",
            "SUBS{<c>}{<q>} {<Rd>,} SP, <Rm> , RRX",
            "SUBS{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "SUB{<c>}{<q>} {<Rd>,} SP, <Rm>, RRX",
            "SUB{<c>}.W {<Rd>,} SP, <Rm>",
            "SUB{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}",
            "SUBS{<c>}{<q>} {<Rd>,} SP, <Rm>, RRX",
            "SUBS{<c>}{<q>} {<Rd>,} SP, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "SUB_i": {
        "authored": "Subtract (immediate) subtracts an immediate value from a register value, and\nwrites the result to the destination register.\n\nIf the destination register is not the PC, the SUBS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. If the destination register is the PC:\n  - The SUB variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The SUBS variant of the instruction performs an exception return without the\nuse of the stack. In this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode, except for encoding T5 with\n<imm8> set to zero, which is the encoding for the ERET instruction, see ERET.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "SUB, SUBS (immediate)",
        "templates": {
          "A1": [
            "SUB{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "SUBS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ],
          "T1": [
            "SUB<c>{<q>} <Rd>, <Rn>, #<imm3>",
            "SUBS{<q>} <Rd>, <Rn>, #<imm3>"
          ],
          "T2": [
            "SUB<c>{<q>} <Rdn>, #<imm8>",
            "SUB<c>{<q>} {<Rdn>,} <Rdn>, #<imm8>",
            "SUBS{<q>} <Rdn>, #<imm8>",
            "SUBS{<q>} {<Rdn>,} <Rdn>, #<imm8>"
          ],
          "T3": [
            "SUB<c>.W {<Rd>,} <Rn>, #<const>",
            "SUB{<c>}{<q>} {<Rd>,} <Rn>, #<const>",
            "SUBS.W {<Rd>,} <Rn>, #<const>",
            "SUBS{<c>}{<q>} {<Rd>,} <Rn>, #<const>"
          ],
          "T4": [
            "SUB{<c>}{<q>} {<Rd>,} <Rn>, #<imm12>",
            "SUBW{<c>}{<q>} {<Rd>,} <Rn>, #<imm12>"
          ],
          "T5": [
            "SUBS{<c>}{<q>} PC, LR, #<imm8>"
          ]
        }
      },
      "SUB_r": {
        "authored": "Subtract (register) subtracts an optionally-shifted register value from a\nregister value, and writes the result to the destination register.\n\nIf the destination register is not the PC, the SUBS variant of the instruction\nupdates the condition flags based on the result.\n\nThe field descriptions for <Rd> identify the encodings where the PC is permitted\nas the destination register. However, when the destination register is the PC:\n  - The SUB variant of the instruction is an interworking branch, see Pseudocode\ndescription of operations on the AArch32 general-purpose registers and the PC.\n  - The SUBS variant of the instruction performs an exception return without the\nuse of the stack. ARM deprecates use of this instruction. However, in this case:\n    - The PE branches to the address written to the PC, and restores PSTATE from\nSPSR_<current_mode>.\n    - The PE checks SPSR_<current_mode> for an illegal return event. See Illegal\nreturn events from AArch32 state.\n    - The instruction is undefined in Hyp mode.\n    - The instruction is constrained unpredictable in User mode and System mode.",
        "heading": "SUB, SUBS (register)",
        "templates": {
          "A1": [
            "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "SUB<c>{<q>} <Rd>, <Rn>, <Rm>",
            "SUBS{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T2": [
            "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "SUB<c>.W {<Rd>,} <Rn>, <Rm>",
            "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}",
            "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, RRX",
            "SUBS.W {<Rd>,} <Rn>, <Rm>",
            "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "SUB_rr": {
        "authored": "Subtract (register-shifted register) subtracts a register-shifted register value\nfrom a register value, and writes the result to the destination register. It can\noptionally update the condition flags based on the result.",
        "heading": "SUB, SUBS (register-shifted register)",
        "templates": {
          "A1": [
            "SUBS{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>",
            "SUB{<c>}{<q>} {<Rd>,} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "SVC": {
        "authored": "Supervisor Call causes a Supervisor Call exception. For more information, see\nSupervisor Call (SVC) exception.\n\nSVC was previously called SWI, Software Interrupt, and this name is still found\nin some documentation.\n\nSoftware can use this instruction as a call to an operating system to provide a\nservice.\n\nIn the following cases, the Supervisor Call exception generated by the SVC\ninstruction is taken to Hyp mode:\n  - If the SVC is executed in Hyp mode.\n  - If HCR.TGE is set to 1, and the SVC is executed in Non-secure User mode. For\nmore information, see Supervisor Call exception, when HCR.TGE is set to 1\n\nIn these cases, the HSR, Hyp Syndrome Register identifies that the exception\nentry was caused by a Supervisor Call exception, EC value 0x11, see Use of the\nHSR. The immediate field in the HSR:\n  - If the SVC is unconditional:\n    - For the T32 instruction, is the zero-extended value of the imm8 field.\n    - For the A32 instruction, is the least-significant 16 bits the imm24 field.\n  - If the SVC is conditional, is unknown.",
        "heading": "SVC",
        "templates": {
          "A1": [
            "SVC{<c>}{<q>} {#}<imm>"
          ],
          "T1": [
            "SVC{<c>}{<q>} {#}<imm>"
          ]
        }
      },
      "SXTAB": {
        "authored": "Signed Extend and Add Byte extracts an 8-bit value from a register, sign-extends\nit to 32 bits, adds the result to the value in another register, and writes the\nfinal result to the destination register. The instruction can specify a rotation\nby 0, 8, 16, or 24 bits before extracting the 8-bit value.",
        "heading": "SXTAB",
        "templates": {
          "A1": [
            "SXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
          ],
          "T1": [
            "SXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
          ]
        }
      },
      "SXTAB16": {
        "authored": "Signed Extend and Add Byte 16 extracts two 8-bit values from a register, sign-\nextends them to 16 bits each, adds the results to two 16-bit values from another\nregister, and writes the final results to the destination register. The\ninstruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the\n8-bit values.",
        "heading": "SXTAB16",
        "templates": {
          "A1": [
            "SXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
          ],
          "T1": [
            "SXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
          ]
        }
      },
      "SXTAH": {
        "authored": "Signed Extend and Add Halfword extracts a 16-bit value from a register, sign-\nextends it to 32 bits, adds the result to a value from another register, and\nwrites the final result to the destination register. The instruction can specify\na rotation by 0, 8, 16, or 24 bits before extracting the 16-bit value.",
        "heading": "SXTAH",
        "templates": {
          "A1": [
            "SXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
          ],
          "T1": [
            "SXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
          ]
        }
      },
      "SXTB": {
        "authored": "Signed Extend Byte extracts an 8-bit value from a register, sign-extends it to\n32 bits, and writes the result to the destination register. The instruction can\nspecify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value.",
        "heading": "SXTB",
        "templates": {
          "A1": [
            "SXTB{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
          ],
          "T1": [
            "SXTB{<c>}{<q>} {<Rd>,} <Rm>"
          ],
          "T2": [
            "SXTB{<c>}.W {<Rd>,} <Rm>",
            "SXTB{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
          ]
        }
      },
      "SXTB16": {
        "authored": "Signed Extend Byte 16 extracts two 8-bit values from a register, sign-extends\nthem to 16 bits each, and writes the results to the destination register. The\ninstruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the\n8-bit values.",
        "heading": "SXTB16",
        "templates": {
          "A1": [
            "SXTB16{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
          ],
          "T1": [
            "SXTB16{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
          ]
        }
      },
      "SXTH": {
        "authored": "Signed Extend Halfword extracts a 16-bit value from a register, sign-extends it\nto 32 bits, and writes the result to the destination register. The instruction\ncan specify a rotation by 0, 8, 16, or 24 bits before extracting the 16-bit\nvalue.",
        "heading": "SXTH",
        "templates": {
          "A1": [
            "SXTH{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
          ],
          "T1": [
            "SXTH{<c>}{<q>} {<Rd>,} <Rm>"
          ],
          "T2": [
            "SXTH{<c>}.W {<Rd>,} <Rm>",
            "SXTH{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
          ]
        }
      },
      "TBB": {
        "authored": "Table Branch Byte or Halfword causes a PC-relative forward branch using a table\nof single byte or halfword offsets. A base register provides a pointer to the\ntable, and a second register supplies an index into the table. The branch length\nis twice the value returned from the table.",
        "heading": "TBB, TBH",
        "templates": {
          "T1": [
            "TBB{<c>}{<q>} [<Rn>, <Rm>]",
            "TBH{<c>}{<q>} [<Rn>, <Rm>, LSL #1]"
          ]
        }
      },
      "TEQ_i": {
        "authored": "Test Equivalence (immediate) performs a bitwise exclusive OR operation on a\nregister value and an immediate value. It updates the condition flags based on\nthe result, and discards the result.",
        "heading": "TEQ (immediate)",
        "templates": {
          "A1": [
            "TEQ{<c>}{<q>} <Rn>, #<const>"
          ],
          "T1": [
            "TEQ{<c>}{<q>} <Rn>, #<const>"
          ]
        }
      },
      "TEQ_r": {
        "authored": "Test Equivalence (register) performs a bitwise exclusive OR operation on a\nregister value and an optionally-shifted register value. It updates the\ncondition flags based on the result, and discards the result.",
        "heading": "TEQ (register)",
        "templates": {
          "A1": [
            "TEQ{<c>}{<q>} <Rn>, <Rm>, RRX",
            "TEQ{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "TEQ{<c>}{<q>} <Rn>, <Rm>, RRX",
            "TEQ{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "TEQ_rr": {
        "authored": "Test Equivalence (register-shifted register) performs a bitwise exclusive OR\noperation on a register value and a register-shifted register value. It updates\nthe condition flags based on the result, and discards the result.",
        "heading": "TEQ (register-shifted register)",
        "templates": {
          "A1": [
            "TEQ{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "TSB": {
        "authored": "Trace Synchronization Barrier. This instruction is a barrier that synchronizes\nthe trace operations of instructions.\n\nIf the Self-Hosted Trace Extension is not implemented, this instruction executes\nas a NOP.",
        "heading": "TSB CSYNC",
        "templates": {
          "A1": [
            "TSB{<c>}{<q>} CSYNC"
          ],
          "T1": [
            "TSB{<c>}{<q>} CSYNC"
          ]
        }
      },
      "TST_i": {
        "authored": "Test (immediate) performs a bitwise AND operation on a register value and an\nimmediate value. It updates the condition flags based on the result, and\ndiscards the result.",
        "heading": "TST (immediate)",
        "templates": {
          "A1": [
            "TST{<c>}{<q>} <Rn>, #<const>"
          ],
          "T1": [
            "TST{<c>}{<q>} <Rn>, #<const>"
          ]
        }
      },
      "TST_r": {
        "authored": "Test (register) performs a bitwise AND operation on a register value and an\noptionally-shifted register value. It updates the condition flags based on the\nresult, and discards the result.",
        "heading": "TST (register)",
        "templates": {
          "A1": [
            "TST{<c>}{<q>} <Rn>, <Rm>, RRX",
            "TST{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
          ],
          "T1": [
            "TST{<c>}{<q>} <Rn>, <Rm>"
          ],
          "T2": [
            "TST{<c>}{<q>} <Rn>, <Rm>, RRX",
            "TST{<c>}.W <Rn>, <Rm>",
            "TST{<c>}{<q>} <Rn>, <Rm> {, <shift> #<amount>}"
          ]
        }
      },
      "TST_rr": {
        "authored": "Test (register-shifted register) performs a bitwise AND operation on a register\nvalue and a register-shifted register value. It updates the condition flags\nbased on the result, and discards the result.",
        "heading": "TST (register-shifted register)",
        "templates": {
          "A1": [
            "TST{<c>}{<q>} <Rn>, <Rm>, <type> <Rs>"
          ]
        }
      },
      "UADD16": {
        "authored": "Unsigned Add 16 performs two 16-bit unsigned integer additions, and writes the\nresults to the destination register. It sets PSTATE.GE according to the results\nof the additions.",
        "heading": "UADD16",
        "templates": {
          "A1": [
            "UADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UADD8": {
        "authored": "Unsigned Add 8 performs four unsigned 8-bit integer additions, and writes the\nresults to the destination register. It sets PSTATE.GE according to the results\nof the additions.",
        "heading": "UADD8",
        "templates": {
          "A1": [
            "UADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UASX": {
        "authored": "Unsigned Add and Subtract with Exchange exchanges the two halfwords of the\nsecond operand, performs one unsigned 16-bit integer addition and one unsigned\n16-bit subtraction, and writes the results to the destination register. It sets\nPSTATE.GE according to the results.",
        "heading": "UASX",
        "templates": {
          "A1": [
            "UASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UBFX": {
        "authored": "Unsigned Bit Field Extract extracts any number of adjacent bits at any position\nfrom a register, zero-extends them to 32 bits, and writes the result to the\ndestination register.",
        "heading": "UBFX",
        "templates": {
          "A1": [
            "UBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>"
          ],
          "T1": [
            "UBFX{<c>}{<q>} <Rd>, <Rn>, #<lsb>, #<width>"
          ]
        }
      },
      "UDF": {
        "authored": "Permanently Undefined generates an Undefined Instruction exception.\n\nThe encodings for UDF used in this section are defined as permanently undefined\nin the ARMv8-A architecture. However:\n  - With the T32 instruction set, ARM deprecates using the UDF instruction in an\nIT block.\n  - In the A32 instruction set, UDF is not conditional.",
        "heading": "UDF",
        "templates": {
          "A1": [
            "UDF{<c>}{<q>} {#}<imm>"
          ],
          "T1": [
            "UDF{<c>}{<q>} {#}<imm>"
          ],
          "T2": [
            "UDF{<c>}.W {#}<imm>",
            "UDF{<c>}{<q>} {#}<imm>"
          ]
        }
      },
      "UDIV": {
        "authored": "Unsigned Divide divides a 32-bit unsigned integer register value by a 32-bit\nunsigned integer register value, and writes the result to the destination\nregister. The condition flags are not affected.\n\nSee Divide instructions for more information about this instruction.",
        "heading": "UDIV",
        "templates": {
          "A1": [
            "UDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UDIV{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UHADD16": {
        "authored": "Unsigned Halving Add 16 performs two unsigned 16-bit integer additions, halves\nthe results, and writes the results to the destination register.",
        "heading": "UHADD16",
        "templates": {
          "A1": [
            "UHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UHADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UHADD8": {
        "authored": "Unsigned Halving Add 8 performs four unsigned 8-bit integer additions, halves\nthe results, and writes the results to the destination register.",
        "heading": "UHADD8",
        "templates": {
          "A1": [
            "UHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UHADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UHASX": {
        "authored": "Unsigned Halving Add and Subtract with Exchange exchanges the two halfwords of\nthe second operand, performs one unsigned 16-bit integer addition and one\nunsigned 16-bit subtraction, halves the results, and writes the results to the\ndestination register.",
        "heading": "UHASX",
        "templates": {
          "A1": [
            "UHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UHASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UHSAX": {
        "authored": "Unsigned Halving Subtract and Add with Exchange exchanges the two halfwords of\nthe second operand, performs one unsigned 16-bit integer subtraction and one\nunsigned 16-bit addition, halves the results, and writes the results to the\ndestination register.",
        "heading": "UHSAX",
        "templates": {
          "A1": [
            "UHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UHSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UHSUB16": {
        "authored": "Unsigned Halving Subtract 16 performs two unsigned 16-bit integer subtractions,\nhalves the results, and writes the results to the destination register.",
        "heading": "UHSUB16",
        "templates": {
          "A1": [
            "UHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UHSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UHSUB8": {
        "authored": "Unsigned Halving Subtract 8 performs four unsigned 8-bit integer subtractions,\nhalves the results, and writes the results to the destination register.",
        "heading": "UHSUB8",
        "templates": {
          "A1": [
            "UHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UHSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UMAAL": {
        "authored": "Unsigned Multiply Accumulate Accumulate Long multiplies two unsigned 32-bit\nvalues to produce a 64-bit value, adds two unsigned 32-bit values, and writes\nthe 64-bit result to two registers.",
        "heading": "UMAAL",
        "templates": {
          "A1": [
            "UMAAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ],
          "T1": [
            "UMAAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ]
        }
      },
      "UMLAL": {
        "authored": "Unsigned Multiply Accumulate Long multiplies two unsigned 32-bit values to\nproduce a 64-bit value, and accumulates this with a 64-bit value.\n\nIn A32 instructions, the condition flags can optionally be updated based on the\nresult. Use of this option adversely affects performance on many\nimplementations.",
        "heading": "UMLAL, UMLALS",
        "templates": {
          "A1": [
            "UMLALS{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "UMLAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ],
          "T1": [
            "UMLAL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ]
        }
      },
      "UMULL": {
        "authored": "Unsigned Multiply Long multiplies two 32-bit unsigned values to produce a 64-bit\nresult.\n\nIn A32 instructions, the condition flags can optionally be updated based on the\nresult. Use of this option adversely affects performance on many\nimplementations.",
        "heading": "UMULL, UMULLS",
        "templates": {
          "A1": [
            "UMULLS{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>",
            "UMULL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ],
          "T1": [
            "UMULL{<c>}{<q>} <RdLo>, <RdHi>, <Rn>, <Rm>"
          ]
        }
      },
      "UQADD16": {
        "authored": "Unsigned Saturating Add 16 performs two unsigned 16-bit integer additions,\nsaturates the results to the 16-bit unsigned integer range 0 <= x <= 2^16 - 1,\nand writes the results to the destination register.",
        "heading": "UQADD16",
        "templates": {
          "A1": [
            "UQADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UQADD16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UQADD8": {
        "authored": "Unsigned Saturating Add 8 performs four unsigned 8-bit integer additions,\nsaturates the results to the 8-bit unsigned integer range 0 <= x <= 2^8 - 1, and\nwrites the results to the destination register.",
        "heading": "UQADD8",
        "templates": {
          "A1": [
            "UQADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UQADD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UQASX": {
        "authored": "Unsigned Saturating Add and Subtract with Exchange exchanges the two halfwords\nof the second operand, performs one unsigned 16-bit integer addition and one\nunsigned 16-bit subtraction, saturates the results to the 16-bit unsigned\ninteger range 0 <= x <= 2^16 - 1, and writes the results to the destination\nregister.",
        "heading": "UQASX",
        "templates": {
          "A1": [
            "UQASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UQASX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UQSAX": {
        "authored": "Unsigned Saturating Subtract and Add with Exchange exchanges the two halfwords\nof the second operand, performs one unsigned 16-bit integer subtraction and one\nunsigned 16-bit addition, saturates the results to the 16-bit unsigned integer\nrange 0 <= x <= 2^16 - 1, and writes the results to the destination register.",
        "heading": "UQSAX",
        "templates": {
          "A1": [
            "UQSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UQSAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UQSUB16": {
        "authored": "Unsigned Saturating Subtract 16 performs two unsigned 16-bit integer\nsubtractions, saturates the results to the 16-bit unsigned integer range 0 <= x\n<= 2^16 - 1, and writes the results to the destination register.",
        "heading": "UQSUB16",
        "templates": {
          "A1": [
            "UQSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UQSUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UQSUB8": {
        "authored": "Unsigned Saturating Subtract 8 performs four unsigned 8-bit integer\nsubtractions, saturates the results to the 8-bit unsigned integer range 0 <= x\n<= 2^8 - 1, and writes the results to the destination register.",
        "heading": "UQSUB8",
        "templates": {
          "A1": [
            "UQSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "UQSUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "USAD8": {
        "authored": "Unsigned Sum of Absolute Differences performs four unsigned 8-bit subtractions,\nand adds the absolute values of the differences together.",
        "heading": "USAD8",
        "templates": {
          "A1": [
            "USAD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "USAD8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "USADA8": {
        "authored": "Unsigned Sum of Absolute Differences and Accumulate performs four unsigned 8-bit\nsubtractions, and adds the absolute values of the differences to a 32-bit\naccumulate operand.",
        "heading": "USADA8",
        "templates": {
          "A1": [
            "USADA8{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ],
          "T1": [
            "USADA8{<c>}{<q>} <Rd>, <Rn>, <Rm>, <Ra>"
          ]
        }
      },
      "USAT": {
        "authored": "Unsigned Saturate saturates an optionally-shifted signed value to a selected\nunsigned range.\n\nThis instruction sets PSTATE.Q to 1 if the operation saturates.",
        "heading": "USAT",
        "templates": {
          "A1": [
            "USAT{<c>}{<q>} <Rd>, #<imm>, <Rn>, ASR #<amount>",
            "USAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, LSL #<amount>}"
          ],
          "T1": [
            "USAT{<c>}{<q>} <Rd>, #<imm>, <Rn>, ASR #<amount>",
            "USAT{<c>}{<q>} <Rd>, #<imm>, <Rn> {, LSL #<amount>}"
          ]
        }
      },
      "USAT16": {
        "authored": "Unsigned Saturate 16 saturates two signed 16-bit values to a selected unsigned\nrange.\n\nThis instruction sets PSTATE.Q to 1 if the operation saturates.",
        "heading": "USAT16",
        "templates": {
          "A1": [
            "USAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>"
          ],
          "T1": [
            "USAT16{<c>}{<q>} <Rd>, #<imm>, <Rn>"
          ]
        }
      },
      "USAX": {
        "authored": "Unsigned Subtract and Add with Exchange exchanges the two halfwords of the\nsecond operand, performs one unsigned 16-bit integer subtraction and one\nunsigned 16-bit addition, and writes the results to the destination register. It\nsets PSTATE.GE according to the results.",
        "heading": "USAX",
        "templates": {
          "A1": [
            "USAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "USAX{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "USUB16": {
        "authored": "Unsigned Subtract 16 performs two 16-bit unsigned integer subtractions, and\nwrites the results to the destination register. It sets PSTATE.GE according to\nthe results of the subtractions.",
        "heading": "USUB16",
        "templates": {
          "A1": [
            "USUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "USUB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "USUB8": {
        "authored": "Unsigned Subtract 8 performs four 8-bit unsigned integer subtractions, and\nwrites the results to the destination register. It sets PSTATE.GE according to\nthe results of the subtractions.",
        "heading": "USUB8",
        "templates": {
          "A1": [
            "USUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ],
          "T1": [
            "USUB8{<c>}{<q>} {<Rd>,} <Rn>, <Rm>"
          ]
        }
      },
      "UXTAB": {
        "authored": "Unsigned Extend and Add Byte extracts an 8-bit value from a register, zero-\nextends it to 32 bits, adds the result to the value in another register, and\nwrites the final result to the destination register. The instruction can specify\na rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value.",
        "heading": "UXTAB",
        "templates": {
          "A1": [
            "UXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
          ],
          "T1": [
            "UXTAB{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
          ]
        }
      },
      "UXTAB16": {
        "authored": "Unsigned Extend and Add Byte 16 extracts two 8-bit values from a register, zero-\nextends them to 16 bits each, adds the results to two 16-bit values from another\nregister, and writes the final results to the destination register. The\ninstruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the\n8-bit values.",
        "heading": "UXTAB16",
        "templates": {
          "A1": [
            "UXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
          ],
          "T1": [
            "UXTAB16{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
          ]
        }
      },
      "UXTAH": {
        "authored": "Unsigned Extend and Add Halfword extracts a 16-bit value from a register, zero-\nextends it to 32 bits, adds the result to a value from another register, and\nwrites the final result to the destination register. The instruction can specify\na rotation by 0, 8, 16, or 24 bits before extracting the 16-bit value.",
        "heading": "UXTAH",
        "templates": {
          "A1": [
            "UXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
          ],
          "T1": [
            "UXTAH{<c>}{<q>} {<Rd>,} <Rn>, <Rm> {, ROR #<amount>}"
          ]
        }
      },
      "UXTB": {
        "authored": "Unsigned Extend Byte extracts an 8-bit value from a register, zero-extends it to\n32 bits, and writes the result to the destination register. The instruction can\nspecify a rotation by 0, 8, 16, or 24 bits before extracting the 8-bit value.",
        "heading": "UXTB",
        "templates": {
          "A1": [
            "UXTB{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
          ],
          "T1": [
            "UXTB{<c>}{<q>} {<Rd>,} <Rm>"
          ],
          "T2": [
            "UXTB{<c>}.W {<Rd>,} <Rm>",
            "UXTB{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
          ]
        }
      },
      "UXTB16": {
        "authored": "Unsigned Extend Byte 16 extracts two 8-bit values from a register, zero-extends\nthem to 16 bits each, and writes the results to the destination register. The\ninstruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the\n8-bit values.",
        "heading": "UXTB16",
        "templates": {
          "A1": [
            "UXTB16{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
          ],
          "T1": [
            "UXTB16{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
          ]
        }
      },
      "UXTH": {
        "authored": "Unsigned Extend Halfword extracts a 16-bit value from a register, zero-extends\nit to 32 bits, and writes the result to the destination register. The\ninstruction can specify a rotation by 0, 8, 16, or 24 bits before extracting the\n16-bit value.",
        "heading": "UXTH",
        "templates": {
          "A1": [
            "UXTH{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
          ],
          "T1": [
            "UXTH{<c>}{<q>} {<Rd>,} <Rm>"
          ],
          "T2": [
            "UXTH{<c>}.W {<Rd>,} <Rm>",
            "UXTH{<c>}{<q>} {<Rd>,} <Rm> {, ROR #<amount>}"
          ]
        }
      },
      "WFE": {
        "authored": "Wait For Event is a hint instruction that indicates that the PE can enter a low-\npower state and remain there until a wakeup event occurs. Wakeup events include\nthe event signaled as a result of executing the SEV instruction on any PE in the\nmultiprocessor system. For more information, see Wait For Event and Send Event.\n\nAs described in Wait For Event and Send Event, the execution of a WFE\ninstruction that would otherwise cause entry to a low-power state can be trapped\nto a higher Exception level, see:\n  - Traps to Undefined mode of PL0 execution of WFE and WFI instructions.\n  - Traps to Hyp mode of Non-secure EL0 and EL1 execution of WFE and WFI\ninstructions.\n  - Traps to Monitor mode of the execution of WFE and WFI instructions in modes\nother than Monitor mode.",
        "heading": "WFE",
        "templates": {
          "A1": [
            "WFE{<c>}{<q>}"
          ],
          "T1": [
            "WFE{<c>}{<q>}"
          ],
          "T2": [
            "WFE{<c>}.W"
          ]
        }
      },
      "WFI": {
        "authored": "Wait For Interrupt is a hint instruction that indicates that the PE can enter a\nlow-power state and remain there until a wakeup event occurs. For more\ninformation, see Wait For Interrupt.\n\nAs described in Wait For Interrupt, the execution of a WFI instruction that\nwould otherwise cause entry to a low-power state can be trapped to a higher\nException level, see:\n  - Traps to Undefined mode of PL0 execution of WFE and WFI instructions.\n  - Traps to Hyp mode of Non-secure EL0 and EL1 execution of WFE and WFI\ninstructions.\n  - Traps to Monitor mode of the execution of WFE and WFI instructions in modes\nother than Monitor mode.",
        "heading": "WFI",
        "templates": {
          "A1": [
            "WFI{<c>}{<q>}"
          ],
          "T1": [
            "WFI{<c>}{<q>}"
          ],
          "T2": [
            "WFI{<c>}.W"
          ]
        }
      },
      "YIELD": {
        "authored": "YIELD is a hint instruction. Software with a multithreading capability can use a\nYIELD instruction to indicate to the PE that it is performing a task, for\nexample a spin-lock, that could be swapped out to improve overall system\nperformance. The PE can use this hint to suspend and resume multiple software\nthreads if it supports the capability.\n\nFor more information about the recommended use of this instruction see The Yield\ninstruction.",
        "heading": "YIELD",
        "templates": {
          "A1": [
            "YIELD{<c>}{<q>}"
          ],
          "T1": [
            "YIELD{<c>}{<q>}"
          ],
          "T2": [
            "YIELD{<c>}.W"
          ]
        }
      }
    },
    "encodings": {
      "A32": {
        "ADC_i": {
          "A1": ["xxxx0010101xxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADC_r": {
          "A1": ["xxxx0000101xxxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADC_rr": {
          "A1": ["xxxx0000101xxxxxxxxxxxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADD_ADR": {
          "A1": ["xxxx001010001111xxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADD_SP_i": {
          "A1": ["xxxx0010100x1101xxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADD_SP_r": {
          "A1": ["xxxx0000100x1101xxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADD_i": {
          "A1": ["xxxx0010100xxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADD_r": {
          "A1": ["xxxx0000100xxxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1101xxxxxxxxxxxxxxxx"]
        },
        "ADD_rr": {
          "A1": ["xxxx0000100xxxxxxxxxxxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ADR": {
          "A1": ["xxxx001010001111xxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx001001001111xxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "AESD": {
          "A1": ["111100111x11xx00xxxx001101x0xxxx"]
        },
        "AESE": {
          "A1": ["111100111x11xx00xxxx001100x0xxxx"]
        },
        "AESIMC": {
          "A1": ["111100111x11xx00xxxx001111x0xxxx"]
        },
        "AESMC": {
          "A1": ["111100111x11xx00xxxx001110x0xxxx"]
        },
        "AND_i": {
          "A1": ["xxxx0010000xxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "AND_r": {
          "A1": ["xxxx0000000xxxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "AND_rr": {
          "A1": ["xxxx0000000xxxxxxxxxxxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ASRS_MOV_r": {
          "A1": ["xxxx000110110000xxxxxxxxx100xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ASRS_MOV_rr": {
          "A1": ["xxxx000110110000xxxxxxxx0101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ASR_MOV_r": {
          "A1": ["xxxx000110100000xxxxxxxxx100xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ASR_MOV_rr": {
          "A1": ["xxxx000110100000xxxxxxxx0101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "B": {
          "A1": ["xxxx1010xxxxxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BFC": {
          "A1": ["xxxx0111110xxxxxxxxxxxxxx0011111", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BFI": {
          "A1": ["xxxx0111110xxxxxxxxxxxxxx001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxxxxxxxxxxxxx1111"]
        },
        "BIC_i": {
          "A1": ["xxxx0011110xxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BIC_r": {
          "A1": ["xxxx0001110xxxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BIC_rr": {
          "A1": ["xxxx0001110xxxxxxxxxxxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BKPT": {
          "A1": ["xxxx00010010xxxxxxxxxxxx0111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BLX_r": {
          "A1": ["xxxx000100101111111111110011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BL_i": {
          "A1": ["xxxx1011xxxxxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["1111101xxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BX": {
          "A1": ["xxxx000100101111111111110001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "BXJ": {
          "A1": ["xxxx000100101111111111110010xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CLREX": {
          "A1": ["11110101011111111111000000011111"]
        },
        "CLZ": {
          "A1": ["xxxx000101101111xxxx11110001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CMN_i": {
          "A1": ["xxxx00110111xxxx0000xxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CMN_r": {
          "A1": ["xxxx00010111xxxx0000xxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CMN_rr": {
          "A1": ["xxxx00010111xxxx0000xxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CMP_i": {
          "A1": ["xxxx00110101xxxx0000xxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CMP_r": {
          "A1": ["xxxx00010101xxxx0000xxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CMP_rr": {
          "A1": ["xxxx00010101xxxx0000xxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CPS": {
          "A1": ["111100010000xxx00000000xxx0xxxxx"]
        },
        "CRC32": {
          "A1": ["xxxx00010xx0xxxxxxxx00000100xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CRC32C": {
          "A1": ["xxxx00010xx0xxxxxxxx00100100xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "CSDB": {
          "A1": ["xxxx0011001000001111000000010100", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "DBG": {
          "A1": ["xxxx001100100000111100001111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "DMB": {
          "A1": ["1111010101111111111100000101xxxx"]
        },
        "DSB": {
          "A1": ["1111010101111111111100000100xxxx"]
        },
        "EOR_i": {
          "A1": ["xxxx0010001xxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "EOR_r": {
          "A1": ["xxxx0000001xxxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "EOR_rr": {
          "A1": ["xxxx0000001xxxxxxxxxxxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ERET": {
          "A1": ["xxxx0001011000000000000001101110", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ESB": {
          "A1": ["xxxx0011001000001111000000010000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "FLDMX": {
          "A1": ["xxxx110xxxx1xxxxxxxx1011xxxxxxx1", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "FSTMX": {
          "A1": ["xxxx110xxxx0xxxxxxxx1011xxxxxxx1", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "HLT": {
          "A1": ["xxxx00010000xxxxxxxxxxxx0111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "HVC": {
          "A1": ["xxxx00010100xxxxxxxxxxxx0111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ISB": {
          "A1": ["1111010101111111111100000110xxxx"]
        },
        "LDA": {
          "A1": ["xxxx00011001xxxxxxxx110010011111", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDAB": {
          "A1": ["xxxx00011101xxxxxxxx110010011111", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDAEX": {
          "A1": ["xxxx00011001xxxxxxxx111010011111", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDAEXB": {
          "A1": ["xxxx00011101xxxxxxxx111010011111", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDAEXD": {
          "A1": ["xxxx00011011xxxxxxxx111010011111", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDAEXH": {
          "A1": ["xxxx00011111xxxxxxxx111010011111", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDAH": {
          "A1": ["xxxx00011111xxxxxxxx110010011111", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDC_i": {
          "A1": ["xxxx110xx0x1xxxx01011110xxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDC_l": {
          "A1": ["xxxx110xx0x1111101011110xxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDM": {
          "A1": ["xxxx100010x1xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDMDA": {
          "A1": ["xxxx100000x1xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDMDB": {
          "A1": ["xxxx100100x1xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDMIB": {
          "A1": ["xxxx100110x1xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDM_e": {
          "A1": ["xxxx100xx1x1xxxx1xxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDM_u": {
          "A1": ["xxxx100xx101xxxx0xxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRBT": {
          "A1": ["xxxx0100x111xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx0110x111xxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRB_i": {
          "A1": ["xxxx010xx1x1xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRB_l": {
          "A1": ["xxxx010xx1x11111xxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRB_r": {
          "A1": ["xxxx011xx1x1xxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRD_i": {
          "A1": ["xxxx000xx1x0xxxxxxxxxxxx1101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRD_l": {
          "A1": ["xxxx0001x1001111xxxxxxxx1101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRD_r": {
          "A1": ["xxxx000xx0x0xxxxxxxx00001101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDREX": {
          "A1": ["xxxx00011001xxxxxxxx111110011111", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDREXB": {
          "A1": ["xxxx00011101xxxxxxxx111110011111", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDREXD": {
          "A1": ["xxxx00011011xxxxxxxx111110011111", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDREXH": {
          "A1": ["xxxx00011111xxxxxxxx111110011111", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRHT": {
          "A1": ["xxxx0000x111xxxxxxxxxxxx1011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx0000x011xxxxxxxx00001011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRH_i": {
          "A1": ["xxxx000xx1x1xxxxxxxxxxxx1011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRH_l": {
          "A1": ["xxxx000xx1x11111xxxxxxxx1011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRH_r": {
          "A1": ["xxxx000xx0x1xxxxxxxx00001011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSBT": {
          "A1": ["xxxx0000x111xxxxxxxxxxxx1101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx0000x011xxxxxxxx00001101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSB_i": {
          "A1": ["xxxx000xx1x1xxxxxxxxxxxx1101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRSB_l": {
          "A1": ["xxxx000xx1x11111xxxxxxxx1101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSB_r": {
          "A1": ["xxxx000xx0x1xxxxxxxx00001101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSHT": {
          "A1": ["xxxx0000x111xxxxxxxxxxxx1111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx0000x011xxxxxxxx00001111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSH_i": {
          "A1": ["xxxx000xx1x1xxxxxxxxxxxx1111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRSH_l": {
          "A1": ["xxxx000xx1x11111xxxxxxxx1111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRSH_r": {
          "A1": ["xxxx000xx0x1xxxxxxxx00001111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDRT": {
          "A1": ["xxxx0100x011xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx0110x011xxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDR_i": {
          "A1": ["xxxx010xx0x1xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDR_l": {
          "A1": ["xxxx010xx0x11111xxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LDR_r": {
          "A1": ["xxxx011xx0x1xxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LSLS_MOV_r": {
          "A1": ["xxxx000110110000xxxxxxxxx000xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxxxxx00000xxxxxxx"]
        },
        "LSLS_MOV_rr": {
          "A1": ["xxxx000110110000xxxxxxxx0001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LSL_MOV_r": {
          "A1": ["xxxx000110100000xxxxxxxxx000xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxxxxx00000xxxxxxx"]
        },
        "LSL_MOV_rr": {
          "A1": ["xxxx000110100000xxxxxxxx0001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LSRS_MOV_r": {
          "A1": ["xxxx000110110000xxxxxxxxx010xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LSRS_MOV_rr": {
          "A1": ["xxxx000110110000xxxxxxxx0011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LSR_MOV_r": {
          "A1": ["xxxx000110100000xxxxxxxxx010xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "LSR_MOV_rr": {
          "A1": ["xxxx000110100000xxxxxxxx0011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MCR": {
          "A1": ["xxxx1110xxx0xxxxxxxx111xxxx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MCRR": {
          "A1": ["xxxx11000100xxxxxxxx111xxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MLA": {
          "A1": ["xxxx0000001xxxxxxxxxxxxx1001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MLS": {
          "A1": ["xxxx00000110xxxxxxxxxxxx1001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOVT": {
          "A1": ["xxxx00110100xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOV_i": {
          "A1": ["xxxx0011101x0000xxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx00110000xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOV_r": {
          "A1": ["xxxx0001101x0000xxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MOV_rr": {
          "A1": ["xxxx0001101x0000xxxxxxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MRC": {
          "A1": ["xxxx1110xxx1xxxxxxxx111xxxx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MRRC": {
          "A1": ["xxxx11000101xxxxxxxx111xxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MRS": {
          "A1": ["xxxx00010x001111xxxx000000000000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MRS_br": {
          "A1": ["xxxx00010x00xxxxxxxx001x00000000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MSR_br": {
          "A1": ["xxxx00010x10xxxx1111001x0000xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MSR_i": {
          "A1": ["xxxx00110x10xxxx1111xxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MSR_r": {
          "A1": ["xxxx00010x10xxxx111100000000xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MUL": {
          "A1": ["xxxx0000000xxxxx0000xxxx1001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MVN_i": {
          "A1": ["xxxx0011111x0000xxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MVN_r": {
          "A1": ["xxxx0001111x0000xxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "MVN_rr": {
          "A1": ["xxxx0001111x0000xxxxxxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "NOP": {
          "A1": ["xxxx0011001000001111000000000000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ORR_i": {
          "A1": ["xxxx0011100xxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ORR_r": {
          "A1": ["xxxx0001100xxxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ORR_rr": {
          "A1": ["xxxx0001100xxxxxxxxxxxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "PKH": {
          "A1": ["xxxx01101000xxxxxxxxxxxxxx01xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "PLD_i": {
          "A1": ["11110101xx01xxxx1111xxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "PLD_l": {
          "A1": ["11110101x10111111111xxxxxxxxxxxx"]
        },
        "PLD_r": {
          "A1": ["11110111xx01xxxx1111xxxxxxx0xxxx"]
        },
        "PLI_i": {
          "A1": ["11110100x101xxxx1111xxxxxxxxxxxx"]
        },
        "PLI_r": {
          "A1": ["11110110x101xxxx1111xxxxxxx0xxxx"]
        },
        "POP_LDM": {
          "A1": ["xxxx100010111101xxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "POP_LDR_i": {
          "A1": ["xxxx010010011101xxxx000000000100", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "PSSBB": {
          "A1": ["11110101011111111111000001000100"]
        },
        "PUSH_STMDB": {
          "A1": ["xxxx100100101101xxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "PUSH_STR_i": {
          "A1": ["xxxx010100101101xxxx000000000100", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "QADD": {
          "A1": ["xxxx00010000xxxxxxxx00000101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "QADD16": {
          "A1": ["xxxx01100010xxxxxxxx11110001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "QADD8": {
          "A1": ["xxxx01100010xxxxxxxx11111001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "QASX": {
          "A1": ["xxxx01100010xxxxxxxx11110011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "QDADD": {
          "A1": ["xxxx00010100xxxxxxxx00000101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "QDSUB": {
          "A1": ["xxxx00010110xxxxxxxx00000101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "QSAX": {
          "A1": ["xxxx01100010xxxxxxxx11110101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "QSUB": {
          "A1": ["xxxx00010010xxxxxxxx00000101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "QSUB16": {
          "A1": ["xxxx01100010xxxxxxxx11110111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "QSUB8": {
          "A1": ["xxxx01100010xxxxxxxx11111111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "RBIT": {
          "A1": ["xxxx011011111111xxxx11110011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "REV": {
          "A1": ["xxxx011010111111xxxx11110011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "REV16": {
          "A1": ["xxxx011010111111xxxx11111011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "REVSH": {
          "A1": ["xxxx011011111111xxxx11111011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "RFE": {
          "A1": ["1111100xx0x1xxxx0000101000000000"]
        },
        "RORS_MOV_r": {
          "A1": ["xxxx000110110000xxxxxxxxx110xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxxxxx00000xxxxxxx"]
        },
        "RORS_MOV_rr": {
          "A1": ["xxxx000110110000xxxxxxxx0111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "ROR_MOV_r": {
          "A1": ["xxxx000110100000xxxxxxxxx110xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxxxxxx00000xxxxxxx"]
        },
        "ROR_MOV_rr": {
          "A1": ["xxxx000110100000xxxxxxxx0111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "RRXS_MOV_r": {
          "A1": ["xxxx000110110000xxxx00000110xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "RRX_MOV_r": {
          "A1": ["xxxx000110100000xxxx00000110xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "RSB_i": {
          "A1": ["xxxx0010011xxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "RSB_r": {
          "A1": ["xxxx0000011xxxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "RSB_rr": {
          "A1": ["xxxx0000011xxxxxxxxxxxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "RSC_i": {
          "A1": ["xxxx0010111xxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "RSC_r": {
          "A1": ["xxxx0000111xxxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "RSC_rr": {
          "A1": ["xxxx0000111xxxxxxxxxxxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SADD16": {
          "A1": ["xxxx01100001xxxxxxxx11110001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SADD8": {
          "A1": ["xxxx01100001xxxxxxxx11111001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SASX": {
          "A1": ["xxxx01100001xxxxxxxx11110011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SB": {
          "A1": ["11110101011111111111000001110000"]
        },
        "SBC_i": {
          "A1": ["xxxx0010110xxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SBC_r": {
          "A1": ["xxxx0000110xxxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SBC_rr": {
          "A1": ["xxxx0000110xxxxxxxxxxxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SBFX": {
          "A1": ["xxxx0111101xxxxxxxxxxxxxx101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SDIV": {
          "A1": ["xxxx01110001xxxx1111xxxx0001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SEL": {
          "A1": ["xxxx01101000xxxxxxxx11111011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SETEND": {
          "A1": ["1111000100000001000000x000000000"]
        },
        "SETPAN": {
          "A1": ["1111000100010000000000x000000000"]
        },
        "SEV": {
          "A1": ["xxxx0011001000001111000000000100", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SEVL": {
          "A1": ["xxxx0011001000001111000000000101", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SHA1C": {
          "A1": ["111100100x00xxxxxxxx1100xxx0xxxx"]
        },
        "SHA1H": {
          "A1": ["111100111x11xx01xxxx001011x0xxxx"]
        },
        "SHA1M": {
          "A1": ["111100100x10xxxxxxxx1100xxx0xxxx"]
        },
        "SHA1P": {
          "A1": ["111100100x01xxxxxxxx1100xxx0xxxx"]
        },
        "SHA1SU0": {
          "A1": ["111100100x11xxxxxxxx1100xxx0xxxx"]
        },
        "SHA1SU1": {
          "A1": ["111100111x11xx10xxxx001110x0xxxx"]
        },
        "SHA256H": {
          "A1": ["111100110x00xxxxxxxx1100xxx0xxxx"]
        },
        "SHA256H2": {
          "A1": ["111100110x01xxxxxxxx1100xxx0xxxx"]
        },
        "SHA256SU0": {
          "A1": ["111100111x11xx10xxxx001111x0xxxx"]
        },
        "SHA256SU1": {
          "A1": ["111100110x10xxxxxxxx1100xxx0xxxx"]
        },
        "SHADD16": {
          "A1": ["xxxx01100011xxxxxxxx11110001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SHADD8": {
          "A1": ["xxxx01100011xxxxxxxx11111001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SHASX": {
          "A1": ["xxxx01100011xxxxxxxx11110011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SHSAX": {
          "A1": ["xxxx01100011xxxxxxxx11110101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SHSUB16": {
          "A1": ["xxxx01100011xxxxxxxx11110111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SHSUB8": {
          "A1": ["xxxx01100011xxxxxxxx11111111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMC": {
          "A1": ["xxxx000101100000000000000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMLABB": {
          "A1": ["xxxx00010000xxxxxxxxxxxx1xx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMLAD": {
          "A1": ["xxxx01110000xxxxxxxxxxxx00x1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "SMLAL": {
          "A1": ["xxxx0000111xxxxxxxxxxxxx1001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMLALBB": {
          "A1": ["xxxx00010100xxxxxxxxxxxx1xx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMLALD": {
          "A1": ["xxxx01110100xxxxxxxxxxxx00x1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMLAWB": {
          "A1": ["xxxx00010010xxxxxxxxxxxx1x00xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMLSD": {
          "A1": ["xxxx01110000xxxxxxxxxxxx01x1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "SMLSLD": {
          "A1": ["xxxx01110100xxxxxxxxxxxx01x1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMMLA": {
          "A1": ["xxxx01110101xxxxxxxxxxxx00x1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "SMMLS": {
          "A1": ["xxxx01110101xxxxxxxxxxxx11x1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMMUL": {
          "A1": ["xxxx01110101xxxx1111xxxx00x1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMUAD": {
          "A1": ["xxxx01110000xxxx1111xxxx00x1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMULBB": {
          "A1": ["xxxx00010110xxxx0000xxxx1xx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMULL": {
          "A1": ["xxxx0000110xxxxxxxxxxxxx1001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMULWB": {
          "A1": ["xxxx00010010xxxx0000xxxx1x10xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SMUSD": {
          "A1": ["xxxx01110000xxxx1111xxxx01x1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SRS": {
          "A1": ["1111100xx1x0110100000101000xxxxx"]
        },
        "SSAT": {
          "A1": ["xxxx0110101xxxxxxxxxxxxxxx01xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SSAT16": {
          "A1": ["xxxx01101010xxxxxxxx11110011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SSAX": {
          "A1": ["xxxx01100001xxxxxxxx11110101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SSBB": {
          "A1": ["11110101011111111111000001000000"]
        },
        "SSUB16": {
          "A1": ["xxxx01100001xxxxxxxx11110111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SSUB8": {
          "A1": ["xxxx01100001xxxxxxxx11111111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STC": {
          "A1": ["xxxx110xx0x0xxxx01011110xxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STL": {
          "A1": ["xxxx00011000xxxx111111001001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STLB": {
          "A1": ["xxxx00011100xxxx111111001001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STLEX": {
          "A1": ["xxxx00011000xxxxxxxx11101001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STLEXB": {
          "A1": ["xxxx00011100xxxxxxxx11101001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STLEXD": {
          "A1": ["xxxx00011010xxxxxxxx11101001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STLEXH": {
          "A1": ["xxxx00011110xxxxxxxx11101001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STLH": {
          "A1": ["xxxx00011110xxxx111111001001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STM": {
          "A1": ["xxxx100010x0xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STMDA": {
          "A1": ["xxxx100000x0xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STMDB": {
          "A1": ["xxxx100100x0xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STMIB": {
          "A1": ["xxxx100110x0xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STM_u": {
          "A1": ["xxxx100xx100xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRBT": {
          "A1": ["xxxx0100x110xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx0110x110xxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRB_i": {
          "A1": ["xxxx010xx1x0xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRB_r": {
          "A1": ["xxxx011xx1x0xxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRD_i": {
          "A1": ["xxxx000xx1x0xxxxxxxxxxxx1111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRD_r": {
          "A1": ["xxxx000xx0x0xxxxxxxx00001111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STREX": {
          "A1": ["xxxx00011000xxxxxxxx11111001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STREXB": {
          "A1": ["xxxx00011100xxxxxxxx11111001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STREXD": {
          "A1": ["xxxx00011010xxxxxxxx11111001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STREXH": {
          "A1": ["xxxx00011110xxxxxxxx11111001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRHT": {
          "A1": ["xxxx0000x110xxxxxxxxxxxx1011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx0000x010xxxxxxxx00001011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRH_i": {
          "A1": ["xxxx000xx1x0xxxxxxxxxxxx1011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRH_r": {
          "A1": ["xxxx000xx0x0xxxxxxxx00001011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STRT": {
          "A1": ["xxxx0100x010xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx0110x010xxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STR_i": {
          "A1": ["xxxx010xx0x0xxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "STR_r": {
          "A1": ["xxxx011xx0x0xxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_ADR": {
          "A2": ["xxxx001001001111xxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_SP_i": {
          "A1": ["xxxx0010010x1101xxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_SP_r": {
          "A1": ["xxxx0000010x1101xxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_i": {
          "A1": ["xxxx0010010xxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SUB_r": {
          "A1": ["xxxx0000010xxxxxxxxxxxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1101xxxxxxxxxxxxxxxx"]
        },
        "SUB_rr": {
          "A1": ["xxxx0000010xxxxxxxxxxxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SVC": {
          "A1": ["xxxx1111xxxxxxxxxxxxxxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SXTAB": {
          "A1": ["xxxx01101010xxxxxxxxxx000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "SXTAB16": {
          "A1": ["xxxx01101000xxxxxxxxxx000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "SXTAH": {
          "A1": ["xxxx01101011xxxxxxxxxx000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "SXTB": {
          "A1": ["xxxx011010101111xxxxxx000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SXTB16": {
          "A1": ["xxxx011010001111xxxxxx000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "SXTH": {
          "A1": ["xxxx011010111111xxxxxx000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "TEQ_i": {
          "A1": ["xxxx00110011xxxx0000xxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "TEQ_r": {
          "A1": ["xxxx00010011xxxx0000xxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "TEQ_rr": {
          "A1": ["xxxx00010011xxxx0000xxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "TSB": {
          "A1": ["xxxx0011001000001111000000010010", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "TST_i": {
          "A1": ["xxxx00110001xxxx0000xxxxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "TST_r": {
          "A1": ["xxxx00010001xxxx0000xxxxxxx0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "TST_rr": {
          "A1": ["xxxx00010001xxxx0000xxxx0xx1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UADD16": {
          "A1": ["xxxx01100101xxxxxxxx11110001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UADD8": {
          "A1": ["xxxx01100101xxxxxxxx11111001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UASX": {
          "A1": ["xxxx01100101xxxxxxxx11110011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UBFX": {
          "A1": ["xxxx0111111xxxxxxxxxxxxxx101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UDF": {
          "A1": ["111001111111xxxxxxxxxxxx1111xxxx"]
        },
        "UDIV": {
          "A1": ["xxxx01110011xxxx1111xxxx0001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UHADD16": {
          "A1": ["xxxx01100111xxxxxxxx11110001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UHADD8": {
          "A1": ["xxxx01100111xxxxxxxx11111001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UHASX": {
          "A1": ["xxxx01100111xxxxxxxx11110011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UHSAX": {
          "A1": ["xxxx01100111xxxxxxxx11110101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UHSUB16": {
          "A1": ["xxxx01100111xxxxxxxx11110111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UHSUB8": {
          "A1": ["xxxx01100111xxxxxxxx11111111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UMAAL": {
          "A1": ["xxxx00000100xxxxxxxxxxxx1001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UMLAL": {
          "A1": ["xxxx0000101xxxxxxxxxxxxx1001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UMULL": {
          "A1": ["xxxx0000100xxxxxxxxxxxxx1001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UQADD16": {
          "A1": ["xxxx01100110xxxxxxxx11110001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UQADD8": {
          "A1": ["xxxx01100110xxxxxxxx11111001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UQASX": {
          "A1": ["xxxx01100110xxxxxxxx11110011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UQSAX": {
          "A1": ["xxxx01100110xxxxxxxx11110101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UQSUB16": {
          "A1": ["xxxx01100110xxxxxxxx11110111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UQSUB8": {
          "A1": ["xxxx01100110xxxxxxxx11111111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "USAD8": {
          "A1": ["xxxx01111000xxxx1111xxxx0001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "USADA8": {
          "A1": ["xxxx01111000xxxxxxxxxxxx0001xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "USAT": {
          "A1": ["xxxx0110111xxxxxxxxxxxxxxx01xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "USAT16": {
          "A1": ["xxxx01101110xxxxxxxx11110011xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "USAX": {
          "A1": ["xxxx01100101xxxxxxxx11110101xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "USUB16": {
          "A1": ["xxxx01100101xxxxxxxx11110111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "USUB8": {
          "A1": ["xxxx01100101xxxxxxxx11111111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UXTAB": {
          "A1": ["xxxx01101110xxxxxxxxxx000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "UXTAB16": {
          "A1": ["xxxx01101100xxxxxxxxxx000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "UXTAH": {
          "A1": ["xxxx01101111xxxxxxxxxx000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "UXTB": {
          "A1": ["xxxx011011101111xxxxxx000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UXTB16": {
          "A1": ["xxxx011011001111xxxxxx000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "UXTH": {
          "A1": ["xxxx011011111111xxxxxx000111xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VABA": {
          "A1": ["1111001x0xxxxxxxxxxx0111xxx1xxxx"]
        },
        "VABAL": {
          "A1": ["1111001x1xxxxxxxxxxx0101x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VABDL_i": {
          "A1": ["1111001x1xxxxxxxxxxx0111x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VABD_f": {
          "A1": ["111100110x1xxxxxxxxx1101xxx0xxxx"]
        },
        "VABD_i": {
          "A1": ["1111001x0xxxxxxxxxxx0111xxx0xxxx"]
        },
        "VABS": {
          "A1": ["111100111x11xx01xxxx0x110xx0xxxx"],
          "A2": ["xxxx11101x110000xxxx10xx11x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VACGE": {
          "A1": ["111100110x0xxxxxxxxx1110xxx1xxxx"]
        },
        "VACGT": {
          "A1": ["111100110x1xxxxxxxxx1110xxx1xxxx"]
        },
        "VACLE_VACGE": {
          "A1": ["111100110x0xxxxxxxxx1110xxx1xxxx"]
        },
        "VACLT_VACGT": {
          "A1": ["111100110x1xxxxxxxxx1110xxx1xxxx"]
        },
        "VADDHN": {
          "A1": ["111100101xxxxxxxxxxx0100x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VADDL": {
          "A1": ["1111001x1xxxxxxxxxxx0000x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VADDW": {
          "A1": ["1111001x1xxxxxxxxxxx0001x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VADD_f": {
          "A1": ["111100100x0xxxxxxxxx1101xxx0xxxx"],
          "A2": ["xxxx11100x11xxxxxxxx10xxx0x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VADD_i": {
          "A1": ["111100100xxxxxxxxxxx1000xxx0xxxx"]
        },
        "VAND_VBIC_i": {
          "A1": ["1111001x1x000xxxxxxx0xx10x11xxxx"],
          "A2": ["1111001x1x000xxxxxxx10x10x11xxxx"]
        },
        "VAND_r": {
          "A1": ["111100100x00xxxxxxxx0001xxx1xxxx"]
        },
        "VBIC_i": {
          "A1": ["1111001x1x000xxxxxxx0xx10x11xxxx"],
          "A2": ["1111001x1x000xxxxxxx10x10x11xxxx"]
        },
        "VBIC_r": {
          "A1": ["111100100x01xxxxxxxx0001xxx1xxxx"]
        },
        "VBIF": {
          "A1": ["111100110x11xxxxxxxx0001xxx1xxxx"]
        },
        "VBIT": {
          "A1": ["111100110x10xxxxxxxx0001xxx1xxxx"]
        },
        "VBSL": {
          "A1": ["111100110x01xxxxxxxx0001xxx1xxxx"]
        },
        "VCADD": {
          "A1": ["1111110x1x0xxxxxxxxx1000xxx0xxxx"]
        },
        "VCEQ_i": {
          "A1": ["111100111x11xx01xxxx0x010xx0xxxx"]
        },
        "VCEQ_r": {
          "A1": ["111100110xxxxxxxxxxx1000xxx1xxxx"],
          "A2": ["111100100x0xxxxxxxxx1110xxx0xxxx"]
        },
        "VCGE_i": {
          "A1": ["111100111x11xx01xxxx0x001xx0xxxx"]
        },
        "VCGE_r": {
          "A1": ["1111001x0xxxxxxxxxxx0011xxx1xxxx"],
          "A2": ["111100110x0xxxxxxxxx1110xxx0xxxx"]
        },
        "VCGT_i": {
          "A1": ["111100111x11xx01xxxx0x000xx0xxxx"]
        },
        "VCGT_r": {
          "A1": ["1111001x0xxxxxxxxxxx0011xxx0xxxx"],
          "A2": ["111100110x1xxxxxxxxx1110xxx0xxxx"]
        },
        "VCLE_VCGE_r": {
          "A1": ["1111001x0xxxxxxxxxxx0011xxx1xxxx"],
          "A2": ["111100110x0xxxxxxxxx1110xxx0xxxx"]
        },
        "VCLE_i": {
          "A1": ["111100111x11xx01xxxx0x011xx0xxxx"]
        },
        "VCLS": {
          "A1": ["111100111x11xx00xxxx01000xx0xxxx"]
        },
        "VCLT_VCGT_r": {
          "A1": ["1111001x0xxxxxxxxxxx0011xxx0xxxx"],
          "A2": ["111100110x1xxxxxxxxx1110xxx0xxxx"]
        },
        "VCLT_i": {
          "A1": ["111100111x11xx01xxxx0x100xx0xxxx"]
        },
        "VCLZ": {
          "A1": ["111100111x11xx00xxxx01001xx0xxxx"]
        },
        "VCMLA": {
          "A1": ["1111110xxx1xxxxxxxxx1000xxx0xxxx"]
        },
        "VCMLA_s": {
          "A1": ["11111110xxxxxxxxxxxx1000xxx0xxxx"]
        },
        "VCMP": {
          "A1": ["xxxx11101x110100xxxx10xx01x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx11101x110101xxxx10xx01000000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VCMPE": {
          "A1": ["xxxx11101x110100xxxx10xx11x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx11101x110101xxxx10xx11000000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VCNT": {
          "A1": ["111100111x11xx00xxxx01010xx0xxxx"]
        },
        "VCVTA_asimd": {
          "A1": ["111100111x11xx11xxxx0000xxx0xxxx"]
        },
        "VCVTA_vfp": {
          "A1": ["111111101x111100xxxx10xxx1x0xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VCVTB": {
          "A1": ["xxxx11101x11001xxxxx101x01x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VCVTM_asimd": {
          "A1": ["111100111x11xx11xxxx0011xxx0xxxx"]
        },
        "VCVTM_vfp": {
          "A1": ["111111101x111111xxxx10xxx1x0xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VCVTN_asimd": {
          "A1": ["111100111x11xx11xxxx0001xxx0xxxx"]
        },
        "VCVTN_vfp": {
          "A1": ["111111101x111101xxxx10xxx1x0xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VCVTP_asimd": {
          "A1": ["111100111x11xx11xxxx0010xxx0xxxx"]
        },
        "VCVTP_vfp": {
          "A1": ["111111101x111110xxxx10xxx1x0xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VCVTR_iv": {
          "A1": ["xxxx11101x11110xxxxx10xx01x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VCVTT": {
          "A1": ["xxxx11101x11001xxxxx101x11x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VCVT_ds": {
          "A1": ["xxxx11101x110111xxxx101x11x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VCVT_hs": {
          "A1": ["111100111x11xx10xxxx011x00x0xxxx"]
        },
        "VCVT_is": {
          "A1": ["111100111x11xx11xxxx011xxxx0xxxx"]
        },
        "VCVT_iv": {
          "A1": ["xxxx11101x11110xxxxx10xx11x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VCVT_vi": {
          "A1": ["xxxx11101x111000xxxx10xxx1x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VCVT_xs": {
          "A1": ["1111001x1xxxxxxxxxxx11xx0xx1xxxx"]
        },
        "VCVT_xv": {
          "A1": ["xxxx11101x111x1xxxxx10xxx1x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VDIV": {
          "A1": ["xxxx11101x00xxxxxxxx10xxx0x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VDUP_r": {
          "A1": ["xxxx11101xx0xxxxxxxx1011x0x10000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VDUP_s": {
          "A1": ["111100111x11xxxxxxxx11000xx0xxxx"]
        },
        "VEOR": {
          "A1": ["111100110x00xxxxxxxx0001xxx1xxxx"]
        },
        "VEXT": {
          "A1": ["111100101x11xxxxxxxxxxxxxxx0xxxx"]
        },
        "VEXT_VEXT": {
          "A1": ["111100101x11xxxxxxxxxxxxxxx0xxxx"]
        },
        "VFMA": {
          "A1": ["111100100x0xxxxxxxxx1100xxx1xxxx"],
          "A2": ["xxxx11101x10xxxxxxxx10xxx0x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VFMAL": {
          "A1": ["111111000x10xxxxxxxx1000xxx1xxxx"]
        },
        "VFMAL_s": {
          "A1": ["111111100x00xxxxxxxx1000xxx1xxxx"]
        },
        "VFMS": {
          "A1": ["111100100x1xxxxxxxxx1100xxx1xxxx"],
          "A2": ["xxxx11101x10xxxxxxxx10xxx1x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VFMSL": {
          "A1": ["111111001x10xxxxxxxx1000xxx1xxxx"]
        },
        "VFMSL_s": {
          "A1": ["111111100x01xxxxxxxx1000xxx1xxxx"]
        },
        "VFNMA": {
          "A1": ["xxxx11101x01xxxxxxxx10xxx1x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VFNMS": {
          "A1": ["xxxx11101x01xxxxxxxx10xxx0x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VHADD": {
          "A1": ["1111001x0xxxxxxxxxxx0000xxx0xxxx"]
        },
        "VHSUB": {
          "A1": ["1111001x0xxxxxxxxxxx0010xxx0xxxx"]
        },
        "VINS": {
          "A1": ["111111101x110000xxxx101011x0xxxx"]
        },
        "VJCVT": {
          "A1": ["xxxx11101x111001xxxx101111x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VLD1_1": {
          "A1": ["111101001x10xxxxxxxx0000xxxxxxxx"],
          "A2": ["111101001x10xxxxxxxx0100xxxxxxxx"],
          "A3": ["111101001x10xxxxxxxx1000xxxxxxxx"]
        },
        "VLD1_a": {
          "A1": ["111101001x10xxxxxxxx1100xxxxxxxx"]
        },
        "VLD1_m": {
          "A1": ["111101000x10xxxxxxxx0111xxxxxxxx"],
          "A2": ["111101000x10xxxxxxxx1010xxxxxxxx"],
          "A3": ["111101000x10xxxxxxxx0110xxxxxxxx"],
          "A4": ["111101000x10xxxxxxxx0010xxxxxxxx"]
        },
        "VLD2_1": {
          "A1": ["111101001x10xxxxxxxx0001xxxxxxxx"],
          "A2": ["111101001x10xxxxxxxx0101xxxxxxxx"],
          "A3": ["111101001x10xxxxxxxx1001xxxxxxxx"]
        },
        "VLD2_a": {
          "A1": ["111101001x10xxxxxxxx1101xxxxxxxx"]
        },
        "VLD2_m": {
          "A1": ["111101000x10xxxxxxxx100xxxxxxxxx"],
          "A2": ["111101000x10xxxxxxxx0011xxxxxxxx"]
        },
        "VLD3_1": {
          "A1": ["111101001x10xxxxxxxx0010xxxxxxxx"],
          "A2": ["111101001x10xxxxxxxx0110xxxxxxxx"],
          "A3": ["111101001x10xxxxxxxx1010xxxxxxxx"]
        },
        "VLD3_a": {
          "A1": ["111101001x10xxxxxxxx1110xxx0xxxx"]
        },
        "VLD3_m": {
          "A1": ["111101000x10xxxxxxxx010xxxxxxxxx"]
        },
        "VLD4_1": {
          "A1": ["111101001x10xxxxxxxx0011xxxxxxxx"],
          "A2": ["111101001x10xxxxxxxx0111xxxxxxxx"],
          "A3": ["111101001x10xxxxxxxx1011xxxxxxxx"]
        },
        "VLD4_a": {
          "A1": ["111101001x10xxxxxxxx1111xxxxxxxx"]
        },
        "VLD4_m": {
          "A1": ["111101000x10xxxxxxxx000xxxxxxxxx"]
        },
        "VLDM": {
          "A1": ["xxxx110xxxx1xxxxxxxx1011xxxxxxx0", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx110xxxx1xxxxxxxx1010xxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VLDR_i": {
          "A1": ["xxxx1101xx01xxxxxxxx10xxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "VLDR_l": {
          "A1": ["xxxx1101xx011111xxxx10xxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMAXNM": {
          "A1": ["111100110x0xxxxxxxxx1111xxx1xxxx"],
          "A2": ["111111101x00xxxxxxxx10xxx0x0xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VMAX_f": {
          "A1": ["111100100x0xxxxxxxxx1111xxx0xxxx"]
        },
        "VMAX_i": {
          "A1": ["1111001x0xxxxxxxxxxx0110xxx0xxxx"]
        },
        "VMINNM": {
          "A1": ["111100110x1xxxxxxxxx1111xxx1xxxx"],
          "A2": ["111111101x00xxxxxxxx10xxx1x0xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VMIN_f": {
          "A1": ["111100100x1xxxxxxxxx1111xxx0xxxx"]
        },
        "VMIN_i": {
          "A1": ["1111001x0xxxxxxxxxxx0110xxx1xxxx"]
        },
        "VMLAL_i": {
          "A1": ["1111001x1xxxxxxxxxxx1000x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMLAL_s": {
          "A1": ["1111001x1xxxxxxxxxxx0010x1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMLA_f": {
          "A1": ["111100100x0xxxxxxxxx1101xxx1xxxx"],
          "A2": ["xxxx11100x00xxxxxxxx10xxx0x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMLA_i": {
          "A1": ["111100100xxxxxxxxxxx1001xxx0xxxx"]
        },
        "VMLA_s": {
          "A1": ["1111001x1xxxxxxxxxxx000xx1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMLSL_i": {
          "A1": ["1111001x1xxxxxxxxxxx1010x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMLSL_s": {
          "A1": ["1111001x1xxxxxxxxxxx0110x1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMLS_f": {
          "A1": ["111100100x1xxxxxxxxx1101xxx1xxxx"],
          "A2": ["xxxx11100x00xxxxxxxx10xxx1x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMLS_i": {
          "A1": ["111100110xxxxxxxxxxx1001xxx0xxxx"]
        },
        "VMLS_s": {
          "A1": ["1111001x1xxxxxxxxxxx010xx1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMOVL": {
          "A1": ["1111001x1xxxx000xxxx101000x1xxxx", "xxxxxxxxxx000xxxxxxxxxxxxxxxxxxx"]
        },
        "VMOVN": {
          "A1": ["111100111x11xx10xxxx001000x0xxxx"]
        },
        "VMOVX": {
          "A1": ["111111101x110000xxxx101001x0xxxx"]
        },
        "VMOV_VORR_r": {
          "A1": ["111100100x10xxxxxxxx0001xxx1xxxx"]
        },
        "VMOV_d": {
          "A1": ["xxxx1100010xxxxxxxxx101100x1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMOV_h": {
          "A1": ["xxxx1110000xxxxxxxxx1001x0010000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMOV_i": {
          "A1": ["1111001x1x000xxxxxxx0xx00x01xxxx"],
          "A2": ["xxxx11101x11xxxxxxxx10xx0000xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A3": ["1111001x1x000xxxxxxx10x00x01xxxx"],
          "A4": ["1111001x1x000xxxxxxx11xx0x01xxxx"],
          "A5": ["1111001x1x000xxxxxxx11100x11xxxx"]
        },
        "VMOV_r": {
          "A2": ["xxxx11101x110000xxxx101x01x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMOV_rs": {
          "A1": ["xxxx11100xx0xxxxxxxx1011xxx10000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMOV_s": {
          "A1": ["xxxx1110000xxxxxxxxx1010x0010000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMOV_sr": {
          "A1": ["xxxx1110xxx1xxxxxxxx1011xxx10000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMOV_ss": {
          "A1": ["xxxx1100010xxxxxxxxx101000x1xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMRS": {
          "A1": ["xxxx11101111xxxxxxxx101000010000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMSR": {
          "A1": ["xxxx11101110xxxxxxxx101000010000", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMULL_i": {
          "A1": ["1111001x1xxxxxxxxxxx11x0x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMULL_s": {
          "A1": ["1111001x1xxxxxxxxxxx1010x1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMUL_f": {
          "A1": ["111100110x0xxxxxxxxx1101xxx1xxxx"],
          "A2": ["xxxx11100x10xxxxxxxx10xxx0x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VMUL_i": {
          "A1": ["1111001x0xxxxxxxxxxx1001xxx1xxxx"]
        },
        "VMUL_s": {
          "A1": ["1111001x1xxxxxxxxxxx100xx1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMVN_i": {
          "A1": ["1111001x1x000xxxxxxx0xx00x11xxxx"],
          "A2": ["1111001x1x000xxxxxxx10x00x11xxxx"],
          "A3": ["1111001x1x000xxxxxxx110x0x11xxxx"]
        },
        "VMVN_r": {
          "A1": ["111100111x11xx00xxxx01011xx0xxxx"]
        },
        "VNEG": {
          "A1": ["111100111x11xx01xxxx0x111xx0xxxx"],
          "A2": ["xxxx11101x110001xxxx10xx01x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VNMLA": {
          "A1": ["xxxx11100x01xxxxxxxx10xxx1x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VNMLS": {
          "A1": ["xxxx11100x01xxxxxxxx10xxx0x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VNMUL": {
          "A1": ["xxxx11100x10xxxxxxxx10xxx1x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VORN_VORR_i": {
          "A1": ["1111001x1x000xxxxxxx0xx10x01xxxx"],
          "A2": ["1111001x1x000xxxxxxx10x10x01xxxx"]
        },
        "VORN_r": {
          "A1": ["111100100x11xxxxxxxx0001xxx1xxxx"]
        },
        "VORR_i": {
          "A1": ["1111001x1x000xxxxxxx0xx10x01xxxx"],
          "A2": ["1111001x1x000xxxxxxx10x10x01xxxx"]
        },
        "VORR_r": {
          "A1": ["111100100x10xxxxxxxx0001xxx1xxxx"]
        },
        "VPADAL": {
          "A1": ["111100111x11xx00xxxx0110xxx0xxxx"]
        },
        "VPADDL": {
          "A1": ["111100111x11xx00xxxx0010xxx0xxxx"]
        },
        "VPADD_f": {
          "A1": ["111100110x0xxxxxxxxx1101xxx0xxxx"]
        },
        "VPADD_i": {
          "A1": ["111100100xxxxxxxxxxx1011xxx1xxxx"]
        },
        "VPMAX_f": {
          "A1": ["111100110x0xxxxxxxxx1111x0x0xxxx"]
        },
        "VPMAX_i": {
          "A1": ["1111001x0xxxxxxxxxxx1010x0x0xxxx"]
        },
        "VPMIN_f": {
          "A1": ["111100110x1xxxxxxxxx1111x0x0xxxx"]
        },
        "VPMIN_i": {
          "A1": ["1111001x0xxxxxxxxxxx1010x0x1xxxx"]
        },
        "VPOP_VLDM": {
          "A1": ["xxxx11001x111101xxxx1011xxxxxxx0", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx11001x111101xxxx1010xxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VPUSH_VSTM": {
          "A1": ["xxxx11010x101101xxxx1011xxxxxxx0", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx11010x101101xxxx1010xxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VQABS": {
          "A1": ["111100111x11xx00xxxx01110xx0xxxx"]
        },
        "VQADD": {
          "A1": ["1111001x0xxxxxxxxxxx0000xxx1xxxx"]
        },
        "VQDMLAL": {
          "A1": ["111100101xxxxxxxxxxx1001x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"],
          "A2": ["111100101xxxxxxxxxxx0011x1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQDMLSL": {
          "A1": ["111100101xxxxxxxxxxx1011x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"],
          "A2": ["111100101xxxxxxxxxxx0111x1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQDMULH": {
          "A1": ["111100100xxxxxxxxxxx1011xxx0xxxx"],
          "A2": ["1111001x1xxxxxxxxxxx1100x1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQDMULL": {
          "A1": ["111100101xxxxxxxxxxx1101x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"],
          "A2": ["111100101xxxxxxxxxxx1011x1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQMOVN": {
          "A1": ["111100111x11xx10xxxx0010xxx0xxxx"]
        },
        "VQNEG": {
          "A1": ["111100111x11xx00xxxx01111xx0xxxx"]
        },
        "VQRDMLAH": {
          "A1": ["111100110xxxxxxxxxxx1011xxx1xxxx"],
          "A2": ["1111001x1xxxxxxxxxxx1110x1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQRDMLSH": {
          "A1": ["111100110xxxxxxxxxxx1100xxx1xxxx"],
          "A2": ["1111001x1xxxxxxxxxxx1111x1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQRDMULH": {
          "A1": ["111100110xxxxxxxxxxx1011xxx0xxxx"],
          "A2": ["1111001x1xxxxxxxxxxx1101x1x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQRSHL": {
          "A1": ["1111001x0xxxxxxxxxxx0101xxx1xxxx"]
        },
        "VQRSHRN": {
          "A1": ["1111001x1xxxxxxxxxxx100x01x1xxxx"]
        },
        "VQRSHRN_VQMOVN": {
          "A1": ["111100111x11xx10xxxx00101xx0xxxx"]
        },
        "VQRSHRUN_VQMOVN": {
          "A1": ["111100111x11xx10xxxx001001x0xxxx"]
        },
        "VQSHL_i": {
          "A1": ["1111001x1xxxxxxxxxxx011xxxx1xxxx"]
        },
        "VQSHL_r": {
          "A1": ["1111001x0xxxxxxxxxxx0100xxx1xxxx"]
        },
        "VQSHRN": {
          "A1": ["1111001x1xxxxxxxxxxx100x00x1xxxx"]
        },
        "VQSHRN_VQMOVN": {
          "A1": ["111100111x11xx10xxxx00101xx0xxxx"]
        },
        "VQSHRUN_VQMOVN": {
          "A1": ["111100111x11xx10xxxx001001x0xxxx"]
        },
        "VQSUB": {
          "A1": ["1111001x0xxxxxxxxxxx0010xxx1xxxx"]
        },
        "VRADDHN": {
          "A1": ["111100111xxxxxxxxxxx0100x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VRECPE": {
          "A1": ["111100111x11xx11xxxx010x0xx0xxxx"]
        },
        "VRECPS": {
          "A1": ["111100100x0xxxxxxxxx1111xxx1xxxx"]
        },
        "VREV16": {
          "A1": ["111100111x11xx00xxxx00010xx0xxxx"]
        },
        "VREV32": {
          "A1": ["111100111x11xx00xxxx00001xx0xxxx"]
        },
        "VREV64": {
          "A1": ["111100111x11xx00xxxx00000xx0xxxx"]
        },
        "VRHADD": {
          "A1": ["1111001x0xxxxxxxxxxx0001xxx0xxxx"]
        },
        "VRINTA_asimd": {
          "A1": ["111100111x11xx10xxxx01010xx0xxxx"]
        },
        "VRINTA_vfp": {
          "A1": ["111111101x111000xxxx10xx01x0xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VRINTM_asimd": {
          "A1": ["111100111x11xx10xxxx01101xx0xxxx"]
        },
        "VRINTM_vfp": {
          "A1": ["111111101x111011xxxx10xx01x0xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VRINTN_asimd": {
          "A1": ["111100111x11xx10xxxx01000xx0xxxx"]
        },
        "VRINTN_vfp": {
          "A1": ["111111101x111001xxxx10xx01x0xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VRINTP_asimd": {
          "A1": ["111100111x11xx10xxxx01111xx0xxxx"]
        },
        "VRINTP_vfp": {
          "A1": ["111111101x111010xxxx10xx01x0xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VRINTR_vfp": {
          "A1": ["xxxx11101x110110xxxx10xx01x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VRINTX_asimd": {
          "A1": ["111100111x11xx10xxxx01001xx0xxxx"]
        },
        "VRINTX_vfp": {
          "A1": ["xxxx11101x110111xxxx10xx01x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VRINTZ_asimd": {
          "A1": ["111100111x11xx10xxxx01011xx0xxxx"]
        },
        "VRINTZ_vfp": {
          "A1": ["xxxx11101x110110xxxx10xx11x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VRSHL": {
          "A1": ["1111001x0xxxxxxxxxxx0101xxx0xxxx"]
        },
        "VRSHR": {
          "A1": ["1111001x1xxxxxxxxxxx0010xxx1xxxx"]
        },
        "VRSHRN": {
          "A1": ["111100101xxxxxxxxxxx100001x1xxxx"]
        },
        "VRSHRN_VMOVN": {
          "A1": ["111100111x11xx10xxxx001000x0xxxx"]
        },
        "VRSHR_VORR_r": {
          "A1": ["111100100x10xxxxxxxx0001xxx1xxxx"]
        },
        "VRSQRTE": {
          "A1": ["111100111x11xx11xxxx010x1xx0xxxx"]
        },
        "VRSQRTS": {
          "A1": ["111100100x1xxxxxxxxx1111xxx1xxxx"]
        },
        "VRSRA": {
          "A1": ["1111001x1xxxxxxxxxxx0011xxx1xxxx"]
        },
        "VRSUBHN": {
          "A1": ["111100111xxxxxxxxxxx0110x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VSDOT": {
          "A1": ["111111000x10xxxxxxxx1101xxx0xxxx"]
        },
        "VSDOT_s": {
          "A1": ["111111100x10xxxxxxxx1101xxx0xxxx"]
        },
        "VSEL": {
          "A1": ["111111100xxxxxxxxxxx10xxx0x0xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VSHLL": {
          "A1": ["1111001x1xxxxxxxxxxx101000x1xxxx"],
          "A2": ["111100111x11xx10xxxx001100x0xxxx"]
        },
        "VSHL_i": {
          "A1": ["111100101xxxxxxxxxxx0101xxx1xxxx"]
        },
        "VSHL_r": {
          "A1": ["1111001x0xxxxxxxxxxx0100xxx0xxxx"]
        },
        "VSHR": {
          "A1": ["1111001x1xxxxxxxxxxx0000xxx1xxxx"]
        },
        "VSHRN": {
          "A1": ["111100101xxxxxxxxxxx100000x1xxxx"]
        },
        "VSHRN_VMOVN": {
          "A1": ["111100111x11xx10xxxx001000x0xxxx"]
        },
        "VSHR_VORR_r": {
          "A1": ["111100100x10xxxxxxxx0001xxx1xxxx"]
        },
        "VSLI": {
          "A1": ["111100111xxxxxxxxxxx0101xxx1xxxx"]
        },
        "VSQRT": {
          "A1": ["xxxx11101x110001xxxx10xx11x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VSRA": {
          "A1": ["1111001x1xxxxxxxxxxx0001xxx1xxxx"]
        },
        "VSRI": {
          "A1": ["111100111xxxxxxxxxxx0100xxx1xxxx"]
        },
        "VST1_1": {
          "A1": ["111101001x00xxxxxxxx0000xxxxxxxx"],
          "A2": ["111101001x00xxxxxxxx0100xxxxxxxx"],
          "A3": ["111101001x00xxxxxxxx1000xxxxxxxx"]
        },
        "VST1_m": {
          "A1": ["111101000x00xxxxxxxx0111xxxxxxxx"],
          "A2": ["111101000x00xxxxxxxx1010xxxxxxxx"],
          "A3": ["111101000x00xxxxxxxx0110xxxxxxxx"],
          "A4": ["111101000x00xxxxxxxx0010xxxxxxxx"]
        },
        "VST2_1": {
          "A1": ["111101001x00xxxxxxxx0001xxxxxxxx"],
          "A2": ["111101001x00xxxxxxxx0101xxxxxxxx"],
          "A3": ["111101001x00xxxxxxxx1001xxxxxxxx"]
        },
        "VST2_m": {
          "A1": ["111101000x00xxxxxxxx100xxxxxxxxx"],
          "A2": ["111101000x00xxxxxxxx0011xxxxxxxx"]
        },
        "VST3_1": {
          "A1": ["111101001x00xxxxxxxx0010xxxxxxxx"],
          "A2": ["111101001x00xxxxxxxx0110xxxxxxxx"],
          "A3": ["111101001x00xxxxxxxx1010xxxxxxxx"]
        },
        "VST3_m": {
          "A1": ["111101000x00xxxxxxxx010xxxxxxxxx"]
        },
        "VST4_1": {
          "A1": ["111101001x00xxxxxxxx0011xxxxxxxx"],
          "A2": ["111101001x00xxxxxxxx0111xxxxxxxx"],
          "A3": ["111101001x00xxxxxxxx1011xxxxxxxx"]
        },
        "VST4_m": {
          "A1": ["111101000x00xxxxxxxx000xxxxxxxxx"]
        },
        "VSTM": {
          "A1": ["xxxx110xxxx0xxxxxxxx1011xxxxxxx0", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"],
          "A2": ["xxxx110xxxx0xxxxxxxx1010xxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VSTR": {
          "A1": ["xxxx1101xx00xxxxxxxx10xxxxxxxxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VSUBHN": {
          "A1": ["111100101xxxxxxxxxxx0110x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VSUBL": {
          "A1": ["1111001x1xxxxxxxxxxx0010x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VSUBW": {
          "A1": ["1111001x1xxxxxxxxxxx0011x0x0xxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VSUB_f": {
          "A1": ["111100100x1xxxxxxxxx1101xxx0xxxx"],
          "A2": ["xxxx11100x11xxxxxxxx10xxx1x0xxxx", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "VSUB_i": {
          "A1": ["111100110xxxxxxxxxxx1000xxx0xxxx"]
        },
        "VSWP": {
          "A1": ["111100111x110010xxxx00000xx0xxxx"]
        },
        "VTBL": {
          "A1": ["111100111x11xxxxxxxx10xxxxx0xxxx"]
        },
        "VTRN": {
          "A1": ["111100111x11xx10xxxx00001xx0xxxx"]
        },
        "VTST": {
          "A1": ["111100100xxxxxxxxxxx1000xxx1xxxx"]
        },
        "VUDOT": {
          "A1": ["111111000x10xxxxxxxx1101xxx1xxxx"]
        },
        "VUDOT_s": {
          "A1": ["111111100x10xxxxxxxx1101xxx1xxxx"]
        },
        "VUZP": {
          "A1": ["111100111x11xx10xxxx00010xx0xxxx"]
        },
        "VUZP_VTRN": {
          "A1": ["111100111x11xx10xxxx000010x0xxxx"]
        },
        "VZIP": {
          "A1": ["111100111x11xx10xxxx00011xx0xxxx"]
        },
        "VZIP_VTRN": {
          "A1": ["111100111x11xx10xxxx000010x0xxxx"]
        },
        "WFE": {
          "A1": ["xxxx0011001000001111000000000010", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "WFI": {
          "A1": ["xxxx0011001000001111000000000011", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        },
        "YIELD": {
          "A1": ["xxxx0011001000001111000000000001", "1111xxxxxxxxxxxxxxxxxxxxxxxxxxxx"]
        }
      },
      "T32": {
        "ADC_i": {
          "T1": ["0xxxxxxxxxxxxxxx11110x01010xxxxx"]
        },
        "ADC_r": {
          "T1": ["0100000101xxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx11101011010xxxxx"]
        },
        "ADD_ADR": {
          "T1": ["10100xxxxxxxxxxx"],
          "T3": ["0xxxxxxxxxxxxxxx11110x1000001111"]
        },
        "ADD_SP_i": {
          "T1": ["10101xxxxxxxxxxx"],
          "T2": ["101100000xxxxxxx"],
          "T3": ["0xxxxxxxxxxxxxxx11110x01000x1101"],
          "T4": ["0xxxxxxxxxxxxxxx11110x1000001101"]
        },
        "ADD_SP_r": {
          "T1": ["01000100x1101xxx"],
          "T2": ["010001001xxxx101", "xxxxxxxxx1101xxx"],
          "T3": ["0xxxxxxxxxxxxxxx11101011000x1101"]
        },
        "ADD_i": {
          "T1": ["0001110xxxxxxxxx"],
          "T2": ["00110xxxxxxxxxxx"],
          "T3": ["0xxxxxxxxxxxxxxx11110x01000xxxxx", "xxxxxxxxxxxx1101xxxxxxxxxxxxxxxx"],
          "T4": ["0xxxxxxxxxxxxxxx11110x100000xxxx", "xxxxxxxxxxxx11x1xxxxxxxxxxxxxxxx"]
        },
        "ADD_r": {
          "T1": ["0001100xxxxxxxxx"],
          "T2": ["01000100xxxxxxxx", "xxxxxxxxx1101xxx"],
          "T3": ["0xxxxxxxxxxxxxxx11101011000xxxxx", "xxxxxxxxxxxx1101xxxxxxxxxxxxxxxx"]
        },
        "ADR": {
          "T1": ["10100xxxxxxxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx11110x1010101111"],
          "T3": ["0xxxxxxxxxxxxxxx11110x1000001111"]
        },
        "AESD": {
          "T1": ["xxxx001101x0xxxx111111111x11xx00"]
        },
        "AESE": {
          "T1": ["xxxx001100x0xxxx111111111x11xx00"]
        },
        "AESIMC": {
          "T1": ["xxxx001111x0xxxx111111111x11xx00"]
        },
        "AESMC": {
          "T1": ["xxxx001110x0xxxx111111111x11xx00"]
        },
        "AND_i": {
          "T1": ["0xxxxxxxxxxxxxxx11110x00000xxxxx"]
        },
        "AND_r": {
          "T1": ["0100000000xxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx11101010000xxxxx"]
        },
        "ASRS_MOV_r": {
          "T2": ["00010xxxxxxxxxxx"],
          "T3": ["0xxxxxxxxx10xxxx1110101001011111"]
        },
        "ASRS_MOV_rr": {
          "T1": ["0100000100xxxxxx"],
          "T2": ["1111xxxx0000xxxx111110100101xxxx"]
        },
        "ASR_MOV_r": {
          "T2": ["00010xxxxxxxxxxx"],
          "T3": ["0xxxxxxxxx10xxxx1110101001001111"]
        },
        "ASR_MOV_rr": {
          "T1": ["0100000100xxxxxx"],
          "T2": ["1111xxxx0000xxxx111110100100xxxx"]
        },
        "B": {
          "T1": ["1101xxxxxxxxxxxx", "xxxx111xxxxxxxxx"],
          "T2": ["11100xxxxxxxxxxx"],
          "T3": ["10x0xxxxxxxxxxxx11110xxxxxxxxxxx", "xxxxxx111xxxxxxxxxxxxxxxxxxxxxxx"],
          "T4": ["10x1xxxxxxxxxxxx11110xxxxxxxxxxx"]
        },
        "BFC": {
          "T1": ["0xxxxxxxxx0xxxxx1111001101101111"]
        },
        "BFI": {
          "T1": ["0xxxxxxxxx0xxxxx111100110110xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "BIC_i": {
          "T1": ["0xxxxxxxxxxxxxxx11110x00001xxxxx"]
        },
        "BIC_r": {
          "T1": ["0100001110xxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx11101010001xxxxx"]
        },
        "BKPT": {
          "T1": ["10111110xxxxxxxx"]
        },
        "BLX_r": {
          "T1": ["010001111xxxx000"]
        },
        "BL_i": {
          "T1": ["11x1xxxxxxxxxxxx11110xxxxxxxxxxx"],
          "T2": ["11x0xxxxxxxxxxxx11110xxxxxxxxxxx"]
        },
        "BX": {
          "T1": ["010001110xxxx000"]
        },
        "BXJ": {
          "T1": ["1000111100000000111100111100xxxx"]
        },
        "CBNZ": {
          "T1": ["1011x0x1xxxxxxxx"]
        },
        "CLREX": {
          "T1": ["10001111001011111111001110111111"]
        },
        "CLZ": {
          "T1": ["1111xxxx1000xxxx111110101011xxxx"]
        },
        "CMN_i": {
          "T1": ["0xxx1111xxxxxxxx11110x010001xxxx"]
        },
        "CMN_r": {
          "T1": ["0100001011xxxxxx"],
          "T2": ["0xxx1111xxxxxxxx111010110001xxxx"]
        },
        "CMP_i": {
          "T1": ["00101xxxxxxxxxxx"],
          "T2": ["0xxx1111xxxxxxxx11110x011011xxxx"]
        },
        "CMP_r": {
          "T1": ["0100001010xxxxxx"],
          "T2": ["01000101xxxxxxxx"],
          "T3": ["0xxx1111xxxxxxxx111010111011xxxx"]
        },
        "CPS": {
          "T1": ["10110110011x0xxx"],
          "T2": ["10000xxxxxxxxxxx1111001110101111"]
        },
        "CRC32": {
          "T1": ["1111xxxx10xxxxxx111110101100xxxx"]
        },
        "CRC32C": {
          "T1": ["1111xxxx10xxxxxx111110101101xxxx"]
        },
        "CSDB": {
          "T1": ["10000000000101001111001110101111"]
        },
        "DBG": {
          "T1": ["100000001111xxxx1111001110101111"]
        },
        "DCPS": {
          "T1": ["10000000000000xx1111011110001111"]
        },
        "DMB": {
          "T1": ["100011110101xxxx1111001110111111"]
        },
        "DSB": {
          "T1": ["100011110100xxxx1111001110111111", "xxxxxxxxxxxxxxxxxxxxxxxxxxxx0x00"]
        },
        "EOR_i": {
          "T1": ["0xxxxxxxxxxxxxxx11110x00100xxxxx"]
        },
        "EOR_r": {
          "T1": ["0100000001xxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx11101010100xxxxx"]
        },
        "ERET": {
          "T1": ["10001111000000001111001111011110"]
        },
        "ESB": {
          "T1": ["10000000000100001111001110101111"]
        },
        "FLDMX": {
          "T1": ["xxxx1011xxxxxxx11110110xxxx1xxxx"]
        },
        "FSTMX": {
          "T1": ["xxxx1011xxxxxxx11110110xxxx0xxxx"]
        },
        "HLT": {
          "T1": ["1011101010xxxxxx"]
        },
        "HVC": {
          "T1": ["1000xxxxxxxxxxxx111101111110xxxx"]
        },
        "ISB": {
          "T1": ["100011110110xxxx1111001110111111"]
        },
        "IT": {
          "T1": ["10111111xxxxxxxx", "xxxxxxxxxxxx0000"]
        },
        "LDA": {
          "T1": ["xxxx111110101111111010001101xxxx"]
        },
        "LDAB": {
          "T1": ["xxxx111110001111111010001101xxxx"]
        },
        "LDAEX": {
          "T1": ["xxxx111111101111111010001101xxxx"]
        },
        "LDAEXB": {
          "T1": ["xxxx111111001111111010001101xxxx"]
        },
        "LDAEXD": {
          "T1": ["xxxxxxxx11111111111010001101xxxx"]
        },
        "LDAEXH": {
          "T1": ["xxxx111111011111111010001101xxxx"]
        },
        "LDAH": {
          "T1": ["xxxx111110011111111010001101xxxx"]
        },
        "LDC_i": {
          "T1": ["01011110xxxxxxxx1110110xx0x1xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDC_l": {
          "T1": ["01011110xxxxxxxx1110110xx0x11111"]
        },
        "LDM": {
          "T1": ["11001xxxxxxxxxxx"],
          "T2": ["xxxxxxxxxxxxxxxx1110100010x1xxxx"]
        },
        "LDMDB": {
          "T1": ["xxxxxxxxxxxxxxxx1110100100x1xxxx"]
        },
        "LDRBT": {
          "T1": ["xxxx1110xxxxxxxx111110000001xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRB_i": {
          "T1": ["01111xxxxxxxxxxx"],
          "T2": ["xxxxxxxxxxxxxxxx111110001001xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"],
          "T3": ["xxxx1xxxxxxxxxxx111110000001xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRB_l": {
          "T1": ["xxxxxxxxxxxxxxxx11111000x0011111", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "LDRB_r": {
          "T1": ["0101110xxxxxxxxx"],
          "T2": ["xxxx000000xxxxxx111110000001xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "LDRD_i": {
          "T1": ["xxxxxxxxxxxxxxxx1110100xx1x1xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRD_l": {
          "T1": ["xxxxxxxxxxxxxxxx1110100xx1x11111"]
        },
        "LDREX": {
          "T1": ["xxxx1111xxxxxxxx111010000101xxxx"]
        },
        "LDREXB": {
          "T1": ["xxxx111101001111111010001101xxxx"]
        },
        "LDREXD": {
          "T1": ["xxxxxxxx01111111111010001101xxxx"]
        },
        "LDREXH": {
          "T1": ["xxxx111101011111111010001101xxxx"]
        },
        "LDRHT": {
          "T1": ["xxxx1110xxxxxxxx111110000011xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRH_i": {
          "T1": ["10001xxxxxxxxxxx"],
          "T2": ["xxxxxxxxxxxxxxxx111110001011xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"],
          "T3": ["xxxx1xxxxxxxxxxx111110000011xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRH_l": {
          "T1": ["xxxxxxxxxxxxxxxx11111000x0111111", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "LDRH_r": {
          "T1": ["0101101xxxxxxxxx"],
          "T2": ["xxxx000000xxxxxx111110000011xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "LDRSBT": {
          "T1": ["xxxx1110xxxxxxxx111110010001xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRSB_i": {
          "T1": ["xxxxxxxxxxxxxxxx111110011001xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"],
          "T2": ["xxxx1xxxxxxxxxxx111110010001xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRSB_l": {
          "T1": ["xxxxxxxxxxxxxxxx11111001x0011111", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "LDRSB_r": {
          "T1": ["0101011xxxxxxxxx"],
          "T2": ["xxxx000000xxxxxx111110010001xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "LDRSHT": {
          "T1": ["xxxx1110xxxxxxxx111110010011xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRSH_i": {
          "T1": ["xxxxxxxxxxxxxxxx111110011011xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"],
          "T2": ["xxxx1xxxxxxxxxxx111110010011xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDRSH_l": {
          "T1": ["xxxxxxxxxxxxxxxx11111001x0111111", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "LDRSH_r": {
          "T1": ["0101111xxxxxxxxx"],
          "T2": ["xxxx000000xxxxxx111110010011xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "LDRT": {
          "T1": ["xxxx1110xxxxxxxx111110000101xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDR_i": {
          "T1": ["01101xxxxxxxxxxx"],
          "T2": ["10011xxxxxxxxxxx"],
          "T3": ["xxxxxxxxxxxxxxxx111110001101xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"],
          "T4": ["xxxx1xxxxxxxxxxx111110000101xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LDR_l": {
          "T1": ["01001xxxxxxxxxxx"],
          "T2": ["xxxxxxxxxxxxxxxx11111000x1011111"]
        },
        "LDR_r": {
          "T1": ["0101100xxxxxxxxx"],
          "T2": ["xxxx000000xxxxxx111110000101xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "LSLS_MOV_r": {
          "T2": ["00000xxxxxxxxxxx", "xxxxx00000xxxxxx"],
          "T3": ["0xxxxxxxxx00xxxx1110101001011111"]
        },
        "LSLS_MOV_rr": {
          "T1": ["0100000010xxxxxx"],
          "T2": ["1111xxxx0000xxxx111110100001xxxx"]
        },
        "LSL_MOV_r": {
          "T2": ["00000xxxxxxxxxxx", "xxxxx00000xxxxxx"],
          "T3": ["0xxxxxxxxx00xxxx1110101001001111"]
        },
        "LSL_MOV_rr": {
          "T1": ["0100000010xxxxxx"],
          "T2": ["1111xxxx0000xxxx111110100000xxxx"]
        },
        "LSRS_MOV_r": {
          "T2": ["00001xxxxxxxxxxx"],
          "T3": ["0xxxxxxxxx01xxxx1110101001011111"]
        },
        "LSRS_MOV_rr": {
          "T1": ["0100000011xxxxxx"],
          "T2": ["1111xxxx0000xxxx111110100011xxxx"]
        },
        "LSR_MOV_r": {
          "T2": ["00001xxxxxxxxxxx"],
          "T3": ["0xxxxxxxxx01xxxx1110101001001111"]
        },
        "LSR_MOV_rr": {
          "T1": ["0100000011xxxxxx"],
          "T2": ["1111xxxx0000xxxx111110100010xxxx"]
        },
        "MCR": {
          "T1": ["xxxx111xxxx1xxxx11101110xxx0xxxx"]
        },
        "MCRR": {
          "T1": ["xxxx111xxxxxxxxx111011000100xxxx"]
        },
        "MLA": {
          "T1": ["xxxxxxxx0000xxxx111110110000xxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "MLS": {
          "T1": ["xxxxxxxx0001xxxx111110110000xxxx"]
        },
        "MOVT": {
          "T1": ["0xxxxxxxxxxxxxxx11110x101100xxxx"]
        },
        "MOV_i": {
          "T1": ["00100xxxxxxxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx11110x00010x1111"],
          "T3": ["0xxxxxxxxxxxxxxx11110x100100xxxx"]
        },
        "MOV_r": {
          "T1": ["01000110xxxxxxxx"],
          "T2": ["000xxxxxxxxxxxxx", "xxx11xxxxxxxxxxx"],
          "T3": ["0xxxxxxxxxxxxxxx11101010010x1111"]
        },
        "MOV_rr": {
          "T1": ["0100000xxxxxxxxx"],
          "T2": ["1111xxxx0000xxxx111110100xxxxxxx"]
        },
        "MRC": {
          "T1": ["xxxx111xxxx1xxxx11101110xxx1xxxx"]
        },
        "MRRC": {
          "T1": ["xxxx111xxxxxxxxx111011000101xxxx"]
        },
        "MRS": {
          "T1": ["1000xxxx0000000011110011111x1111"]
        },
        "MRS_br": {
          "T1": ["1000xxxx001x000011110011111xxxxx"]
        },
        "MSR_br": {
          "T1": ["1000xxxx001x000011110011100xxxxx"]
        },
        "MSR_r": {
          "T1": ["1000xxxx0000000011110011100xxxxx"]
        },
        "MUL": {
          "T1": ["0100001101xxxxxx"],
          "T2": ["1111xxxx0000xxxx111110110000xxxx"]
        },
        "MVN_i": {
          "T1": ["0xxxxxxxxxxxxxxx11110x00011x1111"]
        },
        "MVN_r": {
          "T1": ["0100001111xxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx11101010011x1111"]
        },
        "NOP": {
          "T1": ["1011111100000000"],
          "T2": ["10000000000000001111001110101111"]
        },
        "ORN_i": {
          "T1": ["0xxxxxxxxxxxxxxx11110x00011xxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "ORN_r": {
          "T1": ["0xxxxxxxxxxxxxxx11101010011xxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "ORR_i": {
          "T1": ["0xxxxxxxxxxxxxxx11110x00010xxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "ORR_r": {
          "T1": ["0100001100xxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx11101010010xxxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "PKH": {
          "T1": ["0xxxxxxxxxx0xxxx111010101100xxxx"]
        },
        "PLD_i": {
          "T1": ["1111xxxxxxxxxxxx1111100010x1xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"],
          "T2": ["11111100xxxxxxxx1111100000x1xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "PLD_l": {
          "T1": ["1111xxxxxxxxxxxx11111000x0011111"]
        },
        "PLD_r": {
          "T1": ["1111000000xxxxxx1111100000x1xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "PLI_i": {
          "T1": ["1111xxxxxxxxxxxx111110011001xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"],
          "T2": ["11111100xxxxxxxx111110010001xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"],
          "T3": ["1111xxxxxxxxxxxx11111001x0011111"]
        },
        "PLI_r": {
          "T1": ["1111000000xxxxxx111110010001xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "POP": {
          "T1": ["1011110xxxxxxxxx"]
        },
        "POP_LDM": {
          "T2": ["xxxxxxxxxxxxxxxx1110100010111101"]
        },
        "POP_LDR_i": {
          "T4": ["xxxx1011000001001111100001011101"]
        },
        "PSSBB": {
          "T1": ["10001111010001001111001110111111"]
        },
        "PUSH": {
          "T1": ["1011010xxxxxxxxx"]
        },
        "PUSH_STMDB": {
          "T1": ["0xxxxxxxxxxxxxxx1110100100101101"]
        },
        "PUSH_STR_i": {
          "T4": ["xxxx1101000001001111100001001101"]
        },
        "QADD": {
          "T1": ["1111xxxx1000xxxx111110101000xxxx"]
        },
        "QADD16": {
          "T1": ["1111xxxx0001xxxx111110101001xxxx"]
        },
        "QADD8": {
          "T1": ["1111xxxx0001xxxx111110101000xxxx"]
        },
        "QASX": {
          "T1": ["1111xxxx0001xxxx111110101010xxxx"]
        },
        "QDADD": {
          "T1": ["1111xxxx1001xxxx111110101000xxxx"]
        },
        "QDSUB": {
          "T1": ["1111xxxx1011xxxx111110101000xxxx"]
        },
        "QSAX": {
          "T1": ["1111xxxx0001xxxx111110101110xxxx"]
        },
        "QSUB": {
          "T1": ["1111xxxx1010xxxx111110101000xxxx"]
        },
        "QSUB16": {
          "T1": ["1111xxxx0001xxxx111110101101xxxx"]
        },
        "QSUB8": {
          "T1": ["1111xxxx0001xxxx111110101100xxxx"]
        },
        "RBIT": {
          "T1": ["1111xxxx1010xxxx111110101001xxxx"]
        },
        "REV": {
          "T1": ["1011101000xxxxxx"],
          "T2": ["1111xxxx1000xxxx111110101001xxxx"]
        },
        "REV16": {
          "T1": ["1011101001xxxxxx"],
          "T2": ["1111xxxx1001xxxx111110101001xxxx"]
        },
        "REVSH": {
          "T1": ["1011101011xxxxxx"],
          "T2": ["1111xxxx1011xxxx111110101001xxxx"]
        },
        "RFE": {
          "T1": ["11000000000000001110100000x1xxxx"],
          "T2": ["11000000000000001110100110x1xxxx"]
        },
        "RORS_MOV_r": {
          "T3": ["0xxxxxxxxx11xxxx1110101001011111"]
        },
        "RORS_MOV_rr": {
          "T1": ["0100000111xxxxxx"],
          "T2": ["1111xxxx0000xxxx111110100111xxxx"]
        },
        "ROR_MOV_r": {
          "T3": ["0xxxxxxxxx11xxxx1110101001001111"]
        },
        "ROR_MOV_rr": {
          "T1": ["0100000111xxxxxx"],
          "T2": ["1111xxxx0000xxxx111110100110xxxx"]
        },
        "RRXS_MOV_r": {
          "T3": ["0000xxxx0011xxxx1110101001011111"]
        },
        "RRX_MOV_r": {
          "T3": ["0000xxxx0011xxxx1110101001001111"]
        },
        "RSB_i": {
          "T1": ["0100001001xxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx11110x01110xxxxx"]
        },
        "RSB_r": {
          "T1": ["0xxxxxxxxxxxxxxx11101011110xxxxx"]
        },
        "SADD16": {
          "T1": ["1111xxxx0000xxxx111110101001xxxx"]
        },
        "SADD8": {
          "T1": ["1111xxxx0000xxxx111110101000xxxx"]
        },
        "SASX": {
          "T1": ["1111xxxx0000xxxx111110101010xxxx"]
        },
        "SB": {
          "T1": ["10001111011100001111001110111111"]
        },
        "SBC_i": {
          "T1": ["0xxxxxxxxxxxxxxx11110x01011xxxxx"]
        },
        "SBC_r": {
          "T1": ["0100000110xxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx11101011011xxxxx"]
        },
        "SBFX": {
          "T1": ["0xxxxxxxxx0xxxxx111100110100xxxx"]
        },
        "SDIV": {
          "T1": ["1111xxxx1111xxxx111110111001xxxx"]
        },
        "SEL": {
          "T1": ["1111xxxx1000xxxx111110101010xxxx"]
        },
        "SETEND": {
          "T1": ["101101100101x000"]
        },
        "SETPAN": {
          "T1": ["101101100001x000"]
        },
        "SEV": {
          "T1": ["1011111101000000"],
          "T2": ["10000000000001001111001110101111"]
        },
        "SEVL": {
          "T1": ["1011111101010000"],
          "T2": ["10000000000001011111001110101111"]
        },
        "SHA1C": {
          "T1": ["xxxx1100xxx0xxxx111011110x00xxxx"]
        },
        "SHA1H": {
          "T1": ["xxxx001011x0xxxx111111111x11xx01"]
        },
        "SHA1M": {
          "T1": ["xxxx1100xxx0xxxx111011110x10xxxx"]
        },
        "SHA1P": {
          "T1": ["xxxx1100xxx0xxxx111011110x01xxxx"]
        },
        "SHA1SU0": {
          "T1": ["xxxx1100xxx0xxxx111011110x11xxxx"]
        },
        "SHA1SU1": {
          "T1": ["xxxx001110x0xxxx111111111x11xx10"]
        },
        "SHA256H": {
          "T1": ["xxxx1100xxx0xxxx111111110x00xxxx"]
        },
        "SHA256H2": {
          "T1": ["xxxx1100xxx0xxxx111111110x01xxxx"]
        },
        "SHA256SU0": {
          "T1": ["xxxx001111x0xxxx111111111x11xx10"]
        },
        "SHA256SU1": {
          "T1": ["xxxx1100xxx0xxxx111111110x10xxxx"]
        },
        "SHADD16": {
          "T1": ["1111xxxx0010xxxx111110101001xxxx"]
        },
        "SHADD8": {
          "T1": ["1111xxxx0010xxxx111110101000xxxx"]
        },
        "SHASX": {
          "T1": ["1111xxxx0010xxxx111110101010xxxx"]
        },
        "SHSAX": {
          "T1": ["1111xxxx0010xxxx111110101110xxxx"]
        },
        "SHSUB16": {
          "T1": ["1111xxxx0010xxxx111110101101xxxx"]
        },
        "SHSUB8": {
          "T1": ["1111xxxx0010xxxx111110101100xxxx"]
        },
        "SMC": {
          "T1": ["1000000000000000111101111111xxxx"]
        },
        "SMLABB": {
          "T1": ["xxxxxxxx00xxxxxx111110110001xxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "SMLAD": {
          "T1": ["xxxxxxxx000xxxxx111110110010xxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "SMLAL": {
          "T1": ["xxxxxxxx0000xxxx111110111100xxxx"]
        },
        "SMLALBB": {
          "T1": ["xxxxxxxx10xxxxxx111110111100xxxx"]
        },
        "SMLALD": {
          "T1": ["xxxxxxxx110xxxxx111110111100xxxx"]
        },
        "SMLAWB": {
          "T1": ["xxxxxxxx000xxxxx111110110011xxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "SMLSD": {
          "T1": ["xxxxxxxx000xxxxx111110110100xxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "SMLSLD": {
          "T1": ["xxxxxxxx110xxxxx111110111101xxxx"]
        },
        "SMMLA": {
          "T1": ["xxxxxxxx000xxxxx111110110101xxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "SMMLS": {
          "T1": ["xxxxxxxx000xxxxx111110110110xxxx"]
        },
        "SMMUL": {
          "T1": ["1111xxxx000xxxxx111110110101xxxx"]
        },
        "SMUAD": {
          "T1": ["1111xxxx000xxxxx111110110010xxxx"]
        },
        "SMULBB": {
          "T1": ["1111xxxx00xxxxxx111110110001xxxx"]
        },
        "SMULL": {
          "T1": ["xxxxxxxx0000xxxx111110111000xxxx"]
        },
        "SMULWB": {
          "T1": ["1111xxxx000xxxxx111110110011xxxx"]
        },
        "SMUSD": {
          "T1": ["1111xxxx000xxxxx111110110100xxxx"]
        },
        "SRS": {
          "T1": ["11000000000xxxxx1110100000x01101"],
          "T2": ["11000000000xxxxx1110100110x01101"]
        },
        "SSAT": {
          "T1": ["0xxxxxxxxx0xxxxx1111001100x0xxxx"]
        },
        "SSAT16": {
          "T1": ["0000xxxx0000xxxx111100110010xxxx"]
        },
        "SSAX": {
          "T1": ["1111xxxx0000xxxx111110101110xxxx"]
        },
        "SSBB": {
          "T1": ["10001111010000001111001110111111"]
        },
        "SSUB16": {
          "T1": ["1111xxxx0000xxxx111110101101xxxx"]
        },
        "SSUB8": {
          "T1": ["1111xxxx0000xxxx111110101100xxxx"]
        },
        "STC": {
          "T1": ["01011110xxxxxxxx1110110xx0x0xxxx"]
        },
        "STL": {
          "T1": ["xxxx111110101111111010001100xxxx"]
        },
        "STLB": {
          "T1": ["xxxx111110001111111010001100xxxx"]
        },
        "STLEX": {
          "T1": ["xxxx11111110xxxx111010001100xxxx"]
        },
        "STLEXB": {
          "T1": ["xxxx11111100xxxx111010001100xxxx"]
        },
        "STLEXD": {
          "T1": ["xxxxxxxx1111xxxx111010001100xxxx"]
        },
        "STLEXH": {
          "T1": ["xxxx11111101xxxx111010001100xxxx"]
        },
        "STLH": {
          "T1": ["xxxx111110011111111010001100xxxx"]
        },
        "STM": {
          "T1": ["11000xxxxxxxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx1110100010x0xxxx"]
        },
        "STMDB": {
          "T1": ["0xxxxxxxxxxxxxxx1110100100x0xxxx"]
        },
        "STRBT": {
          "T1": ["xxxx1110xxxxxxxx111110000000xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "STRB_i": {
          "T1": ["01110xxxxxxxxxxx"],
          "T2": ["xxxxxxxxxxxxxxxx111110001000xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"],
          "T3": ["xxxx1xxxxxxxxxxx111110000000xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "STRB_r": {
          "T1": ["0101010xxxxxxxxx"],
          "T2": ["xxxx000000xxxxxx111110000000xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "STRD_i": {
          "T1": ["xxxxxxxxxxxxxxxx1110100xx1x0xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "STREX": {
          "T1": ["xxxxxxxxxxxxxxxx111010000100xxxx"]
        },
        "STREXB": {
          "T1": ["xxxx11110100xxxx111010001100xxxx"]
        },
        "STREXD": {
          "T1": ["xxxxxxxx0111xxxx111010001100xxxx"]
        },
        "STREXH": {
          "T1": ["xxxx11110101xxxx111010001100xxxx"]
        },
        "STRHT": {
          "T1": ["xxxx1110xxxxxxxx111110000010xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "STRH_i": {
          "T1": ["10000xxxxxxxxxxx"],
          "T2": ["xxxxxxxxxxxxxxxx111110001010xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"],
          "T3": ["xxxx1xxxxxxxxxxx111110000010xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "STRH_r": {
          "T1": ["0101001xxxxxxxxx"],
          "T2": ["xxxx000000xxxxxx111110000010xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "STRT": {
          "T1": ["xxxx1110xxxxxxxx111110000100xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "STR_i": {
          "T1": ["01100xxxxxxxxxxx"],
          "T2": ["10010xxxxxxxxxxx"],
          "T3": ["xxxxxxxxxxxxxxxx111110001100xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"],
          "T4": ["xxxx1xxxxxxxxxxx111110000100xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "STR_r": {
          "T1": ["0101000xxxxxxxxx"],
          "T2": ["xxxx000000xxxxxx111110000100xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "SUB_ADR": {
          "T2": ["0xxxxxxxxxxxxxxx11110x1010101111"]
        },
        "SUB_SP_i": {
          "T1": ["101100001xxxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx11110x01101x1101"],
          "T3": ["0xxxxxxxxxxxxxxx11110x1010101101"]
        },
        "SUB_SP_r": {
          "T1": ["0xxxxxxxxxxxxxxx11101011101x1101"]
        },
        "SUB_i": {
          "T1": ["0001111xxxxxxxxx"],
          "T2": ["00111xxxxxxxxxxx"],
          "T3": ["0xxxxxxxxxxxxxxx11110x01101xxxxx", "xxxxxxxxxxxx1101xxxxxxxxxxxxxxxx"],
          "T4": ["0xxxxxxxxxxxxxxx11110x101010xxxx", "xxxxxxxxxxxx11x1xxxxxxxxxxxxxxxx"],
          "T5": ["10001111xxxxxxxx1111001111011110", "xxxxxxxxxxxxxxxxxxxxxxxx00000000"]
        },
        "SUB_r": {
          "T1": ["0001101xxxxxxxxx"],
          "T2": ["0xxxxxxxxxxxxxxx11101011101xxxxx", "xxxxxxxxxxxx1101xxxxxxxxxxxxxxxx"]
        },
        "SVC": {
          "T1": ["11011111xxxxxxxx"]
        },
        "SXTAB": {
          "T1": ["1111xxxx10xxxxxx111110100100xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "SXTAB16": {
          "T1": ["1111xxxx10xxxxxx111110100010xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "SXTAH": {
          "T1": ["1111xxxx10xxxxxx111110100000xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "SXTB": {
          "T1": ["1011001001xxxxxx"],
          "T2": ["1111xxxx10xxxxxx1111101001001111"]
        },
        "SXTB16": {
          "T1": ["1111xxxx10xxxxxx1111101000101111"]
        },
        "SXTH": {
          "T1": ["1011001000xxxxxx"],
          "T2": ["1111xxxx10xxxxxx1111101000001111"]
        },
        "TBB": {
          "T1": ["11110000000xxxxx111010001101xxxx"]
        },
        "TEQ_i": {
          "T1": ["0xxx1111xxxxxxxx11110x001001xxxx"]
        },
        "TEQ_r": {
          "T1": ["0xxx1111xxxxxxxx111010101001xxxx"]
        },
        "TSB": {
          "T1": ["10000000000100101111001110101111"]
        },
        "TST_i": {
          "T1": ["0xxx1111xxxxxxxx11110x000001xxxx"]
        },
        "TST_r": {
          "T1": ["0100001000xxxxxx"],
          "T2": ["0xxx1111xxxxxxxx111010100001xxxx"]
        },
        "UADD16": {
          "T1": ["1111xxxx0100xxxx111110101001xxxx"]
        },
        "UADD8": {
          "T1": ["1111xxxx0100xxxx111110101000xxxx"]
        },
        "UASX": {
          "T1": ["1111xxxx0100xxxx111110101010xxxx"]
        },
        "UBFX": {
          "T1": ["0xxxxxxxxx0xxxxx111100111100xxxx"]
        },
        "UDF": {
          "T1": ["11011110xxxxxxxx"],
          "T2": ["1010xxxxxxxxxxxx111101111111xxxx"]
        },
        "UDIV": {
          "T1": ["1111xxxx1111xxxx111110111011xxxx"]
        },
        "UHADD16": {
          "T1": ["1111xxxx0110xxxx111110101001xxxx"]
        },
        "UHADD8": {
          "T1": ["1111xxxx0110xxxx111110101000xxxx"]
        },
        "UHASX": {
          "T1": ["1111xxxx0110xxxx111110101010xxxx"]
        },
        "UHSAX": {
          "T1": ["1111xxxx0110xxxx111110101110xxxx"]
        },
        "UHSUB16": {
          "T1": ["1111xxxx0110xxxx111110101101xxxx"]
        },
        "UHSUB8": {
          "T1": ["1111xxxx0110xxxx111110101100xxxx"]
        },
        "UMAAL": {
          "T1": ["xxxxxxxx0110xxxx111110111110xxxx"]
        },
        "UMLAL": {
          "T1": ["xxxxxxxx0000xxxx111110111110xxxx"]
        },
        "UMULL": {
          "T1": ["xxxxxxxx0000xxxx111110111010xxxx"]
        },
        "UQADD16": {
          "T1": ["1111xxxx0101xxxx111110101001xxxx"]
        },
        "UQADD8": {
          "T1": ["1111xxxx0101xxxx111110101000xxxx"]
        },
        "UQASX": {
          "T1": ["1111xxxx0101xxxx111110101010xxxx"]
        },
        "UQSAX": {
          "T1": ["1111xxxx0101xxxx111110101110xxxx"]
        },
        "UQSUB16": {
          "T1": ["1111xxxx0101xxxx111110101101xxxx"]
        },
        "UQSUB8": {
          "T1": ["1111xxxx0101xxxx111110101100xxxx"]
        },
        "USAD8": {
          "T1": ["1111xxxx0000xxxx111110110111xxxx"]
        },
        "USADA8": {
          "T1": ["xxxxxxxx0000xxxx111110110111xxxx", "xxxxxxxxxxxxxxxx1111xxxxxxxxxxxx"]
        },
        "USAT": {
          "T1": ["0xxxxxxxxx0xxxxx1111001110x0xxxx"]
        },
        "USAT16": {
          "T1": ["0000xxxx0000xxxx111100111010xxxx"]
        },
        "USAX": {
          "T1": ["1111xxxx0100xxxx111110101110xxxx"]
        },
        "USUB16": {
          "T1": ["1111xxxx0100xxxx111110101101xxxx"]
        },
        "USUB8": {
          "T1": ["1111xxxx0100xxxx111110101100xxxx"]
        },
        "UXTAB": {
          "T1": ["1111xxxx10xxxxxx111110100101xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "UXTAB16": {
          "T1": ["1111xxxx10xxxxxx111110100011xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "UXTAH": {
          "T1": ["1111xxxx10xxxxxx111110100001xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "UXTB": {
          "T1": ["1011001011xxxxxx"],
          "T2": ["1111xxxx10xxxxxx1111101001011111"]
        },
        "UXTB16": {
          "T1": ["1111xxxx10xxxxxx1111101000111111"]
        },
        "UXTH": {
          "T1": ["1011001010xxxxxx"],
          "T2": ["1111xxxx10xxxxxx1111101000011111"]
        },
        "VABA": {
          "T1": ["xxxx0111xxx1xxxx111x11110xxxxxxx"]
        },
        "VABAL": {
          "T1": ["xxxx0101x0x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VABDL_i": {
          "T1": ["xxxx0111x0x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VABD_f": {
          "T1": ["xxxx1101xxx0xxxx111111110x1xxxxx"]
        },
        "VABD_i": {
          "T1": ["xxxx0111xxx0xxxx111x11110xxxxxxx"]
        },
        "VABS": {
          "T1": ["xxxx0x110xx0xxxx111111111x11xx01"],
          "T2": ["xxxx10xx11x0xxxx111011101x110000"]
        },
        "VACGE": {
          "T1": ["xxxx1110xxx1xxxx111111110x0xxxxx"]
        },
        "VACGT": {
          "T1": ["xxxx1110xxx1xxxx111111110x1xxxxx"]
        },
        "VACLE_VACGE": {
          "T1": ["xxxx1110xxx1xxxx111111110x0xxxxx"]
        },
        "VACLT_VACGT": {
          "T1": ["xxxx1110xxx1xxxx111111110x1xxxxx"]
        },
        "VADDHN": {
          "T1": ["xxxx0100x0x0xxxx111011111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VADDL": {
          "T1": ["xxxx0000x0x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VADDW": {
          "T1": ["xxxx0001x0x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VADD_f": {
          "T1": ["xxxx1101xxx0xxxx111011110x0xxxxx"],
          "T2": ["xxxx10xxx0x0xxxx111011100x11xxxx"]
        },
        "VADD_i": {
          "T1": ["xxxx1000xxx0xxxx111011110xxxxxxx"]
        },
        "VAND_VBIC_i": {
          "T1": ["xxxx0xx10x11xxxx111x11111x000xxx"],
          "T2": ["xxxx10x10x11xxxx111x11111x000xxx"]
        },
        "VAND_r": {
          "T1": ["xxxx0001xxx1xxxx111011110x00xxxx"]
        },
        "VBIC_i": {
          "T1": ["xxxx0xx10x11xxxx111x11111x000xxx"],
          "T2": ["xxxx10x10x11xxxx111x11111x000xxx"]
        },
        "VBIC_r": {
          "T1": ["xxxx0001xxx1xxxx111011110x01xxxx"]
        },
        "VBIF": {
          "T1": ["xxxx0001xxx1xxxx111111110x11xxxx"]
        },
        "VBIT": {
          "T1": ["xxxx0001xxx1xxxx111111110x10xxxx"]
        },
        "VBSL": {
          "T1": ["xxxx0001xxx1xxxx111111110x01xxxx"]
        },
        "VCADD": {
          "T1": ["xxxx1000xxx0xxxx1111110x1x0xxxxx"]
        },
        "VCEQ_i": {
          "T1": ["xxxx0x010xx0xxxx111111111x11xx01"]
        },
        "VCEQ_r": {
          "T1": ["xxxx1000xxx1xxxx111111110xxxxxxx"],
          "T2": ["xxxx1110xxx0xxxx111011110x0xxxxx"]
        },
        "VCGE_i": {
          "T1": ["xxxx0x001xx0xxxx111111111x11xx01"]
        },
        "VCGE_r": {
          "T1": ["xxxx0011xxx1xxxx111x11110xxxxxxx"],
          "T2": ["xxxx1110xxx0xxxx111111110x0xxxxx"]
        },
        "VCGT_i": {
          "T1": ["xxxx0x000xx0xxxx111111111x11xx01"]
        },
        "VCGT_r": {
          "T1": ["xxxx0011xxx0xxxx111x11110xxxxxxx"],
          "T2": ["xxxx1110xxx0xxxx111111110x1xxxxx"]
        },
        "VCLE_VCGE_r": {
          "T1": ["xxxx0011xxx1xxxx111x11110xxxxxxx"],
          "T2": ["xxxx1110xxx0xxxx111111110x0xxxxx"]
        },
        "VCLE_i": {
          "T1": ["xxxx0x011xx0xxxx111111111x11xx01"]
        },
        "VCLS": {
          "T1": ["xxxx01000xx0xxxx111111111x11xx00"]
        },
        "VCLT_VCGT_r": {
          "T1": ["xxxx0011xxx0xxxx111x11110xxxxxxx"],
          "T2": ["xxxx1110xxx0xxxx111111110x1xxxxx"]
        },
        "VCLT_i": {
          "T1": ["xxxx0x100xx0xxxx111111111x11xx01"]
        },
        "VCLZ": {
          "T1": ["xxxx01001xx0xxxx111111111x11xx00"]
        },
        "VCMLA": {
          "T1": ["xxxx1000xxx0xxxx1111110xxx1xxxxx"]
        },
        "VCMLA_s": {
          "T1": ["xxxx1000xxx0xxxx11111110xxxxxxxx"]
        },
        "VCMP": {
          "T1": ["xxxx10xx01x0xxxx111011101x110100"],
          "T2": ["xxxx10xx01000000111011101x110101"]
        },
        "VCMPE": {
          "T1": ["xxxx10xx11x0xxxx111011101x110100"],
          "T2": ["xxxx10xx11000000111011101x110101"]
        },
        "VCNT": {
          "T1": ["xxxx01010xx0xxxx111111111x11xx00"]
        },
        "VCVTA_asimd": {
          "T1": ["xxxx0000xxx0xxxx111111111x11xx11"]
        },
        "VCVTA_vfp": {
          "T1": ["xxxx10xxx1x0xxxx111111101x111100", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VCVTB": {
          "T1": ["xxxx101x01x0xxxx111011101x11001x"]
        },
        "VCVTM_asimd": {
          "T1": ["xxxx0011xxx0xxxx111111111x11xx11"]
        },
        "VCVTM_vfp": {
          "T1": ["xxxx10xxx1x0xxxx111111101x111111", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VCVTN_asimd": {
          "T1": ["xxxx0001xxx0xxxx111111111x11xx11"]
        },
        "VCVTN_vfp": {
          "T1": ["xxxx10xxx1x0xxxx111111101x111101", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VCVTP_asimd": {
          "T1": ["xxxx0010xxx0xxxx111111111x11xx11"]
        },
        "VCVTP_vfp": {
          "T1": ["xxxx10xxx1x0xxxx111111101x111110", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VCVTR_iv": {
          "T1": ["xxxx10xx01x0xxxx111011101x11110x"]
        },
        "VCVTT": {
          "T1": ["xxxx101x11x0xxxx111011101x11001x"]
        },
        "VCVT_ds": {
          "T1": ["xxxx101x11x0xxxx111011101x110111"]
        },
        "VCVT_hs": {
          "T1": ["xxxx011x00x0xxxx111111111x11xx10"]
        },
        "VCVT_is": {
          "T1": ["xxxx011xxxx0xxxx111111111x11xx11"]
        },
        "VCVT_iv": {
          "T1": ["xxxx10xx11x0xxxx111011101x11110x"]
        },
        "VCVT_vi": {
          "T1": ["xxxx10xxx1x0xxxx111011101x111000"]
        },
        "VCVT_xs": {
          "T1": ["xxxx11xx0xx1xxxx111x11111xxxxxxx"]
        },
        "VCVT_xv": {
          "T1": ["xxxx10xxx1x0xxxx111011101x111x1x"]
        },
        "VDIV": {
          "T1": ["xxxx10xxx0x0xxxx111011101x00xxxx"]
        },
        "VDUP_r": {
          "T1": ["xxxx1011x0x10000111011101xx0xxxx"]
        },
        "VDUP_s": {
          "T1": ["xxxx11000xx0xxxx111111111x11xxxx"]
        },
        "VEOR": {
          "T1": ["xxxx0001xxx1xxxx111111110x00xxxx"]
        },
        "VEXT": {
          "T1": ["xxxxxxxxxxx0xxxx111011111x11xxxx"]
        },
        "VEXT_VEXT": {
          "T1": ["xxxxxxxxxxx0xxxx111011111x11xxxx"]
        },
        "VFMA": {
          "T1": ["xxxx1100xxx1xxxx111011110x0xxxxx"],
          "T2": ["xxxx10xxx0x0xxxx111011101x10xxxx"]
        },
        "VFMAL": {
          "T1": ["xxxx1000xxx1xxxx111111000x10xxxx"]
        },
        "VFMAL_s": {
          "T1": ["xxxx1000xxx1xxxx111111100x00xxxx"]
        },
        "VFMS": {
          "T1": ["xxxx1100xxx1xxxx111011110x1xxxxx"],
          "T2": ["xxxx10xxx1x0xxxx111011101x10xxxx"]
        },
        "VFMSL": {
          "T1": ["xxxx1000xxx1xxxx111111001x10xxxx"]
        },
        "VFMSL_s": {
          "T1": ["xxxx1000xxx1xxxx111111100x01xxxx"]
        },
        "VFNMA": {
          "T1": ["xxxx10xxx1x0xxxx111011101x01xxxx"]
        },
        "VFNMS": {
          "T1": ["xxxx10xxx0x0xxxx111011101x01xxxx"]
        },
        "VHADD": {
          "T1": ["xxxx0000xxx0xxxx111x11110xxxxxxx"]
        },
        "VHSUB": {
          "T1": ["xxxx0010xxx0xxxx111x11110xxxxxxx"]
        },
        "VINS": {
          "T1": ["xxxx101011x0xxxx111111101x110000"]
        },
        "VJCVT": {
          "T1": ["xxxx101111x0xxxx111011101x111001"]
        },
        "VLD1_1": {
          "T1": ["xxxx0000xxxxxxxx111110011x10xxxx"],
          "T2": ["xxxx0100xxxxxxxx111110011x10xxxx"],
          "T3": ["xxxx1000xxxxxxxx111110011x10xxxx"]
        },
        "VLD1_a": {
          "T1": ["xxxx1100xxxxxxxx111110011x10xxxx"]
        },
        "VLD1_m": {
          "T1": ["xxxx0111xxxxxxxx111110010x10xxxx"],
          "T2": ["xxxx1010xxxxxxxx111110010x10xxxx"],
          "T3": ["xxxx0110xxxxxxxx111110010x10xxxx"],
          "T4": ["xxxx0010xxxxxxxx111110010x10xxxx"]
        },
        "VLD2_1": {
          "T1": ["xxxx0001xxxxxxxx111110011x10xxxx"],
          "T2": ["xxxx0101xxxxxxxx111110011x10xxxx"],
          "T3": ["xxxx1001xxxxxxxx111110011x10xxxx"]
        },
        "VLD2_a": {
          "T1": ["xxxx1101xxxxxxxx111110011x10xxxx"]
        },
        "VLD2_m": {
          "T1": ["xxxx100xxxxxxxxx111110010x10xxxx"],
          "T2": ["xxxx0011xxxxxxxx111110010x10xxxx"]
        },
        "VLD3_1": {
          "T1": ["xxxx0010xxxxxxxx111110011x10xxxx"],
          "T2": ["xxxx0110xxxxxxxx111110011x10xxxx"],
          "T3": ["xxxx1010xxxxxxxx111110011x10xxxx"]
        },
        "VLD3_a": {
          "T1": ["xxxx1110xxx0xxxx111110011x10xxxx"]
        },
        "VLD3_m": {
          "T1": ["xxxx010xxxxxxxxx111110010x10xxxx"]
        },
        "VLD4_1": {
          "T1": ["xxxx0011xxxxxxxx111110011x10xxxx"],
          "T2": ["xxxx0111xxxxxxxx111110011x10xxxx"],
          "T3": ["xxxx1011xxxxxxxx111110011x10xxxx"]
        },
        "VLD4_a": {
          "T1": ["xxxx1111xxxxxxxx111110011x10xxxx"]
        },
        "VLD4_m": {
          "T1": ["xxxx000xxxxxxxxx111110010x10xxxx"]
        },
        "VLDM": {
          "T1": ["xxxx1011xxxxxxx01110110xxxx1xxxx"],
          "T2": ["xxxx1010xxxxxxxx1110110xxxx1xxxx"]
        },
        "VLDR_i": {
          "T1": ["xxxx10xxxxxxxxxx11101101xx01xxxx", "xxxxxxxxxxxx1111xxxxxxxxxxxxxxxx"]
        },
        "VLDR_l": {
          "T1": ["xxxx10xxxxxxxxxx11101101xx011111"]
        },
        "VMAXNM": {
          "T1": ["xxxx1111xxx1xxxx111111110x0xxxxx"],
          "T2": ["xxxx10xxx0x0xxxx111111101x00xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VMAX_f": {
          "T1": ["xxxx1111xxx0xxxx111011110x0xxxxx"]
        },
        "VMAX_i": {
          "T1": ["xxxx0110xxx0xxxx111x11110xxxxxxx"]
        },
        "VMINNM": {
          "T1": ["xxxx1111xxx1xxxx111111110x1xxxxx"],
          "T2": ["xxxx10xxx1x0xxxx111111101x00xxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VMIN_f": {
          "T1": ["xxxx1111xxx0xxxx111011110x1xxxxx"]
        },
        "VMIN_i": {
          "T1": ["xxxx0110xxx1xxxx111x11110xxxxxxx"]
        },
        "VMLAL_i": {
          "T1": ["xxxx1000x0x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMLAL_s": {
          "T1": ["xxxx0010x1x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMLA_f": {
          "T1": ["xxxx1101xxx1xxxx111011110x0xxxxx"],
          "T2": ["xxxx10xxx0x0xxxx111011100x00xxxx"]
        },
        "VMLA_i": {
          "T1": ["xxxx1001xxx0xxxx111011110xxxxxxx"]
        },
        "VMLA_s": {
          "T1": ["xxxx000xx1x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMLSL_i": {
          "T1": ["xxxx1010x0x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMLSL_s": {
          "T1": ["xxxx0110x1x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMLS_f": {
          "T1": ["xxxx1101xxx1xxxx111011110x1xxxxx"],
          "T2": ["xxxx10xxx1x0xxxx111011100x00xxxx"]
        },
        "VMLS_i": {
          "T1": ["xxxx1001xxx0xxxx111111110xxxxxxx"]
        },
        "VMLS_s": {
          "T1": ["xxxx010xx1x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMOVL": {
          "T1": ["xxxx101000x1xxxx111x11111xxxx000", "xxxxxxxxxx000xxxxxxxxxxxxxxxxxxx"]
        },
        "VMOVN": {
          "T1": ["xxxx001000x0xxxx111111111x11xx10"]
        },
        "VMOVX": {
          "T1": ["xxxx101001x0xxxx111111101x110000"]
        },
        "VMOV_VORR_r": {
          "T1": ["xxxx0001xxx1xxxx111011110x10xxxx"]
        },
        "VMOV_d": {
          "T1": ["xxxx101100x1xxxx11101100010xxxxx"]
        },
        "VMOV_h": {
          "T1": ["xxxx1001x001000011101110000xxxxx"]
        },
        "VMOV_i": {
          "T1": ["xxxx0xx00x01xxxx111x11111x000xxx"],
          "T2": ["xxxx10xx0000xxxx111011101x11xxxx"],
          "T3": ["xxxx10x00x01xxxx111x11111x000xxx"],
          "T4": ["xxxx11xx0x01xxxx111x11111x000xxx"],
          "T5": ["xxxx11100x11xxxx111x11111x000xxx"]
        },
        "VMOV_r": {
          "T2": ["xxxx101x01x0xxxx111011101x110000"]
        },
        "VMOV_rs": {
          "T1": ["xxxx1011xxx10000111011100xx0xxxx"]
        },
        "VMOV_s": {
          "T1": ["xxxx1010x001000011101110000xxxxx"]
        },
        "VMOV_sr": {
          "T1": ["xxxx1011xxx1000011101110xxx1xxxx"]
        },
        "VMOV_ss": {
          "T1": ["xxxx101000x1xxxx11101100010xxxxx"]
        },
        "VMRS": {
          "T1": ["xxxx101000010000111011101111xxxx"]
        },
        "VMSR": {
          "T1": ["xxxx101000010000111011101110xxxx"]
        },
        "VMULL_i": {
          "T1": ["xxxx11x0x0x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMULL_s": {
          "T1": ["xxxx1010x1x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMUL_f": {
          "T1": ["xxxx1101xxx1xxxx111111110x0xxxxx"],
          "T2": ["xxxx10xxx0x0xxxx111011100x10xxxx"]
        },
        "VMUL_i": {
          "T1": ["xxxx1001xxx1xxxx111x11110xxxxxxx"]
        },
        "VMUL_s": {
          "T1": ["xxxx100xx1x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VMVN_i": {
          "T1": ["xxxx0xx00x11xxxx111x11111x000xxx"],
          "T2": ["xxxx10x00x11xxxx111x11111x000xxx"],
          "T3": ["xxxx110x0x11xxxx111x11111x000xxx"]
        },
        "VMVN_r": {
          "T1": ["xxxx01011xx0xxxx111111111x11xx00"]
        },
        "VNEG": {
          "T1": ["xxxx0x111xx0xxxx111111111x11xx01"],
          "T2": ["xxxx10xx01x0xxxx111011101x110001"]
        },
        "VNMLA": {
          "T1": ["xxxx10xxx1x0xxxx111011100x01xxxx"]
        },
        "VNMLS": {
          "T1": ["xxxx10xxx0x0xxxx111011100x01xxxx"]
        },
        "VNMUL": {
          "T1": ["xxxx10xxx1x0xxxx111011100x10xxxx"]
        },
        "VORN_VORR_i": {
          "T1": ["xxxx0xx10x01xxxx111x11111x000xxx"],
          "T2": ["xxxx10x10x01xxxx111x11111x000xxx"]
        },
        "VORN_r": {
          "T1": ["xxxx0001xxx1xxxx111011110x11xxxx"]
        },
        "VORR_i": {
          "T1": ["xxxx0xx10x01xxxx111x11111x000xxx"],
          "T2": ["xxxx10x10x01xxxx111x11111x000xxx"]
        },
        "VORR_r": {
          "T1": ["xxxx0001xxx1xxxx111011110x10xxxx"]
        },
        "VPADAL": {
          "T1": ["xxxx0110xxx0xxxx111111111x11xx00"]
        },
        "VPADDL": {
          "T1": ["xxxx0010xxx0xxxx111111111x11xx00"]
        },
        "VPADD_f": {
          "T1": ["xxxx1101xxx0xxxx111111110x0xxxxx"]
        },
        "VPADD_i": {
          "T1": ["xxxx1011xxx1xxxx111011110xxxxxxx"]
        },
        "VPMAX_f": {
          "T1": ["xxxx1111x0x0xxxx111111110x0xxxxx"]
        },
        "VPMAX_i": {
          "T1": ["xxxx1010x0x0xxxx111x11110xxxxxxx"]
        },
        "VPMIN_f": {
          "T1": ["xxxx1111x0x0xxxx111111110x1xxxxx"]
        },
        "VPMIN_i": {
          "T1": ["xxxx1010x0x1xxxx111x11110xxxxxxx"]
        },
        "VPOP_VLDM": {
          "T1": ["xxxx1011xxxxxxx0111011001x111101"],
          "T2": ["xxxx1010xxxxxxxx111011001x111101"]
        },
        "VPUSH_VSTM": {
          "T1": ["xxxx1011xxxxxxx0111011010x101101"],
          "T2": ["xxxx1010xxxxxxxx111011010x101101"]
        },
        "VQABS": {
          "T1": ["xxxx01110xx0xxxx111111111x11xx00"]
        },
        "VQADD": {
          "T1": ["xxxx0000xxx1xxxx111x11110xxxxxxx"]
        },
        "VQDMLAL": {
          "T1": ["xxxx1001x0x0xxxx111011111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"],
          "T2": ["xxxx0011x1x0xxxx111011111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQDMLSL": {
          "T1": ["xxxx1011x0x0xxxx111011111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"],
          "T2": ["xxxx0111x1x0xxxx111011111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQDMULH": {
          "T1": ["xxxx1011xxx0xxxx111011110xxxxxxx"],
          "T2": ["xxxx1100x1x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQDMULL": {
          "T1": ["xxxx1101x0x0xxxx111011111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"],
          "T2": ["xxxx1011x1x0xxxx111011111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQMOVN": {
          "T1": ["xxxx0010xxx0xxxx111111111x11xx10"]
        },
        "VQNEG": {
          "T1": ["xxxx01111xx0xxxx111111111x11xx00"]
        },
        "VQRDMLAH": {
          "T1": ["xxxx1011xxx1xxxx111111110xxxxxxx"],
          "T2": ["xxxx1110x1x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQRDMLSH": {
          "T1": ["xxxx1100xxx1xxxx111111110xxxxxxx"],
          "T2": ["xxxx1111x1x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQRDMULH": {
          "T1": ["xxxx1011xxx0xxxx111111110xxxxxxx"],
          "T2": ["xxxx1101x1x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VQRSHL": {
          "T1": ["xxxx0101xxx1xxxx111x11110xxxxxxx"]
        },
        "VQRSHRN": {
          "T1": ["xxxx100x01x1xxxx111x11111xxxxxxx"]
        },
        "VQRSHRN_VQMOVN": {
          "T1": ["xxxx00101xx0xxxx111111111x11xx10"]
        },
        "VQRSHRUN_VQMOVN": {
          "T1": ["xxxx001001x0xxxx111111111x11xx10"]
        },
        "VQSHL_i": {
          "T1": ["xxxx011xxxx1xxxx111x11111xxxxxxx"]
        },
        "VQSHL_r": {
          "T1": ["xxxx0100xxx1xxxx111x11110xxxxxxx"]
        },
        "VQSHRN": {
          "T1": ["xxxx100x00x1xxxx111x11111xxxxxxx"]
        },
        "VQSHRN_VQMOVN": {
          "T1": ["xxxx00101xx0xxxx111111111x11xx10"]
        },
        "VQSHRUN_VQMOVN": {
          "T1": ["xxxx001001x0xxxx111111111x11xx10"]
        },
        "VQSUB": {
          "T1": ["xxxx0010xxx1xxxx111x11110xxxxxxx"]
        },
        "VRADDHN": {
          "T1": ["xxxx0100x0x0xxxx111111111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VRECPE": {
          "T1": ["xxxx010x0xx0xxxx111111111x11xx11"]
        },
        "VRECPS": {
          "T1": ["xxxx1111xxx1xxxx111011110x0xxxxx"]
        },
        "VREV16": {
          "T1": ["xxxx00010xx0xxxx111111111x11xx00"]
        },
        "VREV32": {
          "T1": ["xxxx00001xx0xxxx111111111x11xx00"]
        },
        "VREV64": {
          "T1": ["xxxx00000xx0xxxx111111111x11xx00"]
        },
        "VRHADD": {
          "T1": ["xxxx0001xxx0xxxx111x11110xxxxxxx"]
        },
        "VRINTA_asimd": {
          "T1": ["xxxx01010xx0xxxx111111111x11xx10"]
        },
        "VRINTA_vfp": {
          "T1": ["xxxx10xx01x0xxxx111111101x111000", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VRINTM_asimd": {
          "T1": ["xxxx01101xx0xxxx111111111x11xx10"]
        },
        "VRINTM_vfp": {
          "T1": ["xxxx10xx01x0xxxx111111101x111011", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VRINTN_asimd": {
          "T1": ["xxxx01000xx0xxxx111111111x11xx10"]
        },
        "VRINTN_vfp": {
          "T1": ["xxxx10xx01x0xxxx111111101x111001", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VRINTP_asimd": {
          "T1": ["xxxx01111xx0xxxx111111111x11xx10"]
        },
        "VRINTP_vfp": {
          "T1": ["xxxx10xx01x0xxxx111111101x111010", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VRINTR_vfp": {
          "T1": ["xxxx10xx01x0xxxx111011101x110110"]
        },
        "VRINTX_asimd": {
          "T1": ["xxxx01001xx0xxxx111111111x11xx10"]
        },
        "VRINTX_vfp": {
          "T1": ["xxxx10xx01x0xxxx111011101x110111"]
        },
        "VRINTZ_asimd": {
          "T1": ["xxxx01011xx0xxxx111111111x11xx10"]
        },
        "VRINTZ_vfp": {
          "T1": ["xxxx10xx11x0xxxx111011101x110110"]
        },
        "VRSHL": {
          "T1": ["xxxx0101xxx0xxxx111x11110xxxxxxx"]
        },
        "VRSHR": {
          "T1": ["xxxx0010xxx1xxxx111x11111xxxxxxx"]
        },
        "VRSHRN": {
          "T1": ["xxxx100001x1xxxx111011111xxxxxxx"]
        },
        "VRSHRN_VMOVN": {
          "T1": ["xxxx001000x0xxxx111111111x11xx10"]
        },
        "VRSHR_VORR_r": {
          "T1": ["xxxx0001xxx1xxxx111011110x10xxxx"]
        },
        "VRSQRTE": {
          "T1": ["xxxx010x1xx0xxxx111111111x11xx11"]
        },
        "VRSQRTS": {
          "T1": ["xxxx1111xxx1xxxx111011110x1xxxxx"]
        },
        "VRSRA": {
          "T1": ["xxxx0011xxx1xxxx111x11111xxxxxxx"]
        },
        "VRSUBHN": {
          "T1": ["xxxx0110x0x0xxxx111111111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VSDOT": {
          "T1": ["xxxx1101xxx0xxxx111111000x10xxxx"]
        },
        "VSDOT_s": {
          "T1": ["xxxx1101xxx0xxxx111111100x10xxxx"]
        },
        "VSEL": {
          "T1": ["xxxx10xxx0x0xxxx111111100xxxxxxx", "xxxxxxxxxxxxxxxxxxxxxx00xxxxxxxx"]
        },
        "VSHLL": {
          "T1": ["xxxx101000x1xxxx111x11111xxxxxxx"],
          "T2": ["xxxx001100x0xxxx111111111x11xx10"]
        },
        "VSHL_i": {
          "T1": ["xxxx0101xxx1xxxx111011111xxxxxxx"]
        },
        "VSHL_r": {
          "T1": ["xxxx0100xxx0xxxx111x11110xxxxxxx"]
        },
        "VSHR": {
          "T1": ["xxxx0000xxx1xxxx111x11111xxxxxxx"]
        },
        "VSHRN": {
          "T1": ["xxxx100000x1xxxx111011111xxxxxxx"]
        },
        "VSHRN_VMOVN": {
          "T1": ["xxxx001000x0xxxx111111111x11xx10"]
        },
        "VSHR_VORR_r": {
          "T1": ["xxxx0001xxx1xxxx111011110x10xxxx"]
        },
        "VSLI": {
          "T1": ["xxxx0101xxx1xxxx111111111xxxxxxx"]
        },
        "VSQRT": {
          "T1": ["xxxx10xx11x0xxxx111011101x110001"]
        },
        "VSRA": {
          "T1": ["xxxx0001xxx1xxxx111x11111xxxxxxx"]
        },
        "VSRI": {
          "T1": ["xxxx0100xxx1xxxx111111111xxxxxxx"]
        },
        "VST1_1": {
          "T1": ["xxxx0000xxxxxxxx111110011x00xxxx"],
          "T2": ["xxxx0100xxxxxxxx111110011x00xxxx"],
          "T3": ["xxxx1000xxxxxxxx111110011x00xxxx"]
        },
        "VST1_m": {
          "T1": ["xxxx0111xxxxxxxx111110010x00xxxx"],
          "T2": ["xxxx1010xxxxxxxx111110010x00xxxx"],
          "T3": ["xxxx0110xxxxxxxx111110010x00xxxx"],
          "T4": ["xxxx0010xxxxxxxx111110010x00xxxx"]
        },
        "VST2_1": {
          "T1": ["xxxx0001xxxxxxxx111110011x00xxxx"],
          "T2": ["xxxx0101xxxxxxxx111110011x00xxxx"],
          "T3": ["xxxx1001xxxxxxxx111110011x00xxxx"]
        },
        "VST2_m": {
          "T1": ["xxxx100xxxxxxxxx111110010x00xxxx"],
          "T2": ["xxxx0011xxxxxxxx111110010x00xxxx"]
        },
        "VST3_1": {
          "T1": ["xxxx0010xxxxxxxx111110011x00xxxx"],
          "T2": ["xxxx0110xxxxxxxx111110011x00xxxx"],
          "T3": ["xxxx1010xxxxxxxx111110011x00xxxx"]
        },
        "VST3_m": {
          "T1": ["xxxx010xxxxxxxxx111110010x00xxxx"]
        },
        "VST4_1": {
          "T1": ["xxxx0011xxxxxxxx111110011x00xxxx"],
          "T2": ["xxxx0111xxxxxxxx111110011x00xxxx"],
          "T3": ["xxxx1011xxxxxxxx111110011x00xxxx"]
        },
        "VST4_m": {
          "T1": ["xxxx000xxxxxxxxx111110010x00xxxx"]
        },
        "VSTM": {
          "T1": ["xxxx1011xxxxxxx01110110xxxx0xxxx"],
          "T2": ["xxxx1010xxxxxxxx1110110xxxx0xxxx"]
        },
        "VSTR": {
          "T1": ["xxxx10xxxxxxxxxx11101101xx00xxxx"]
        },
        "VSUBHN": {
          "T1": ["xxxx0110x0x0xxxx111011111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VSUBL": {
          "T1": ["xxxx0010x0x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VSUBW": {
          "T1": ["xxxx0011x0x0xxxx111x11111xxxxxxx", "xxxxxxxxxx11xxxxxxxxxxxxxxxxxxxx"]
        },
        "VSUB_f": {
          "T1": ["xxxx1101xxx0xxxx111011110x1xxxxx"],
          "T2": ["xxxx10xxx1x0xxxx111011100x11xxxx"]
        },
        "VSUB_i": {
          "T1": ["xxxx1000xxx0xxxx111111110xxxxxxx"]
        },
        "VSWP": {
          "T1": ["xxxx00000xx0xxxx111111111x110010"]
        },
        "VTBL": {
          "T1": ["xxxx10xxxxx0xxxx111111111x11xxxx"]
        },
        "VTRN": {
          "T1": ["xxxx00001xx0xxxx111111111x11xx10"]
        },
        "VTST": {
          "T1": ["xxxx1000xxx1xxxx111011110xxxxxxx"]
        },
        "VUDOT": {
          "T1": ["xxxx1101xxx1xxxx111111000x10xxxx"]
        },
        "VUDOT_s": {
          "T1": ["xxxx1101xxx1xxxx111111100x10xxxx"]
        },
        "VUZP": {
          "T1": ["xxxx00010xx0xxxx111111111x11xx10"]
        },
        "VUZP_VTRN": {
          "T1": ["xxxx000010x0xxxx111111111x11xx10"]
        },
        "VZIP": {
          "T1": ["xxxx00011xx0xxxx111111111x11xx10"]
        },
        "VZIP_VTRN": {
          "T1": ["xxxx000010x0xxxx111111111x11xx10"]
        },
        "WFE": {
          "T1": ["1011111100100000"],
          "T2": ["10000000000000101111001110101111"]
        },
        "WFI": {
          "T1": ["1011111100110000"],
          "T2": ["10000000000000111111001110101111"]
        },
        "YIELD": {
          "T1": ["1011111100010000"],
          "T2": ["10000000000000011111001110101111"]
        }
      }
    },
    "simd_fp": {
      "AESD": {
        "authored": "AES single round decryption.",
        "heading": "AESD",
        "templates": {
          "A1": [
            "AESD.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "AESD.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "AESE": {
        "authored": "AES single round encryption.",
        "heading": "AESE",
        "templates": {
          "A1": [
            "AESE.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "AESE.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "AESIMC": {
        "authored": "AES inverse mix columns.",
        "heading": "AESIMC",
        "templates": {
          "A1": [
            "AESIMC.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "AESIMC.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "AESMC": {
        "authored": "AES mix columns.",
        "heading": "AESMC",
        "templates": {
          "A1": [
            "AESMC.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "AESMC.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "FLDMX": {
        "authored": "FLDMDBX is the Decrement Before variant of this instruction, and FLDMIAX is the\nIncrement After variant. FLDM*X loads multiple SIMD&FP registers from\nconsecutive locations in the Advanced SIMD and floating-point register file\nusing an address from a general-purpose register.\n\nARM deprecates use of FLDMDBX and FLDMIAX, except for disassembly purposes, and\nreassembly of disassembled code.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "FLDM*X (FLDMDBX, FLDMIAX)",
        "templates": {
          "A1": [
            "FLDMDBX{<c>}{<q>} <Rn>!, <dreglist>",
            "FLDMIAX{<c>}{<q>} <Rn>{!}, <dreglist>"
          ],
          "T1": [
            "FLDMDBX{<c>}{<q>} <Rn>!, <dreglist>",
            "FLDMIAX{<c>}{<q>} <Rn>{!}, <dreglist>"
          ]
        }
      },
      "FSTMX": {
        "authored": "FSTMX stores multiple SIMD&FP registers from the Advanced SIMD and floating-\npoint register file to consecutive locations in using an address from a general-\npurpose register.\n\nARM deprecates use of FLDMDBX and FLDMIAX, except for disassembly purposes, and\nreassembly of disassembled code.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "FSTMDBX, FSTMIAX",
        "templates": {
          "A1": [
            "FSTMDBX{<c>}{<q>} <Rn>!, <dreglist>",
            "FSTMIAX{<c>}{<q>} <Rn>{!}, <dreglist>"
          ],
          "T1": [
            "FSTMDBX{<c>}{<q>} <Rn>!, <dreglist>",
            "FSTMIAX{<c>}{<q>} <Rn>{!}, <dreglist>"
          ]
        }
      },
      "SHA1C": {
        "authored": "SHA1 hash update (choose).",
        "heading": "SHA1C",
        "templates": {
          "A1": [
            "SHA1C.32 <Qd>, <Qn>, <Qm>"
          ],
          "T1": [
            "SHA1C.32 <Qd>, <Qn>, <Qm>"
          ]
        }
      },
      "SHA1H": {
        "authored": "SHA1 fixed rotate.",
        "heading": "SHA1H",
        "templates": {
          "A1": [
            "SHA1H.32 <Qd>, <Qm>"
          ],
          "T1": [
            "SHA1H.32 <Qd>, <Qm>"
          ]
        }
      },
      "SHA1M": {
        "authored": "SHA1 hash update (majority).",
        "heading": "SHA1M",
        "templates": {
          "A1": [
            "SHA1M.32 <Qd>, <Qn>, <Qm>"
          ],
          "T1": [
            "SHA1M.32 <Qd>, <Qn>, <Qm>"
          ]
        }
      },
      "SHA1P": {
        "authored": "SHA1 hash update (parity).",
        "heading": "SHA1P",
        "templates": {
          "A1": [
            "SHA1P.32 <Qd>, <Qn>, <Qm>"
          ],
          "T1": [
            "SHA1P.32 <Qd>, <Qn>, <Qm>"
          ]
        }
      },
      "SHA1SU0": {
        "authored": "SHA1 schedule update 0.",
        "heading": "SHA1SU0",
        "templates": {
          "A1": [
            "SHA1SU0.32 <Qd>, <Qn>, <Qm>"
          ],
          "T1": [
            "SHA1SU0.32 <Qd>, <Qn>, <Qm>"
          ]
        }
      },
      "SHA1SU1": {
        "authored": "SHA1 schedule update 1.",
        "heading": "SHA1SU1",
        "templates": {
          "A1": [
            "SHA1SU1.32 <Qd>, <Qm>"
          ],
          "T1": [
            "SHA1SU1.32 <Qd>, <Qm>"
          ]
        }
      },
      "SHA256H": {
        "authored": "SHA256 hash update part 1.",
        "heading": "SHA256H",
        "templates": {
          "A1": [
            "SHA256H.32 <Qd>, <Qn>, <Qm>"
          ],
          "T1": [
            "SHA256H.32 <Qd>, <Qn>, <Qm>"
          ]
        }
      },
      "SHA256H2": {
        "authored": "SHA256 hash update part 2.",
        "heading": "SHA256H2",
        "templates": {
          "A1": [
            "SHA256H2.32 <Qd>, <Qn>, <Qm>"
          ],
          "T1": [
            "SHA256H2.32 <Qd>, <Qn>, <Qm>"
          ]
        }
      },
      "SHA256SU0": {
        "authored": "SHA256 schedule update 0.",
        "heading": "SHA256SU0",
        "templates": {
          "A1": [
            "SHA256SU0.32 <Qd>, <Qm>"
          ],
          "T1": [
            "SHA256SU0.32 <Qd>, <Qm>"
          ]
        }
      },
      "SHA256SU1": {
        "authored": "SHA256 schedule update 1.",
        "heading": "SHA256SU1",
        "templates": {
          "A1": [
            "SHA256SU1.32 <Qd>, <Qn>, <Qm>"
          ],
          "T1": [
            "SHA256SU1.32 <Qd>, <Qn>, <Qm>"
          ]
        }
      },
      "VABA": {
        "authored": "Vector Absolute Difference and Accumulate subtracts the elements of one vector\nfrom the corresponding elements of another vector, and accumulates the absolute\nvalues of the results into the elements of the destination vector.\n\nOperand and result elements are all integers of the same length.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VABA",
        "templates": {
          "A1": [
            "VABA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VABA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "T1": [
            "VABA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VABA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ]
        }
      },
      "VABAL": {
        "authored": "Vector Absolute Difference and Accumulate Long subtracts the elements of one\nvector from the corresponding elements of another vector, and accumulates the\nabsolute values of the results into the elements of the destination vector.\n\nOperand elements are all integers of the same length, and the result elements\nare double the length of the operands.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VABAL",
        "templates": {
          "A1": [
            "VABAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VABAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ]
        }
      },
      "VABDL_i": {
        "authored": "Vector Absolute Difference Long (integer) subtracts the elements of one vector\nfrom the corresponding elements of another vector, and places the absolute\nvalues of the results in the elements of the destination vector.\n\nOperand elements are all integers of the same length, and the result elements\nare double the length of the operands.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VABDL (integer)",
        "templates": {
          "A1": [
            "VABDL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VABDL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ]
        }
      },
      "VABD_f": {
        "authored": "Vector Absolute Difference (floating-point) subtracts the elements of one vector\nfrom the corresponding elements of another vector, and places the absolute\nvalues of the results in the elements of the destination vector.\n\nOperand and result elements are floating-point numbers of the same size.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VABD (floating-point)",
        "templates": {
          "A1": [
            "VABD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VABD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VABD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VABD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VABD_i": {
        "authored": "Vector Absolute Difference (integer) subtracts the elements of one vector from\nthe corresponding elements of another vector, and places the absolute values of\nthe results in the elements of the destination vector.\n\nOperand and result elements are all integers of the same length.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VABD (integer)",
        "templates": {
          "A1": [
            "VABD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VABD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VABD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VABD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VABS": {
        "authored": "Vector Absolute takes the absolute value of each element in a vector, and places\nthe results in a second vector. The floating-point version only clears the sign\nbit.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VABS",
        "templates": {
          "A1": [
            "VABS{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VABS{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "A2": [
            "VABS{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VABS{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VABS{<c>}{<q>}.F64 <Dd>, <Dm>"
          ],
          "T1": [
            "VABS{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VABS{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T2": [
            "VABS{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VABS{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VABS{<c>}{<q>}.F64 <Dd>, <Dm>"
          ]
        }
      },
      "VACGE": {
        "authored": "Vector Absolute Compare Greater Than or Equal takes the absolute value of each\nelement in a vector, and compares it with the absolute value of the\ncorresponding element of a second vector. If the first is greater than or equal\nto the second, the corresponding element in the destination vector is set to all\nones. Otherwise, it is set to all zeros.\n\nThe operands and result can be quadword or doubleword vectors.  They must all be\nthe same size.\n\nThe operand vector elements are floating-point numbers. The result vector\nelements are the same size as the operand vector elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VACGE",
        "templates": {
          "A1": [
            "VACGE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VACGE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VACGE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VACGE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VACGT": {
        "authored": "Vector Absolute Compare Greater Than takes the absolute value of each element in\na vector, and compares it with the absolute value of the corresponding element\nof a second vector. If the first is greater than the second, the corresponding\nelement in the destination vector is set to all ones. Otherwise, it is set to\nall zeros.\n\nThe operands and result can be quadword or doubleword vectors.  They must all be\nthe same size.\n\nThe operand vector elements are floating-point numbers. The result vector\nelements are the same size as the operand vector elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VACGT",
        "templates": {
          "A1": [
            "VACGT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VACGT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VACGT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VACGT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VACLE_VACGE": {
        "authored": " takes the absolute value of each element in a vector, and compares it with the\nabsolute value of the corresponding element of a second vector. If the first is\nless than or equal to the second, the corresponding element in the destination\nvector is set to all ones. Otherwise, it is set to all zeros",
        "heading": "VACLE",
        "templates": {
          "A1": [
            "VACLE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VACLE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VACLE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VACLE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VACLT_VACGT": {
        "authored": " takes the absolute value of each element in a vector, and compares it with the\nabsolute value of the corresponding element of a second vector. If the first is\nless than the second, the corresponding element in the destination vector is set\nto all ones. Otherwise, it is set to all zeros",
        "heading": "VACLT",
        "templates": {
          "A1": [
            "VACLT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VACLT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VACLT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VACLT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VADDHN": {
        "authored": "Vector Add and Narrow, returning High Half adds corresponding elements in two\nquadword vectors, and places the most significant half of each result in a\ndoubleword vector. The results are truncated. For rounded results, see VRADDHN.\n\nThe operand elements can be 16-bit, 32-bit, or 64-bit integers. There is no\ndistinction between signed and unsigned integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VADDHN",
        "templates": {
          "A1": [
            "VADDHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>"
          ],
          "T1": [
            "VADDHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>"
          ]
        }
      },
      "VADDL": {
        "authored": "Vector Add Long adds corresponding elements in two doubleword vectors, and\nplaces the results in a quadword vector. Before adding, it sign-extends or zero-\nextends the elements of both operands.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VADDL",
        "templates": {
          "A1": [
            "VADDL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VADDL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ]
        }
      },
      "VADDW": {
        "authored": "Vector Add Wide adds corresponding elements in one quadword and one doubleword\nvector, and places the results in a quadword vector. Before adding, it sign-\nextends or zero-extends the elements of the doubleword operand.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VADDW",
        "templates": {
          "A1": [
            "VADDW{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm>"
          ],
          "T1": [
            "VADDW{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm>"
          ]
        }
      },
      "VADD_f": {
        "authored": "Vector Add (floating-point) adds corresponding elements in two vectors, and\nplaces the results in the destination vector.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VADD (floating-point)",
        "templates": {
          "A1": [
            "VADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "A2": [
            "VADD{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>",
            "VADD{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>",
            "VADD{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>"
          ],
          "T1": [
            "VADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T2": [
            "VADD{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>",
            "VADD{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>",
            "VADD{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>"
          ]
        }
      },
      "VADD_i": {
        "authored": "Vector Add (integer) adds corresponding elements in two vectors, and places the\nresults in the destination vector.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VADD (integer)",
        "templates": {
          "A1": [
            "VADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VAND_VBIC_i": {
        "authored": " performs a bitwise AND between a register value and an immediate value, and\nreturns the result into the destination vector",
        "heading": "VAND (immediate)",
        "templates": {
          "A1": [
            "VAND{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>",
            "VAND{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>"
          ],
          "A2": [
            "VAND{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>",
            "VAND{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>"
          ],
          "T1": [
            "VAND{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>",
            "VAND{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>"
          ],
          "T2": [
            "VAND{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>",
            "VAND{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>"
          ]
        }
      },
      "VAND_r": {
        "authored": "Vector Bitwise AND (register) performs a bitwise AND operation between two\nregisters, and places the result in the destination register.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VAND (register)",
        "templates": {
          "A1": [
            "VAND{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VAND{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ],
          "T1": [
            "VAND{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VAND{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ]
        }
      },
      "VBIC_i": {
        "authored": "Vector Bitwise Bit Clear (immediate) performs a bitwise AND between a register\nvalue and the complement of an immediate value, and returns the result into the\ndestination vector.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VBIC (immediate)",
        "templates": {
          "A1": [
            "VBIC{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>",
            "VBIC{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>"
          ],
          "A2": [
            "VBIC{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>",
            "VBIC{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>"
          ],
          "T1": [
            "VBIC{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>",
            "VBIC{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>"
          ],
          "T2": [
            "VBIC{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>",
            "VBIC{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>"
          ]
        }
      },
      "VBIC_r": {
        "authored": "Vector Bitwise Bit Clear (register) performs a bitwise AND between a register\nvalue and the complement of a register value, and places the result in the\ndestination register.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VBIC (register)",
        "templates": {
          "A1": [
            "VBIC{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VBIC{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ],
          "T1": [
            "VBIC{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VBIC{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ]
        }
      },
      "VBIF": {
        "authored": "Vector Bitwise Insert if False inserts each bit from the first source register\ninto the destination register if the corresponding bit of the second source\nregister is 0, otherwise leaves the bit in the destination register unchanged.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VBIF",
        "templates": {
          "A1": [
            "VBIF{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VBIF{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ],
          "T1": [
            "VBIF{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VBIF{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ]
        }
      },
      "VBIT": {
        "authored": "Vector Bitwise Insert if True inserts each bit from the first source register\ninto the destination register if the corresponding bit of the second source\nregister is 1, otherwise leaves the bit in the destination register unchanged.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VBIT",
        "templates": {
          "A1": [
            "VBIT{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VBIT{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ],
          "T1": [
            "VBIT{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VBIT{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ]
        }
      },
      "VBSL": {
        "authored": "Vector Bitwise Select sets each bit in the destination to the corresponding bit\nfrom the first source operand when the original destination bit was 1, otherwise\nfrom the second source operand.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VBSL",
        "templates": {
          "A1": [
            "VBSL{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VBSL{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ],
          "T1": [
            "VBSL{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VBSL{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ]
        }
      },
      "VCADD": {
        "authored": "Vector Complex Add.\n\nThis instruction operates on complex numbers that are represented in SIMD&FP\nregisters as pairs of elements, with the more significant element holding the\nimaginary part of the number and the less significant element holding the real\npart of the number. Each element holds a floating-point value. It performs the\nfollowing computation on the corresponding complex number element pairs from the\ntwo source registers:\n  - Considering the complex number from the second source register on an Argand\ndiagram, the number is rotated counterclockwise by 90 or 270 degrees.\n  - The rotated complex number is added to the complex number from the first\nsource register.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCADD",
        "templates": {
          "A1": [
            "VCADD{<q>}.<dt> <Dd>, <Dn>, <Dm>, #<rotate>",
            "VCADD{<q>}.<dt> <Qd>, <Qn>, <Qm>, #<rotate>"
          ],
          "T1": [
            "VCADD{<q>}.<dt> <Dd>, <Dn>, <Dm>, #<rotate>",
            "VCADD{<q>}.<dt> <Qd>, <Qn>, <Qm>, #<rotate>"
          ]
        }
      },
      "VCEQ_i": {
        "authored": "Vector Compare Equal to Zero takes each element in a vector, and compares it\nwith zero.  If it is equal to zero, the corresponding element in the destination\nvector is set to all ones. Otherwise, it is set to all zeros.\n\nThe operand vector elements are the same type, and are integers or floating-\npoint numbers. The result vector elements are fields the same size as the\noperand vector elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCEQ (immediate #0)",
        "templates": {
          "A1": [
            "VCEQ{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0",
            "VCEQ{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0"
          ],
          "T1": [
            "VCEQ{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0",
            "VCEQ{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0"
          ]
        }
      },
      "VCEQ_r": {
        "authored": "Vector Compare Equal takes each element in a vector, and compares it with the\ncorresponding element of a second vector. If they are equal, the corresponding\nelement in the destination vector is set to all ones. Otherwise, it is set to\nall zeros.\n\nThe operand vector elements are the same type, and are integers or floating-\npoint numbers. The result vector elements are fields the same size as the\noperand vector elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCEQ (register)",
        "templates": {
          "A1": [
            "VCEQ{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCEQ{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "A2": [
            "VCEQ{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCEQ{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VCEQ{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCEQ{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T2": [
            "VCEQ{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCEQ{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VCGE_i": {
        "authored": "Vector Compare Greater Than or Equal to Zero takes each element in a vector, and\ncompares it with zero. If it is greater than or equal to zero, the corresponding\nelement in the destination vector is set to all ones. Otherwise, it is set to\nall zeros.\n\nThe operand vector elements are the same type, and are signed integers or\nfloating-point numbers. The result vector elements are fields the same size as\nthe operand vector elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCGE (immediate #0)",
        "templates": {
          "A1": [
            "VCGE{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0",
            "VCGE{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0"
          ],
          "T1": [
            "VCGE{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0",
            "VCGE{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0"
          ]
        }
      },
      "VCGE_r": {
        "authored": "Vector Compare Greater Than or Equal takes each element in a vector, and\ncompares it with the corresponding element of a second vector. If the first is\ngreater than or equal to the second, the corresponding element in the\ndestination vector is set to all ones. Otherwise, it is set to all zeros.\n\nThe operand vector elements are the same type, and are signed integers, unsigned\nintegers, or floating-point numbers. The result vector elements are fields the\nsame size as the operand vector elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCGE (register)",
        "templates": {
          "A1": [
            "VCGE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCGE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "A2": [
            "VCGE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCGE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VCGE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCGE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T2": [
            "VCGE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCGE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VCGT_i": {
        "authored": "Vector Compare Greater Than Zero takes each element in a vector, and compares it\nwith zero.  If it is greater than zero, the corresponding element in the\ndestination vector is set to all ones. Otherwise, it is set to all zeros.\n\nThe operand vector elements are the same type, and are signed integers or\nfloating-point numbers. The result vector elements are fields the same size as\nthe operand vector elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCGT (immediate #0)",
        "templates": {
          "A1": [
            "VCGT{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0",
            "VCGT{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0"
          ],
          "T1": [
            "VCGT{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0",
            "VCGT{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0"
          ]
        }
      },
      "VCGT_r": {
        "authored": "Vector Compare Greater Than takes each element in a vector, and compares it with\nthe corresponding element of a second vector. If the first is greater than the\nsecond, the corresponding element in the destination vector is set to all ones.\nOtherwise, it is set to all zeros.\n\nThe operand vector elements are the same type, and are signed integers, unsigned\nintegers, or floating-point numbers. The result vector elements are fields the\nsame size as the operand vector elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCGT (register)",
        "templates": {
          "A1": [
            "VCGT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCGT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "A2": [
            "VCGT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCGT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VCGT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCGT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T2": [
            "VCGT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCGT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VCLE_VCGE_r": {
        "authored": " takes each element in a vector, and compares it with the corresponding element\nof a second vector. If the first is less than or equal to the second, the\ncorresponding element in the destination vector is set to all ones. Otherwise,\nit is set to all zeros",
        "heading": "VCLE (register)",
        "templates": {
          "A1": [
            "VCLE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCLE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "A2": [
            "VCLE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCLE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VCLE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCLE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T2": [
            "VCLE{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCLE{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VCLE_i": {
        "authored": "Vector Compare Less Than or Equal to Zero takes each element in a vector, and\ncompares it with zero. If it is less than or equal to zero, the corresponding\nelement in the destination vector is set to all ones. Otherwise, it is set to\nall zeros.\n\nThe operand vector elements are the same type, and are signed integers or\nfloating-point numbers. The result vector elements are fields the same size as\nthe operand vector elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCLE (immediate #0)",
        "templates": {
          "A1": [
            "VCLE{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0",
            "VCLE{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0"
          ],
          "T1": [
            "VCLE{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0",
            "VCLE{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0"
          ]
        }
      },
      "VCLS": {
        "authored": "Vector Count Leading Sign Bits counts the number of consecutive bits following\nthe topmost bit, that are the same as the topmost bit, in each element in a\nvector, and places the results in a second vector. The count does not include\nthe topmost bit itself.\n\nThe operand vector elements can be any one of 8-bit, 16-bit, or 32-bit signed\nintegers.\n\nThe result vector elements are the same data type as the operand vector\nelements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCLS",
        "templates": {
          "A1": [
            "VCLS{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VCLS{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VCLS{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VCLS{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VCLT_VCGT_r": {
        "authored": " takes each element in a vector, and compares it with the corresponding element\nof a second vector. If the first is less than the second, the corresponding\nelement in the destination vector is set to all ones. Otherwise, it is set to\nall zeros",
        "heading": "VCLT (register)",
        "templates": {
          "A1": [
            "VCLT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCLT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "A2": [
            "VCLT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCLT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VCLT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCLT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T2": [
            "VCLT{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VCLT{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VCLT_i": {
        "authored": "Vector Compare Less Than Zero takes each element in a vector, and compares it\nwith zero.  If it is less than zero, the corresponding element in the\ndestination vector is set to all ones. Otherwise, it is set to all zeros.\n\nThe operand vector elements are the same type, and are signed integers or\nfloating-point numbers. The result vector elements are fields the same size as\nthe operand vector elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCLT (immediate #0)",
        "templates": {
          "A1": [
            "VCLT{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0",
            "VCLT{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0"
          ],
          "T1": [
            "VCLT{<c>}{<q>}.<dt> {<Dd>,} <Dm>, #0",
            "VCLT{<c>}{<q>}.<dt> {<Qd>,} <Qm>, #0"
          ]
        }
      },
      "VCLZ": {
        "authored": "Vector Count Leading Zeros counts the number of consecutive zeros, starting from\nthe most significant bit, in each element in a vector, and places the results in\na second vector.\n\nThe operand vector elements can be any one of 8-bit, 16-bit, or 32-bit integers.\nThere is no distinction between signed and unsigned integers.\n\nThe result vector elements are the same data type as the operand vector\nelements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCLZ",
        "templates": {
          "A1": [
            "VCLZ{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VCLZ{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VCLZ{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VCLZ{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VCMLA": {
        "authored": "Vector Complex Multiply Accumulate.\n\nThis instruction operates on complex numbers that are represented in SIMD&FP\nregisters as pairs of elements, with the more significant element holding the\nimaginary part of the number and the less significant element holding the real\npart of the number. Each element holds a floating-point value. It performs the\nfollowing computation on the corresponding complex number element pairs from the\ntwo source registers and the destination register:\n  - Considering the complex number from the second source register on an Argand\ndiagram, the number is rotated counterclockwise by 0, 90, 180, or 270 degrees.\n  - The two elements of the transformed complex number are multiplied by:\n    - The real element of the complex number from the first source register, if\nthe transformation was a rotation by 0 or 180 degrees.\n    - The imaginary element of the complex number from the first source\nregister, if the transformation was a rotation by 90 or 270 degrees.\n  - The complex number resulting from that multiplication is added to the\ncomplex number from the destination register.\n\nThe multiplication and addition operations are performed as a fused multiply-\nadd, without any intermediate rounding.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCMLA",
        "templates": {
          "A1": [
            "VCMLA{<q>}.<dt> <Dd>, <Dn>, <Dm>, #<rotate>",
            "VCMLA{<q>}.<dt> <Qd>, <Qn>, <Qm>, #<rotate>"
          ],
          "T1": [
            "VCMLA{<q>}.<dt> <Dd>, <Dn>, <Dm>, #<rotate>",
            "VCMLA{<q>}.<dt> <Qd>, <Qn>, <Qm>, #<rotate>"
          ]
        }
      },
      "VCMLA_s": {
        "authored": "Vector Complex Multiply Accumulate (by element).\n\nThis instruction operates on complex numbers that are represented in SIMD&FP\nregisters as pairs of elements, with the more significant element holding the\nimaginary part of the number and the less significant element holding the real\npart of the number. Each element holds a floating-point value. It performs the\nfollowing computation on complex numbers from the first source register and the\ndestination register with the specified complex number from the second source\nregister:\n  - Considering the complex number from the second source register on an Argand\ndiagram, the number is rotated counterclockwise by 0, 90, 180, or 270 degrees.\n  - The two elements of the transformed complex number are multiplied by:\n    - The real element of the complex number from the first source register, if\nthe transformation was a rotation by 0 or 180 degrees.\n    - The imaginary element of the complex number from the first source\nregister, if the transformation was a rotation by 90 or 270 degrees.\n  - The complex number resulting from that multiplication is added to the\ncomplex number from the destination register.\n\nThe multiplication and addition operations are performed as a fused multiply-\nadd, without any intermediate rounding.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCMLA (by element)",
        "templates": {
          "A1": [
            "VCMLA{<q>}.F16 <Dd>, <Dn>, <Dm>[<index>], #<rotate>",
            "VCMLA{<q>}.F32 <Dd>, <Dn>, <Dm>[0], #<rotate>",
            "VCMLA{<q>}.F16 <Qd>, <Qn>, <Dm>[<index>], #<rotate>",
            "VCMLA{<q>}.F32 <Qd>, <Qn>, <Dm>[0], #<rotate>"
          ],
          "T1": [
            "VCMLA{<q>}.F16 <Dd>, <Dn>, <Dm>[<index>], #<rotate>",
            "VCMLA{<q>}.F32 <Dd>, <Dn>, <Dm>[0], #<rotate>",
            "VCMLA{<q>}.F16 <Qd>, <Qn>, <Dm>[<index>], #<rotate>",
            "VCMLA{<q>}.F32 <Qd>, <Qn>, <Dm>[0], #<rotate>"
          ]
        }
      },
      "VCMP": {
        "authored": "Vector Compare compares two floating-point registers, or one floating-point\nregister and zero. It writes the result to the FPSCR flags. These are normally\ntransferred to the PSTATE.{N, Z, C, V} Condition flags by a subsequent VMRS\ninstruction.\n\nIt raises an Invalid Operation exception only if either operand is a signaling\nNaN.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCMP",
        "templates": {
          "A1": [
            "VCMP{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VCMP{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VCMP{<c>}{<q>}.F64 <Dd>, <Dm>"
          ],
          "A2": [
            "VCMP{<c>}{<q>}.F16 <Sd>, #0.0",
            "VCMP{<c>}{<q>}.F32 <Sd>, #0.0",
            "VCMP{<c>}{<q>}.F64 <Dd>, #0.0"
          ],
          "T1": [
            "VCMP{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VCMP{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VCMP{<c>}{<q>}.F64 <Dd>, <Dm>"
          ],
          "T2": [
            "VCMP{<c>}{<q>}.F16 <Sd>, #0.0",
            "VCMP{<c>}{<q>}.F32 <Sd>, #0.0",
            "VCMP{<c>}{<q>}.F64 <Dd>, #0.0"
          ]
        }
      },
      "VCMPE": {
        "authored": "Vector Compare, raising Invalid Operation on NaN compares two floating-point\nregisters, or one floating-point register and zero. It writes the result to the\nFPSCR flags. These are normally transferred to the PSTATE.{N, Z, C, V} Condition\nflags by a subsequent VMRS instruction.\n\nIt raises an Invalid Operation exception if either operand is any type of NaN.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCMPE",
        "templates": {
          "A1": [
            "VCMPE{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VCMPE{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VCMPE{<c>}{<q>}.F64 <Dd>, <Dm>"
          ],
          "A2": [
            "VCMPE{<c>}{<q>}.F16 <Sd>, #0.0",
            "VCMPE{<c>}{<q>}.F32 <Sd>, #0.0",
            "VCMPE{<c>}{<q>}.F64 <Dd>, #0.0"
          ],
          "T1": [
            "VCMPE{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VCMPE{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VCMPE{<c>}{<q>}.F64 <Dd>, <Dm>"
          ],
          "T2": [
            "VCMPE{<c>}{<q>}.F16 <Sd>, #0.0",
            "VCMPE{<c>}{<q>}.F32 <Sd>, #0.0",
            "VCMPE{<c>}{<q>}.F64 <Dd>, #0.0"
          ]
        }
      },
      "VCNT": {
        "authored": "Vector Count Set Bits counts the number of bits that are one in each element in\na vector, and places the results in a second vector.\n\nThe operand vector elements must be 8-bit fields.\n\nThe result vector elements are 8-bit integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCNT",
        "templates": {
          "A1": [
            "VCNT{<c>}{<q>}.8 <Dd>, <Dm>",
            "VCNT{<c>}{<q>}.8 <Qd>, <Qm>"
          ],
          "T1": [
            "VCNT{<c>}{<q>}.8 <Dd>, <Dm>",
            "VCNT{<c>}{<q>}.8 <Qd>, <Qm>"
          ]
        }
      },
      "VCVTA_asimd": {
        "authored": "Vector Convert floating-point to integer with Round to Nearest with Ties to Away\nconverts each element in a vector from floating-point to integer using the Round\nto Nearest with Ties to Away rounding mode, and places the results in a second\nvector.\n\nThe operand vector elements are floating-point numbers.\n\nThe result vector elements are 32-bit integers. Signed and unsigned integers are\ndistinct.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVTA (Advanced SIMD)",
        "templates": {
          "A1": [
            "VCVTA{<q>}.<dt>.<dt2> <Dd>, <Dm>",
            "VCVTA{<q>}.<dt>.<dt2> <Qd>, <Qm>"
          ],
          "T1": [
            "VCVTA{<q>}.<dt>.<dt2> <Dd>, <Dm>",
            "VCVTA{<q>}.<dt>.<dt2> <Qd>, <Qm>"
          ]
        }
      },
      "VCVTA_vfp": {
        "authored": "Convert floating-point to integer with Round to Nearest with Ties to Away\nconverts a value in a register from floating-point to a 32-bit integer using the\nRound to Nearest with Ties to Away rounding mode, and places the result in a\nsecond register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVTA (floating-point)",
        "templates": {
          "A1": [
            "VCVTA{<q>}.<dt>.F16 <Sd>, <Sm>",
            "VCVTA{<q>}.<dt>.F32 <Sd>, <Sm>",
            "VCVTA{<q>}.<dt>.F64 <Sd>, <Dm>"
          ],
          "T1": [
            "VCVTA{<q>}.<dt>.F16 <Sd>, <Sm>",
            "VCVTA{<q>}.<dt>.F32 <Sd>, <Sm>",
            "VCVTA{<q>}.<dt>.F64 <Sd>, <Dm>"
          ]
        }
      },
      "VCVTB": {
        "authored": "Convert to or from a half-precision value in the bottom half of a single-\nprecision register does one of the following:\n  - Converts the half-precision value in the bottom half of a single-precision\nregister to single-precision and writes the result to a single-precision\nregister.\n  - Converts the half-precision value in the bottom half of a single-precision\nregister to double-precision and writes the result to a double-precision\nregister.\n  - Converts the single-precision value in a single-precision register to half-\nprecision and writes the result into the bottom half of a single-precision\nregister, preserving the other half of the destination register.\n  - Converts the double-precision value in a double-precision register to half-\nprecision and writes the result into the bottom half of a single-precision\nregister, preserving the other half of the destination register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVTB",
        "templates": {
          "A1": [
            "VCVTB{<c>}{<q>}.F32.F16 <Sd>, <Sm>",
            "VCVTB{<c>}{<q>}.F64.F16 <Dd>, <Sm>",
            "VCVTB{<c>}{<q>}.F16.F32 <Sd>, <Sm>",
            "VCVTB{<c>}{<q>}.F16.F64 <Sd>, <Dm>"
          ],
          "T1": [
            "VCVTB{<c>}{<q>}.F32.F16 <Sd>, <Sm>",
            "VCVTB{<c>}{<q>}.F64.F16 <Dd>, <Sm>",
            "VCVTB{<c>}{<q>}.F16.F32 <Sd>, <Sm>",
            "VCVTB{<c>}{<q>}.F16.F64 <Sd>, <Dm>"
          ]
        }
      },
      "VCVTM_asimd": {
        "authored": "Vector Convert floating-point to integer with Round towards -Infinity converts\neach element in a vector from floating-point to integer using the Round towards\n-Infinity rounding mode, and places the results in a second vector.\n\nThe operand vector elements are floating-point numbers.\n\nThe result vector elements are 32-bit integers. Signed and unsigned integers are\ndistinct.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVTM (Advanced SIMD)",
        "templates": {
          "A1": [
            "VCVTM{<q>}.<dt>.<dt2> <Dd>, <Dm>",
            "VCVTM{<q>}.<dt>.<dt2> <Qd>, <Qm>"
          ],
          "T1": [
            "VCVTM{<q>}.<dt>.<dt2> <Dd>, <Dm>",
            "VCVTM{<q>}.<dt>.<dt2> <Qd>, <Qm>"
          ]
        }
      },
      "VCVTM_vfp": {
        "authored": "Convert floating-point to integer with Round towards -Infinity converts a value\nin a register from floating-point to a 32-bit integer using the Round towards\n-Infinity rounding mode, and places the result in a second register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVTM (floating-point)",
        "templates": {
          "A1": [
            "VCVTM{<q>}.<dt>.F16 <Sd>, <Sm>",
            "VCVTM{<q>}.<dt>.F32 <Sd>, <Sm>",
            "VCVTM{<q>}.<dt>.F64 <Sd>, <Dm>"
          ],
          "T1": [
            "VCVTM{<q>}.<dt>.F16 <Sd>, <Sm>",
            "VCVTM{<q>}.<dt>.F32 <Sd>, <Sm>",
            "VCVTM{<q>}.<dt>.F64 <Sd>, <Dm>"
          ]
        }
      },
      "VCVTN_asimd": {
        "authored": "Vector Convert floating-point to integer with Round to Nearest converts each\nelement in a vector from floating-point to integer using the Round to Nearest\nrounding mode, and places the results in a second vector.\n\nThe operand vector elements are floating-point numbers.\n\nThe result vector elements are 32-bit integers. Signed and unsigned integers are\ndistinct.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVTN (Advanced SIMD)",
        "templates": {
          "A1": [
            "VCVTN{<q>}.<dt>.<dt2> <Dd>, <Dm>",
            "VCVTN{<q>}.<dt>.<dt2> <Qd>, <Qm>"
          ],
          "T1": [
            "VCVTN{<q>}.<dt>.<dt2> <Dd>, <Dm>",
            "VCVTN{<q>}.<dt>.<dt2> <Qd>, <Qm>"
          ]
        }
      },
      "VCVTN_vfp": {
        "authored": "Convert floating-point to integer with Round to Nearest converts a value in a\nregister from floating-point to a 32-bit integer using the Round to Nearest\nrounding mode, and places the result in a second register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVTN (floating-point)",
        "templates": {
          "A1": [
            "VCVTN{<q>}.<dt>.F16 <Sd>, <Sm>",
            "VCVTN{<q>}.<dt>.F32 <Sd>, <Sm>",
            "VCVTN{<q>}.<dt>.F64 <Sd>, <Dm>"
          ],
          "T1": [
            "VCVTN{<q>}.<dt>.F16 <Sd>, <Sm>",
            "VCVTN{<q>}.<dt>.F32 <Sd>, <Sm>",
            "VCVTN{<q>}.<dt>.F64 <Sd>, <Dm>"
          ]
        }
      },
      "VCVTP_asimd": {
        "authored": "Vector Convert floating-point to integer with Round towards +Infinity converts\neach element in a vector from floating-point to integer using the Round towards\n+Infinity rounding mode, and places the results in a second vector.\n\nThe operand vector elements are floating-point numbers.\n\nThe result vector elements are 32-bit integers. Signed and unsigned integers are\ndistinct.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVTP (Advanced SIMD)",
        "templates": {
          "A1": [
            "VCVTP{<q>}.<dt>.<dt2> <Dd>, <Dm>",
            "VCVTP{<q>}.<dt>.<dt2> <Qd>, <Qm>"
          ],
          "T1": [
            "VCVTP{<q>}.<dt>.<dt2> <Dd>, <Dm>",
            "VCVTP{<q>}.<dt>.<dt2> <Qd>, <Qm>"
          ]
        }
      },
      "VCVTP_vfp": {
        "authored": "Convert floating-point to integer with Round towards +Infinity converts a value\nin a register from floating-point to a 32-bit integer using the Round towards\n+Infinity rounding mode, and places the result in a second register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVTP (floating-point)",
        "templates": {
          "A1": [
            "VCVTP{<q>}.<dt>.F16 <Sd>, <Sm>",
            "VCVTP{<q>}.<dt>.F32 <Sd>, <Sm>",
            "VCVTP{<q>}.<dt>.F64 <Sd>, <Dm>"
          ],
          "T1": [
            "VCVTP{<q>}.<dt>.F16 <Sd>, <Sm>",
            "VCVTP{<q>}.<dt>.F32 <Sd>, <Sm>",
            "VCVTP{<q>}.<dt>.F64 <Sd>, <Dm>"
          ]
        }
      },
      "VCVTR_iv": {
        "authored": "Convert floating-point to integer converts a value in a register from floating-\npoint to a 32-bit integer, using the rounding mode specified by the FPSCR and\nplaces the result in a second register.\n\nVCVT (between floating-point and fixed-point, floating-point) describes\nconversions between floating-point and 16-bit integers.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVTR",
        "templates": {
          "A1": [
            "VCVTR{<c>}{<q>}.U32.F16 <Sd>, <Sm>",
            "VCVTR{<c>}{<q>}.S32.F16 <Sd>, <Sm>",
            "VCVTR{<c>}{<q>}.U32.F32 <Sd>, <Sm>",
            "VCVTR{<c>}{<q>}.S32.F32 <Sd>, <Sm>",
            "VCVTR{<c>}{<q>}.U32.F64 <Sd>, <Dm>",
            "VCVTR{<c>}{<q>}.S32.F64 <Sd>, <Dm>"
          ],
          "T1": [
            "VCVTR{<c>}{<q>}.U32.F16 <Sd>, <Sm>",
            "VCVTR{<c>}{<q>}.S32.F16 <Sd>, <Sm>",
            "VCVTR{<c>}{<q>}.U32.F32 <Sd>, <Sm>",
            "VCVTR{<c>}{<q>}.S32.F32 <Sd>, <Sm>",
            "VCVTR{<c>}{<q>}.U32.F64 <Sd>, <Dm>",
            "VCVTR{<c>}{<q>}.S32.F64 <Sd>, <Dm>"
          ]
        }
      },
      "VCVTT": {
        "authored": "Convert to or from a half-precision value in the top half of a single-precision\nregister does one of the following:\n  - Converts the half-precision value in the top half of a single-precision\nregister to single-precision and writes the result to a single-precision\nregister.\n  - Converts the half-precision value in the top half of a single-precision\nregister to double-precision and writes the result to a double-precision\nregister.\n  - Converts the single-precision value in a single-precision register to half-\nprecision and writes the result into the top half of a single-precision\nregister, preserving the other half of the destination register.\n  - Converts the double-precision value in a double-precision register to half-\nprecision and writes the result into the top half of a single-precision\nregister, preserving the other half of the destination register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVTT",
        "templates": {
          "A1": [
            "VCVTT{<c>}{<q>}.F32.F16 <Sd>, <Sm>",
            "VCVTT{<c>}{<q>}.F64.F16 <Dd>, <Sm>",
            "VCVTT{<c>}{<q>}.F16.F32 <Sd>, <Sm>",
            "VCVTT{<c>}{<q>}.F16.F64 <Sd>, <Dm>"
          ],
          "T1": [
            "VCVTT{<c>}{<q>}.F32.F16 <Sd>, <Sm>",
            "VCVTT{<c>}{<q>}.F64.F16 <Dd>, <Sm>",
            "VCVTT{<c>}{<q>}.F16.F32 <Sd>, <Sm>",
            "VCVTT{<c>}{<q>}.F16.F64 <Sd>, <Dm>"
          ]
        }
      },
      "VCVT_ds": {
        "authored": "Convert between double-precision and single-precision does one of the following:\n  - Converts the value in a double-precision register to single-precision and\nwrites the result to a single-precision register.\n  - Converts the value in a single-precision register to double-precision and\nwrites the result to a double-precision register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVT (between double-precision and single-precision)",
        "templates": {
          "A1": [
            "VCVT{<c>}{<q>}.F64.F32 <Dd>, <Sm>",
            "VCVT{<c>}{<q>}.F32.F64 <Sd>, <Dm>"
          ],
          "T1": [
            "VCVT{<c>}{<q>}.F64.F32 <Dd>, <Sm>",
            "VCVT{<c>}{<q>}.F32.F64 <Sd>, <Dm>"
          ]
        }
      },
      "VCVT_hs": {
        "authored": "Vector Convert between half-precision and single-precision converts each element\nin a vector from single-precision to half-precision floating-point, or from\nhalf-precision to single-precision, and places the results in a second vector.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVT (between half-precision and single-precision, Advanced SIMD)",
        "templates": {
          "A1": [
            "VCVT{<c>}{<q>}.F32.F16 <Qd>, <Dm>",
            "VCVT{<c>}{<q>}.F16.F32 <Dd>, <Qm>"
          ],
          "T1": [
            "VCVT{<c>}{<q>}.F32.F16 <Qd>, <Dm>",
            "VCVT{<c>}{<q>}.F16.F32 <Dd>, <Qm>"
          ]
        }
      },
      "VCVT_is": {
        "authored": "Vector Convert between floating-point and integer converts each element in a\nvector from floating-point to integer, or from integer to floating-point, and\nplaces the results in a second vector.\n\nThe vector elements are the same type, and are floating-point numbers or\nintegers. Signed and unsigned integers are distinct.\n\nThe floating-point to integer operation uses the Round towards Zero rounding\nmode. The integer to floating-point operation uses the Round to Nearest rounding\nmode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVT (between floating-point and integer, Advanced SIMD)",
        "templates": {
          "A1": [
            "VCVT{<c>}{<q>}.<dt1>.<dt2> <Dd>, <Dm>",
            "VCVT{<c>}{<q>}.<dt1>.<dt2> <Qd>, <Qm>"
          ],
          "T1": [
            "VCVT{<c>}{<q>}.<dt1>.<dt2> <Dd>, <Dm>",
            "VCVT{<c>}{<q>}.<dt1>.<dt2> <Qd>, <Qm>"
          ]
        }
      },
      "VCVT_iv": {
        "authored": "Convert floating-point to integer with Round towards Zero converts a value in a\nregister from floating-point to a 32-bit integer, using the Round towards Zero\nrounding mode, and places the result in a second register.\n\nVCVT (between floating-point and fixed-point, floating-point) describes\nconversions between floating-point and 16-bit integers.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVT (floating-point to integer, floating-point)",
        "templates": {
          "A1": [
            "VCVT{<c>}{<q>}.U32.F16 <Sd>, <Sm>",
            "VCVT{<c>}{<q>}.S32.F16 <Sd>, <Sm>",
            "VCVT{<c>}{<q>}.U32.F32 <Sd>, <Sm>",
            "VCVT{<c>}{<q>}.S32.F32 <Sd>, <Sm>",
            "VCVT{<c>}{<q>}.U32.F64 <Sd>, <Dm>",
            "VCVT{<c>}{<q>}.S32.F64 <Sd>, <Dm>"
          ],
          "T1": [
            "VCVT{<c>}{<q>}.U32.F16 <Sd>, <Sm>",
            "VCVT{<c>}{<q>}.S32.F16 <Sd>, <Sm>",
            "VCVT{<c>}{<q>}.U32.F32 <Sd>, <Sm>",
            "VCVT{<c>}{<q>}.S32.F32 <Sd>, <Sm>",
            "VCVT{<c>}{<q>}.U32.F64 <Sd>, <Dm>",
            "VCVT{<c>}{<q>}.S32.F64 <Sd>, <Dm>"
          ]
        }
      },
      "VCVT_vi": {
        "authored": "Convert integer to floating-point converts a 32-bit integer to floating-point\nusing the rounding mode specified by the FPSCR, and places the result in a\nsecond register.\n\nVCVT (between floating-point and fixed-point, floating-point) describes\nconversions between floating-point and 16-bit integers.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVT (integer to floating-point, floating-point)",
        "templates": {
          "A1": [
            "VCVT{<c>}{<q>}.F16.<dt> <Sd>, <Sm>",
            "VCVT{<c>}{<q>}.F32.<dt> <Sd>, <Sm>",
            "VCVT{<c>}{<q>}.F64.<dt> <Dd>, <Sm>"
          ],
          "T1": [
            "VCVT{<c>}{<q>}.F16.<dt> <Sd>, <Sm>",
            "VCVT{<c>}{<q>}.F32.<dt> <Sd>, <Sm>",
            "VCVT{<c>}{<q>}.F64.<dt> <Dd>, <Sm>"
          ]
        }
      },
      "VCVT_xs": {
        "authored": "Vector Convert between floating-point and fixed-point converts each element in a\nvector from floating-point to fixed-point, or from fixed-point to floating-\npoint, and places the results in a second vector.\n\nThe vector elements are the same type, and are floating-point numbers or\nintegers. Signed and unsigned integers are distinct.\n\nThe floating-point to fixed-point operation uses the Round towards Zero rounding\nmode. The fixed-point to floating-point operation uses the Round to Nearest\nrounding mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVT (between floating-point and fixed-point, Advanced SIMD)",
        "templates": {
          "A1": [
            "VCVT{<c>}{<q>}.<dt1>.<dt2> <Dd>, <Dm>, #<fbits>",
            "VCVT{<c>}{<q>}.<dt1>.<dt2> <Qd>, <Qm>, #<fbits>"
          ],
          "T1": [
            "VCVT{<c>}{<q>}.<dt1>.<dt2> <Dd>, <Dm>, #<fbits>",
            "VCVT{<c>}{<q>}.<dt1>.<dt2> <Qd>, <Qm>, #<fbits>"
          ]
        }
      },
      "VCVT_xv": {
        "authored": "Convert between floating-point and fixed-point converts a value in a register\nfrom floating-point to fixed-point, or from fixed-point to floating-point.\nSoftware can specify the fixed-point value as either signed or unsigned.\n\nThe fixed-point value can be 16-bit or 32-bit. Conversions from fixed-point\nvalues take their operand from the low-order bits of the source register and\nignore any remaining bits. Signed conversions to fixed-point values sign-extend\nthe result value to the destination register width. Unsigned conversions to\nfixed-point values zero-extend the result value to the destination register\nwidth.\n\nThe floating-point to fixed-point operation uses the Round towards Zero rounding\nmode. The fixed-point to floating-point operation uses the Round to Nearest\nrounding mode.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VCVT (between floating-point and fixed-point, floating-point)",
        "templates": {
          "A1": [
            "VCVT{<c>}{<q>}.F16.<dt> <Sdm>, <Sdm>, #<fbits>",
            "VCVT{<c>}{<q>}.<dt>.F16 <Sdm>, <Sdm>, #<fbits>",
            "VCVT{<c>}{<q>}.F32.<dt> <Sdm>, <Sdm>, #<fbits>",
            "VCVT{<c>}{<q>}.<dt>.F32 <Sdm>, <Sdm>, #<fbits>",
            "VCVT{<c>}{<q>}.F64.<dt> <Ddm>, <Ddm>, #<fbits>",
            "VCVT{<c>}{<q>}.<dt>.F64 <Ddm>, <Ddm>, #<fbits>"
          ],
          "T1": [
            "VCVT{<c>}{<q>}.F16.<dt> <Sdm>, <Sdm>, #<fbits>",
            "VCVT{<c>}{<q>}.<dt>.F16 <Sdm>, <Sdm>, #<fbits>",
            "VCVT{<c>}{<q>}.F32.<dt> <Sdm>, <Sdm>, #<fbits>",
            "VCVT{<c>}{<q>}.<dt>.F32 <Sdm>, <Sdm>, #<fbits>",
            "VCVT{<c>}{<q>}.F64.<dt> <Ddm>, <Ddm>, #<fbits>",
            "VCVT{<c>}{<q>}.<dt>.F64 <Ddm>, <Ddm>, #<fbits>"
          ]
        }
      },
      "VDIV": {
        "authored": "Divide divides one floating-point value by another floating-point value and\nwrites the result to a third floating-point register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VDIV",
        "templates": {
          "A1": [
            "VDIV{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>",
            "VDIV{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>",
            "VDIV{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>"
          ],
          "T1": [
            "VDIV{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>",
            "VDIV{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>",
            "VDIV{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>"
          ]
        }
      },
      "VDUP_r": {
        "authored": "Duplicate general-purpose register to vector duplicates an element from a\ngeneral-purpose register into every element of the destination vector.\n\nThe destination vector elements can be 8-bit, 16-bit, or 32-bit fields. The\nsource element is the least significant 8, 16, or 32 bits of the general-purpose\nregister. There is no distinction between data types.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VDUP (general-purpose register)",
        "templates": {
          "A1": [
            "VDUP{<c>}{<q>}.<size> <Qd>, <Rt>",
            "VDUP{<c>}{<q>}.<size> <Dd>, <Rt>"
          ],
          "T1": [
            "VDUP{<c>}{<q>}.<size> <Qd>, <Rt>",
            "VDUP{<c>}{<q>}.<size> <Dd>, <Rt>"
          ]
        }
      },
      "VDUP_s": {
        "authored": "Duplicate vector element to vector duplicates a single element of a vector into\nevery element of the destination vector.\n\nThe scalar, and the destination vector elements, can be any one of 8-bit,\n16-bit, or 32-bit fields. There is no distinction between data types.\n\nFor more information about scalars see Advanced SIMD scalars.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VDUP (scalar)",
        "templates": {
          "A1": [
            "VDUP{<c>}{<q>}.<size> <Dd>, <Dm[x]>",
            "VDUP{<c>}{<q>}.<size> <Qd>, <Dm[x]>"
          ],
          "T1": [
            "VDUP{<c>}{<q>}.<size> <Dd>, <Dm[x]>",
            "VDUP{<c>}{<q>}.<size> <Qd>, <Dm[x]>"
          ]
        }
      },
      "VEOR": {
        "authored": "Vector Bitwise Exclusive OR performs a bitwise Exclusive OR operation between\ntwo registers, and places the result in the destination register. The operand\nand result registers can be quadword or doubleword. They must all be the same\nsize.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VEOR",
        "templates": {
          "A1": [
            "VEOR{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VEOR{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ],
          "T1": [
            "VEOR{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VEOR{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ]
        }
      },
      "VEXT": {
        "authored": "Vector Extract extracts elements from the bottom end of the second operand\nvector and the top end of the first, concatenates them and places the result in\nthe destination vector.\n\nThe elements of the vectors are treated as being 8-bit fields. There is no\ndistinction between data types.\n\n\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VEXT (byte elements)",
        "templates": {
          "A1": [
            "VEXT{<c>}{<q>}.8 {<Dd>,} <Dn>, <Dm>, #<imm>",
            "VEXT{<c>}{<q>}.8 {<Qd>,} <Qn>, <Qm>, #<imm>"
          ],
          "T1": [
            "VEXT{<c>}{<q>}.8 {<Dd>,} <Dn>, <Dm>, #<imm>",
            "VEXT{<c>}{<q>}.8 {<Qd>,} <Qn>, <Qm>, #<imm>"
          ]
        }
      },
      "VEXT_VEXT": {
        "authored": " extracts elements from the bottom end of the second operand vector and the top\nend of the first, concatenates them and places the result in the destination\nvector",
        "heading": "VEXT (multibyte elements)",
        "templates": {
          "A1": [
            "VEXT{<c>}{<q>}.<size> {<Dd>,} <Dn>, <Dm>, #<imm>",
            "VEXT{<c>}{<q>}.<size> {<Qd>,} <Qn>, <Qm>, #<imm>"
          ],
          "T1": [
            "VEXT{<c>}{<q>}.<size> {<Dd>,} <Dn>, <Dm>, #<imm>",
            "VEXT{<c>}{<q>}.<size> {<Qd>,} <Qn>, <Qm>, #<imm>"
          ]
        }
      },
      "VFMA": {
        "authored": "Vector Fused Multiply Accumulate multiplies corresponding elements of two\nvectors, and accumulates the results into the elements of the destination\nvector. The instruction does not round the result of the multiply before the\naccumulation.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VFMA",
        "templates": {
          "A1": [
            "VFMA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VFMA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "A2": [
            "VFMA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VFMA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VFMA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VFMA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VFMA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "T2": [
            "VFMA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VFMA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VFMA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "VFMAL": {
        "authored": "Vector Floating-point Multiply-Add Long to accumulator (vector). This\ninstruction multiplies corresponding values in the vectors in the two source\nSIMD&FP registers, and accumulates the product to the corresponding vector\nelement of the destination SIMD&FP register. The instruction does not round the\nresult of the multiply before the accumulation.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.\n\nIn ARMv8.2 and ARMv8.3, this is an optional instruction. From ARMv8.4 it is\nmandatory for all implementations to support it.\n\nID_ISAR6.FHM indicates whether this instruction is supported.",
        "heading": "VFMAL (vector)",
        "templates": {
          "A1": [
            "VFMAL{<q>}.F16 <Dd>, <Sn>, <Sm>",
            "VFMAL{<q>}.F16 <Qd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VFMAL{<q>}.F16 <Dd>, <Sn>, <Sm>",
            "VFMAL{<q>}.F16 <Qd>, <Dn>, <Dm>"
          ]
        }
      },
      "VFMAL_s": {
        "authored": "Vector Floating-point Multiply-Add Long to accumulator (by scalar). This\ninstruction multiplies the vector elements in the first source SIMD&FP register\nby the specified value in the second source SIMD&FP register, and accumulates\nthe product to the corresponding vector element of the destination SIMD&FP\nregister. The instruction does not round the result of the multiply before the\naccumulation.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.\n\nIn ARMv8.2 and ARMv8.3, this is an optional instruction. From ARMv8.4 it is\nmandatory for all implementations to support it.\n\nID_ISAR6.FHM indicates whether this instruction is supported.",
        "heading": "VFMAL (by scalar)",
        "templates": {
          "A1": [
            "VFMAL{<q>}.F16 <Dd>, <Sn>, <Sm>[<index>]",
            "VFMAL{<q>}.F16 <Qd>, <Dn>, <Dm>[<index>]"
          ],
          "T1": [
            "VFMAL{<q>}.F16 <Dd>, <Sn>, <Sm>[<index>]",
            "VFMAL{<q>}.F16 <Qd>, <Dn>, <Dm>[<index>]"
          ]
        }
      },
      "VFMS": {
        "authored": "Vector Fused Multiply Subtract negates the elements of one vector and multiplies\nthem with the corresponding elements of another vector, adds the products to the\ncorresponding elements of the destination vector, and places the results in the\ndestination vector. The instruction does not round the result of the multiply\nbefore the addition.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VFMS",
        "templates": {
          "A1": [
            "VFMS{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VFMS{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "A2": [
            "VFMS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VFMS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VFMS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VFMS{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VFMS{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "T2": [
            "VFMS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VFMS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VFMS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "VFMSL": {
        "authored": "Vector Floating-point Multiply-Subtract Long from accumulator (vector). This\ninstruction negates the values in the vector of one SIMD&FP register, multiplies\nthese with the corresponding values in another vector, and accumulates the\nproduct to the corresponding vector element of the destination SIMD&FP register.\nThe instruction does not round the result of the multiply before the\naccumulation.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.\n\nIn ARMv8.2 and ARMv8.3, this is an optional instruction. From ARMv8.4 it is\nmandatory for all implementations to support it.\n\nID_ISAR6.FHM indicates whether this instruction is supported.",
        "heading": "VFMSL (vector)",
        "templates": {
          "A1": [
            "VFMSL{<q>}.F16 <Dd>, <Sn>, <Sm>",
            "VFMSL{<q>}.F16 <Qd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VFMSL{<q>}.F16 <Dd>, <Sn>, <Sm>",
            "VFMSL{<q>}.F16 <Qd>, <Dn>, <Dm>"
          ]
        }
      },
      "VFMSL_s": {
        "authored": "Vector Floating-point Multiply-Subtract Long from accumulator (by scalar). This\ninstruction multiplies the negated vector elements in the first source SIMD&FP\nregister by the specified value in the second source SIMD&FP register, and\naccumulates the product to the corresponding vector element of the destination\nSIMD&FP register. The instruction does not round the result of the multiply\nbefore the accumulation.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.\n\nIn ARMv8.2 and ARMv8.3, this is an optional instruction. From ARMv8.4 it is\nmandatory for all implementations to support it.\n\nID_ISAR6.FHM indicates whether this instruction is supported.",
        "heading": "VFMSL (by scalar)",
        "templates": {
          "A1": [
            "VFMSL{<q>}.F16 <Dd>, <Sn>, <Sm>[<index>]",
            "VFMSL{<q>}.F16 <Qd>, <Dn>, <Dm>[<index>]"
          ],
          "T1": [
            "VFMSL{<q>}.F16 <Dd>, <Sn>, <Sm>[<index>]",
            "VFMSL{<q>}.F16 <Qd>, <Dn>, <Dm>[<index>]"
          ]
        }
      },
      "VFNMA": {
        "authored": "Vector Fused Negate Multiply Accumulate negates one floating-point register\nvalue and multiplies it by another floating-point register value, adds the\nnegation of the floating-point value in the destination register to the product,\nand writes the result back to the destination register. The instruction does not\nround the result of the multiply before the addition.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VFNMA",
        "templates": {
          "A1": [
            "VFNMA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VFNMA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VFNMA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VFNMA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VFNMA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VFNMA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "VFNMS": {
        "authored": "Vector Fused Negate Multiply Subtract multiplies together two floating-point\nregister values, adds the negation of the floating-point value in the\ndestination register to the product, and writes the result back to the\ndestination register. The instruction does not round the result of the multiply\nbefore the addition.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VFNMS",
        "templates": {
          "A1": [
            "VFNMS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VFNMS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VFNMS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VFNMS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VFNMS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VFNMS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "VHADD": {
        "authored": "Vector Halving Add adds corresponding elements in two vectors of integers,\nshifts each result right one bit, and places the final results in the\ndestination vector. The results of the halving operations are truncated. For\nrounded results, see VRHADD).\n\nThe operand and result elements are all the same type, and can be any one of:\n  - 8-bit, 16-bit, or 32-bit signed integers.\n  - 8-bit, 16-bit, or 32-bit unsigned integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VHADD",
        "templates": {
          "A1": [
            "VHADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VHADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VHADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VHADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VHSUB": {
        "authored": "Vector Halving Subtract subtracts the elements of the second operand from the\ncorresponding elements of the first operand, shifts each result right one bit,\nand places the final results in the destination vector. The results of the\nhalving operations are truncated. There is no rounding version.\n\nThe operand and result elements are all the same type, and can be any one of:\n  - 8-bit, 16-bit, or 32-bit signed integers.\n  - 8-bit, 16-bit, or 32-bit unsigned integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VHSUB",
        "templates": {
          "A1": [
            "VHSUB{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VHSUB{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VHSUB{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VHSUB{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VINS": {
        "authored": "Vector move Insertion. This instruction copies the lower 16 bits of the 32-bit\nsource SIMD&FP register into the upper 16 bits of the 32-bit destination SIMD&FP\nregister, while preserving the values in the remaining bits.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VINS",
        "templates": {
          "A1": [
            "VINS{<q>}.F16 <Sd>, <Sm>"
          ],
          "T1": [
            "VINS{<q>}.F16 <Sd>, <Sm>"
          ]
        }
      },
      "VJCVT": {
        "authored": "Javascript Convert to signed fixed-point, rounding toward Zero. This instruction\nconverts the double-precision floating-point value in the SIMD&FP source\nregister to a 32-bit signed integer using the Round towards Zero rounding mode,\nand writes the result to the SIMD&FP destination register. If the result is too\nlarge to be accomodated as a signed 32-bit integer, then the result is the\ninteger modulo 2^32, as held in a 32-bit signed integer.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VJCVT",
        "templates": {
          "A1": [
            "VJCVT{<q>}.S32.F64 <Sd>, <Dm>"
          ],
          "T1": [
            "VJCVT{<q>}.S32.F64 <Sd>, <Dm>"
          ]
        }
      },
      "VLD1_1": {
        "authored": "Load single 1-element structure to one lane of one register loads one element\nfrom memory into one element of a register. Elements of the register that are\nnot loaded are unchanged. For details of the addressing mode see Advanced SIMD\naddressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLD1 (single element to one lane)",
        "templates": {
          "A1": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A2": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A3": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T2": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T3": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VLD1_a": {
        "authored": "Load single 1-element structure and replicate to all lanes of one register loads\none element from memory into every element of one or two vectors. For details of\nthe addressing mode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLD1 (single element to all lanes)",
        "templates": {
          "A1": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}],<Rm>"
          ],
          "T1": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VLD1_m": {
        "authored": "Load multiple single 1-element structures to one, two, three, or four registers\nloads elements from memory into one, two, three, or four registers, without de-\ninterleaving. Every element of each register is loaded. For details of the\naddressing mode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLD1 (multiple single elements)",
        "templates": {
          "A1": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A2": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A3": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A4": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T2": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T3": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T4": [
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VLD2_1": {
        "authored": "Load single 2-element structure to one lane of two registers loads one 2-element\nstructure from memory into corresponding elements of two registers. Elements of\nthe registers that are not loaded are unchanged. For details of the addressing\nmode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLD2 (single 2-element structure to one lane)",
        "templates": {
          "A1": [
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A2": [
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A3": [
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T2": [
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T3": [
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VLD2_a": {
        "authored": "Load single 2-element structure and replicate to all lanes of two registers\nloads one 2-element structure from memory into all lanes of two registers. For\ndetails of the addressing mode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLD2 (single 2-element structure to all lanes)",
        "templates": {
          "A1": [
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}],<Rm>"
          ],
          "T1": [
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VLD2_m": {
        "authored": "Load multiple 2-element structures to two or four registers loads multiple\n2-element structures from memory into two or four registers, with de-\ninterleaving. For more information, see Element and structure load/store\ninstructions.  Every element of each register is loaded. For details of the\naddressing mode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLD2 (multiple 2-element structures)",
        "templates": {
          "A1": [
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A2": [
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T2": [
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VLD3_1": {
        "authored": "Load single 3-element structure to one lane of three registers loads one\n3-element structure from memory into corresponding elements of three registers.\nElements of the registers that are not loaded are unchanged. For details of the\naddressing mode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLD3 (single 3-element structure to one lane)",
        "templates": {
          "A1": [
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ],
          "A2": [
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ],
          "A3": [
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ],
          "T1": [
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ],
          "T2": [
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ],
          "T3": [
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ]
        }
      },
      "VLD3_a": {
        "authored": "Load single 3-element structure and replicate to all lanes of three registers\nloads one 3-element structure from memory into all lanes of three registers. For\ndetails of the addressing mode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLD3 (single 3-element structure to all lanes)",
        "templates": {
          "A1": [
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ],
          "T1": [
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ]
        }
      },
      "VLD3_m": {
        "authored": "Load multiple 3-element structures to three registers loads multiple 3-element\nstructures from memory into three registers, with de-interleaving. For more\ninformation, see Element and structure load/store instructions. Every element of\neach register is loaded. For details of the addressing mode see Advanced SIMD\naddressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLD3 (multiple 3-element structures)",
        "templates": {
          "A1": [
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VLD4_1": {
        "authored": "Load single 4-element structure to one lane of four registers loads one\n4-element structure from memory into corresponding elements of four registers.\nElements of the registers that are not loaded are unchanged. For details of the\naddressing mode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLD4 (single 4-element structure to one lane)",
        "templates": {
          "A1": [
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A2": [
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A3": [
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T2": [
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T3": [
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VLD4_a": {
        "authored": "Load single 4-element structure and replicate to all lanes of four registers\nloads one 4-element structure from memory into all lanes of four registers. For\ndetails of the addressing mode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLD4 (single 4-element structure to all lanes)",
        "templates": {
          "A1": [
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}],<Rm>"
          ],
          "T1": [
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VLD4_m": {
        "authored": "Load multiple 4-element structures to four registers loads multiple 4-element\nstructures from memory into four registers, with de-interleaving. For more\ninformation, see Element and structure load/store instructions. Every element of\neach register is loaded. For details of the addressing mode see Advanced SIMD\naddressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLD4 (multiple 4-element structures)",
        "templates": {
          "A1": [
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VLD4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VLDM": {
        "authored": "Load Multiple SIMD&FP registers loads multiple registers from consecutive\nlocations in the Advanced SIMD and floating-point register file using an address\nfrom a general-purpose register.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VLDM, VLDMDB, VLDMIA",
        "templates": {
          "A1": [
            "VLDMDB{<c>}{<q>}{.<size>} <Rn>!, <dreglist>",
            "VLDM{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>",
            "VLDMIA{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>"
          ],
          "A2": [
            "VLDMDB{<c>}{<q>}{.<size>} <Rn>!, <sreglist>",
            "VLDM{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>",
            "VLDMIA{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>"
          ],
          "T1": [
            "VLDMDB{<c>}{<q>}{.<size>} <Rn>!, <dreglist>",
            "VLDM{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>",
            "VLDMIA{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>"
          ],
          "T2": [
            "VLDMDB{<c>}{<q>}{.<size>} <Rn>!, <sreglist>",
            "VLDM{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>",
            "VLDMIA{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>"
          ]
        }
      },
      "VLDR_i": {
        "authored": "Load SIMD&FP register (immediate) loads a single register from the Advanced SIMD\nand floating-point register file, using an address from a general-purpose\nregister, with an optional offset.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VLDR (immediate)",
        "templates": {
          "A1": [
            "VLDR{<c>}{<q>}.16 <Sd>, [<Rn> {, #{+/-}<imm>}]",
            "VLDR{<c>}{<q>}{.32} <Sd>, [<Rn> {, #{+/-}<imm>}]",
            "VLDR{<c>}{<q>}{.64} <Dd>, [<Rn> {, #{+/-}<imm>}]"
          ],
          "T1": [
            "VLDR{<c>}{<q>}.16 <Sd>, [<Rn> {, #{+/-}<imm>}]",
            "VLDR{<c>}{<q>}{.32} <Sd>, [<Rn> {, #{+/-}<imm>}]",
            "VLDR{<c>}{<q>}{.64} <Dd>, [<Rn> {, #{+/-}<imm>}]"
          ]
        }
      },
      "VLDR_l": {
        "authored": "Load SIMD&FP register (literal) loads a single register from the Advanced SIMD\nand floating-point register file, using an address from the PC value and an\nimmediate offset.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VLDR (literal)",
        "templates": {
          "A1": [
            "VLDR{<c>}{<q>}.16 <Sd>, <label>",
            "VLDR{<c>}{<q>}.16 <Sd>, [PC, #{+/-}<imm>]",
            "VLDR{<c>}{<q>}{.32} <Sd>, <label>",
            "VLDR{<c>}{<q>}{.32} <Sd>, [PC, #{+/-}<imm>]",
            "VLDR{<c>}{<q>}{.64} <Dd>, <label>",
            "VLDR{<c>}{<q>}{.64} <Dd>, [PC, #{+/-}<imm>]"
          ],
          "T1": [
            "VLDR{<c>}{<q>}.16 <Sd>, <label>",
            "VLDR{<c>}{<q>}.16 <Sd>, [PC, #{+/-}<imm>]",
            "VLDR{<c>}{<q>}{.32} <Sd>, <label>",
            "VLDR{<c>}{<q>}{.32} <Sd>, [PC, #{+/-}<imm>]",
            "VLDR{<c>}{<q>}{.64} <Dd>, <label>",
            "VLDR{<c>}{<q>}{.64} <Dd>, [PC, #{+/-}<imm>]"
          ]
        }
      },
      "VMAXNM": {
        "authored": "This instruction determines the floating-point maximum number.\n\nIt handles NaNs in consistence with the IEEE754-2008 specification. It returns\nthe numerical operand when one operand is numerical and the other is a quiet\nNaN, but otherwise the result is identical to floating-point VMAX.\n\nThis instruction is not conditional.",
        "heading": "VMAXNM",
        "templates": {
          "A1": [
            "VMAXNM{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VMAXNM{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "A2": [
            "VMAXNM{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VMAXNM{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VMAXNM{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VMAXNM{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VMAXNM{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "T2": [
            "VMAXNM{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VMAXNM{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VMAXNM{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "VMAX_f": {
        "authored": "Vector Maximum compares corresponding elements in two vectors, and copies the\nlarger of each pair into the corresponding element in the destination vector.\n\nThe operand vector elements are floating-point numbers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMAX (floating-point)",
        "templates": {
          "A1": [
            "VMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VMAX{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VMAX{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VMAX_i": {
        "authored": "Vector Maximum compares corresponding elements in two vectors, and copies the\nlarger of each pair into the corresponding element in the destination vector.\n\nThe operand vector elements can be any one of:\n  - 8-bit, 16-bit, or 32-bit signed integers.\n  - 8-bit, 16-bit, or 32-bit unsigned integers.\n\nThe result vector elements are the same size as the operand vector elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMAX (integer)",
        "templates": {
          "A1": [
            "VMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VMAX{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VMAX{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VMINNM": {
        "authored": "This instruction determines the floating point minimum number.\n\nIt handles NaNs in consistence with the IEEE754-2008 specification. It returns\nthe numerical operand when one operand is numerical and the other is a quiet\nNaN, but otherwise the result is identical to floating-point VMIN.\n\nThis instruction is not conditional.",
        "heading": "VMINNM",
        "templates": {
          "A1": [
            "VMINNM{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VMINNM{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "A2": [
            "VMINNM{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VMINNM{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VMINNM{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VMINNM{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VMINNM{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "T2": [
            "VMINNM{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VMINNM{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VMINNM{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "VMIN_f": {
        "authored": "Vector Minimum compares corresponding elements in two vectors, and copies the\nsmaller of each pair into the corresponding element in the destination vector.\n\nThe operand vector elements are floating-point numbers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMIN (floating-point)",
        "templates": {
          "A1": [
            "VMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VMIN{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VMIN{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VMIN_i": {
        "authored": "Vector Minimum compares corresponding elements in two vectors, and copies the\nsmaller of each pair into the corresponding element in the destination vector.\n\nThe operand vector elements can be any one of:\n  - 8-bit, 16-bit, or 32-bit signed integers.\n  - 8-bit, 16-bit, or 32-bit unsigned integers.\n\nThe result vector elements are the same size as the operand vector elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMIN (integer)",
        "templates": {
          "A1": [
            "VMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VMIN{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VMIN{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VMLAL_i": {
        "authored": "Vector Multiply Accumulate Long multiplies corresponding elements in two\nvectors, and add the products to the corresponding element of the destination\nvector. The destination vector element is twice as long as the elements that are\nmultiplied.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMLAL (integer)",
        "templates": {
          "A1": [
            "VMLAL{<c>}{<q>}.<type><size> <Qd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VMLAL{<c>}{<q>}.<type><size> <Qd>, <Dn>, <Dm>"
          ]
        }
      },
      "VMLAL_s": {
        "authored": "Vector Multiply Accumulate Long multiplies elements of a vector by a scalar, and\nadds the products to corresponding elements of the destination vector. The\ndestination vector elements are twice as long as the elements that are\nmultiplied.\n\nFor more information about scalars see Advanced SIMD scalars.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMLAL (by scalar)",
        "templates": {
          "A1": [
            "VMLAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>"
          ],
          "T1": [
            "VMLAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>"
          ]
        }
      },
      "VMLA_f": {
        "authored": "Vector Multiply Accumulate multiplies corresponding elements in two vectors, and\naccumulates the results into the elements of the destination vector.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VMLA (floating-point)",
        "templates": {
          "A1": [
            "VMLA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VMLA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "A2": [
            "VMLA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VMLA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VMLA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VMLA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VMLA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "T2": [
            "VMLA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VMLA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VMLA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "VMLA_i": {
        "authored": "Vector Multiply Accumulate multiplies corresponding elements in two vectors, and\nadds the products to the corresponding elements of the destination vector.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMLA (integer)",
        "templates": {
          "A1": [
            "VMLA{<c>}{<q>}.<type><size> <Dd>, <Dn>, <Dm>",
            "VMLA{<c>}{<q>}.<type><size> <Qd>, <Qn>, <Qm>"
          ],
          "T1": [
            "VMLA{<c>}{<q>}.<type><size> <Dd>, <Dn>, <Dm>",
            "VMLA{<c>}{<q>}.<type><size> <Qd>, <Qn>, <Qm>"
          ]
        }
      },
      "VMLA_s": {
        "authored": "Vector Multiply Accumulate multiplies elements of a vector by a scalar, and adds\nthe products to corresponding elements of the destination vector.\n\nFor more information about scalars see Advanced SIMD scalars.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMLA (by scalar)",
        "templates": {
          "A1": [
            "VMLA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>",
            "VMLA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>"
          ],
          "T1": [
            "VMLA{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>",
            "VMLA{<c>}{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>"
          ]
        }
      },
      "VMLSL_i": {
        "authored": "Vector Multiply Subtract Long multiplies corresponding elements in two vectors,\nand subtract the products from the corresponding elements of the destination\nvector. The destination vector element is twice as long as the elements that are\nmultiplied.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMLSL (integer)",
        "templates": {
          "A1": [
            "VMLSL{<c>}{<q>}.<type><size> <Qd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VMLSL{<c>}{<q>}.<type><size> <Qd>, <Dn>, <Dm>"
          ]
        }
      },
      "VMLSL_s": {
        "authored": "Vector Multiply Subtract Long multiplies elements of a vector by a scalar, and\nsubtracts the products from corresponding elements of the destination vector.\nThe destination vector elements are twice as long as the elements that are\nmultiplied.\n\nFor more information about scalars see Advanced SIMD scalars.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMLSL (by scalar)",
        "templates": {
          "A1": [
            "VMLSL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>"
          ],
          "T1": [
            "VMLSL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>"
          ]
        }
      },
      "VMLS_f": {
        "authored": "Vector Multiply Subtract multiplies corresponding elements in two vectors,\nsubtracts the products from corresponding elements of the destination vector,\nand places the results in the destination vector.\n\nARM recommends that software does not use the VMLS instruction in the Round\ntowards Plus Infinity and Round towards Minus Infinity rounding modes, because\nthe rounding of the product and of the sum can change the result of the\ninstruction in opposite directions, defeating the purpose of these rounding\nmodes.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VMLS (floating-point)",
        "templates": {
          "A1": [
            "VMLS{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VMLS{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "A2": [
            "VMLS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VMLS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VMLS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VMLS{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VMLS{<c>}{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "T2": [
            "VMLS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VMLS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VMLS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "VMLS_i": {
        "authored": "Vector Multiply Subtract multiplies corresponding elements in two vectors, and\nsubtracts the products from the corresponding elements of the destination\nvector.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMLS (integer)",
        "templates": {
          "A1": [
            "VMLS{<c>}{<q>}.<type><size> <Dd>, <Dn>, <Dm>",
            "VMLS{<c>}{<q>}.<type><size> <Qd>, <Qn>, <Qm>"
          ],
          "T1": [
            "VMLS{<c>}{<q>}.<type><size> <Dd>, <Dn>, <Dm>",
            "VMLS{<c>}{<q>}.<type><size> <Qd>, <Qn>, <Qm>"
          ]
        }
      },
      "VMLS_s": {
        "authored": "Vector Multiply Subtract multiplies elements of a vector by a scalar, and either\nsubtracts the products from corresponding elements of the destination vector.\n\nFor more information about scalars see Advanced SIMD scalars.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMLS (by scalar)",
        "templates": {
          "A1": [
            "VMLS{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>",
            "VMLS{<c>}{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>"
          ],
          "T1": [
            "VMLS{<c>}{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>",
            "VMLS{<c>}{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>"
          ]
        }
      },
      "VMOVL": {
        "authored": "Vector Move Long takes each element in a doubleword vector, sign or zero-extends\nthem to twice their original length, and places the results in a quadword\nvector.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMOVL",
        "templates": {
          "A1": [
            "VMOVL{<c>}{<q>}.<dt> <Qd>, <Dm>"
          ],
          "T1": [
            "VMOVL{<c>}{<q>}.<dt> <Qd>, <Dm>"
          ]
        }
      },
      "VMOVN": {
        "authored": "Vector Move and Narrow copies the least significant half of each element of a\nquadword vector into the corresponding elements of a doubleword vector.\n\nThe operand vector elements can be any one of 16-bit, 32-bit, or 64-bit\nintegers. There is no distinction between signed and unsigned integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMOVN",
        "templates": {
          "A1": [
            "VMOVN{<c>}{<q>}.<dt> <Dd>, <Qm>"
          ],
          "T1": [
            "VMOVN{<c>}{<q>}.<dt> <Dd>, <Qm>"
          ]
        }
      },
      "VMOVX": {
        "authored": "Vector Move extraction. This instruction copies the upper 16 bits of the 32-bit\nsource SIMD&FP register into the lower 16 bits of the 32-bit destination SIMD&FP\nregister, while clearing the remaining bits to zero.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VMOVX",
        "templates": {
          "A1": [
            "VMOVX{<q>}.F16 <Sd>, <Sm>"
          ],
          "T1": [
            "VMOVX{<q>}.F16 <Sd>, <Sm>"
          ]
        }
      },
      "VMOV_VORR_r": {
        "authored": " copies the contents of one SIMD register to another",
        "heading": "VMOV (register, SIMD)",
        "templates": {
          "A1": [
            "VMOV{<c>}{<q>}{.<dt>} <Dd>, <Dm>",
            "VMOV{<c>}{<q>}{.<dt>} <Qd>, <Qm>"
          ],
          "T1": [
            "VMOV{<c>}{<q>}{.<dt>} <Dd>, <Dm>",
            "VMOV{<c>}{<q>}{.<dt>} <Qd>, <Qm>"
          ]
        }
      },
      "VMOV_d": {
        "authored": "Copy two general-purpose registers to or from a SIMD&FP register copies two\nwords from two general-purpose registers into a doubleword register in the\nAdvanced SIMD and floating-point register file, or from a doubleword register in\nthe Advanced SIMD and floating-point register file to two general-purpose\nregisters.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VMOV (between two general-purpose registers and a doubleword floating-point register)",
        "templates": {
          "A1": [
            "VMOV{<c>}{<q>} <Dm>, <Rt>, <Rt2>",
            "VMOV{<c>}{<q>} <Rt>, <Rt2>, <Dm>"
          ],
          "T1": [
            "VMOV{<c>}{<q>} <Dm>, <Rt>, <Rt2>",
            "VMOV{<c>}{<q>} <Rt>, <Rt2>, <Dm>"
          ]
        }
      },
      "VMOV_h": {
        "authored": "Copy 16 bits of a general-purpose register to or from a 32-bit SIMD&FP register.\nThis instruction transfers the value held in the bottom 16 bits of a 32-bit\nSIMD&FP register to the bottom 16 bits of a general-purpose register, or the\nvalue held in the bottom 16 bits of a general-purpose register to the bottom 16\nbits of a 32-bit SIMD&FP register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VMOV (between general-purpose register and half-precision)",
        "templates": {
          "A1": [
            "VMOV{<c>}{<q>}.F16 <Sn>, <Rt>",
            "VMOV{<c>}{<q>}.F16 <Rt>, <Sn>"
          ],
          "T1": [
            "VMOV{<c>}{<q>}.F16 <Sn>, <Rt>",
            "VMOV{<c>}{<q>}.F16 <Rt>, <Sn>"
          ]
        }
      },
      "VMOV_i": {
        "authored": "Copy immediate value to a SIMD&FP register places an immediate constant into\nevery element of the destination register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode.  For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VMOV (immediate)",
        "templates": {
          "A1": [
            "VMOV{<c>}{<q>}.I32 <Dd>, #<imm>",
            "VMOV{<c>}{<q>}.I32 <Qd>, #<imm>"
          ],
          "A2": [
            "VMOV{<c>}{<q>}.F16 <Sd>, #<imm>",
            "VMOV{<c>}{<q>}.F32 <Sd>, #<imm>",
            "VMOV{<c>}{<q>}.F64 <Dd>, #<imm>"
          ],
          "A3": [
            "VMOV{<c>}{<q>}.I16 <Dd>, #<imm>",
            "VMOV{<c>}{<q>}.I16 <Qd>, #<imm>"
          ],
          "A4": [
            "VMOV{<c>}{<q>}.<dt> <Dd>, #<imm>",
            "VMOV{<c>}{<q>}.<dt> <Qd>, #<imm>"
          ],
          "A5": [
            "VMOV{<c>}{<q>}.I64 <Dd>, #<imm>",
            "VMOV{<c>}{<q>}.I64 <Qd>, #<imm>"
          ],
          "T1": [
            "VMOV{<c>}{<q>}.I32 <Dd>, #<imm>",
            "VMOV{<c>}{<q>}.I32 <Qd>, #<imm>"
          ],
          "T2": [
            "VMOV{<c>}{<q>}.F16 <Sd>, #<imm>",
            "VMOV{<c>}{<q>}.F32 <Sd>, #<imm>",
            "VMOV{<c>}{<q>}.F64 <Dd>, #<imm>"
          ],
          "T3": [
            "VMOV{<c>}{<q>}.I16 <Dd>, #<imm>",
            "VMOV{<c>}{<q>}.I16 <Qd>, #<imm>"
          ],
          "T4": [
            "VMOV{<c>}{<q>}.<dt> <Dd>, #<imm>",
            "VMOV{<c>}{<q>}.<dt> <Qd>, #<imm>"
          ],
          "T5": [
            "VMOV{<c>}{<q>}.I64 <Dd>, #<imm>",
            "VMOV{<c>}{<q>}.I64 <Qd>, #<imm>"
          ]
        }
      },
      "VMOV_r": {
        "authored": "Copy between FP registers copies the contents of one FP register to another.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VMOV (register)",
        "templates": {
          "A2": [
            "VMOV{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VMOV{<c>}{<q>}.F64 <Dd>, <Dm>"
          ],
          "T2": [
            "VMOV{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VMOV{<c>}{<q>}.F64 <Dd>, <Dm>"
          ]
        }
      },
      "VMOV_rs": {
        "authored": "Copy a general-purpose register to a vector element copies a byte, halfword, or\nword from a general-purpose register into an Advanced SIMD scalar.\n\nOn a Floating-point-only system, this instruction transfers one word to the\nupper or lower half of a double-precision floating-point register from a\ngeneral-purpose register. This is an identical operation to the Advanced SIMD\nsingle word transfer.\n\nFor more information about scalars see Advanced SIMD scalars.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VMOV (general-purpose register to scalar)",
        "templates": {
          "A1": [
            "VMOV{<c>}{<q>}{.<size>} <Dd[x]>, <Rt>"
          ],
          "T1": [
            "VMOV{<c>}{<q>}{.<size>} <Dd[x]>, <Rt>"
          ]
        }
      },
      "VMOV_s": {
        "authored": "Copy a general-purpose register to or from a 32-bit SIMD&FP register. This\ninstruction transfers the value held in a 32-bit SIMD&FP register to a general-\npurpose register, or the value held in a general-purpose register to a 32-bit\nSIMD&FP register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VMOV (between general-purpose register and single-precision)",
        "templates": {
          "A1": [
            "VMOV{<c>}{<q>} <Sn>, <Rt>",
            "VMOV{<c>}{<q>} <Rt>, <Sn>"
          ],
          "T1": [
            "VMOV{<c>}{<q>} <Sn>, <Rt>",
            "VMOV{<c>}{<q>} <Rt>, <Sn>"
          ]
        }
      },
      "VMOV_sr": {
        "authored": "Copy a vector element to a general-purpose register with sign or zero extension\ncopies a byte, halfword, or word from an Advanced SIMD scalar to a general-\npurpose register. Bytes and halfwords can be either zero-extended or sign-\nextended.\n\nOn a Floating-point-only system, this instruction transfers one word from the\nupper or lower half of a double-precision floating-point register to a general-\npurpose register. This is an identical operation to the Advanced SIMD single\nword transfer.\n\nFor more information about scalars see Advanced SIMD scalars.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VMOV (scalar to general-purpose register)",
        "templates": {
          "A1": [
            "VMOV{<c>}{<q>}{.<dt>} <Rt>, <Dn[x]>"
          ],
          "T1": [
            "VMOV{<c>}{<q>}{.<dt>} <Rt>, <Dn[x]>"
          ]
        }
      },
      "VMOV_ss": {
        "authored": "Copy two general-purpose registers to a pair of 32-bit SIMD&FP registers\ntransfers the contents of two consecutively numbered single-precision Floating-\npoint registers to two general-purpose registers, or the contents of two\ngeneral-purpose registers to a pair of single-precision Floating-point\nregisters. The general-purpose registers do not have to be contiguous.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VMOV (between two general-purpose registers and two single-precision registers)",
        "templates": {
          "A1": [
            "VMOV{<c>}{<q>} <Sm>, <Sm1>, <Rt>, <Rt2>",
            "VMOV{<c>}{<q>} <Rt>, <Rt2>, <Sm>, <Sm1>"
          ],
          "T1": [
            "VMOV{<c>}{<q>} <Sm>, <Sm1>, <Rt>, <Rt2>",
            "VMOV{<c>}{<q>} <Rt>, <Rt2>, <Sm>, <Sm1>"
          ]
        }
      },
      "VMRS": {
        "authored": "Move SIMD&FP Special register to general-purpose register moves the value of an\nAdvanced SIMD and floating-point System register to a general-purpose register.\nWhen the specified System register is the FPSCR, a form of the instruction\ntransfers the FPSCR.{N, Z, C, V} condition flags to the APSR.{N, Z, C, V}\ncondition flags.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.\n\nWhen these settings permit the execution of floating-point and Advanced SIMD\ninstructions, if the specified floating-point System register is not the FPSCR,\nthe instruction is undefined if executed in User mode.\n\nIn an implementation that includes EL2, when HCR.TID0 is set to 1, any VMRS\naccess to FPSID from a Non-secure EL1 mode that would be permitted if HCR.TID0\nwas set to 0 generates a Hyp Trap exception. For more information, see ID group\n0, Primary device identification registers.\n\nFor simplicity, the VMRS pseudocode does not show the possible trap to Hyp mode.",
        "heading": "VMRS",
        "templates": {
          "A1": [
            "VMRS{<c>}{<q>} <Rt>, <spec_reg>"
          ],
          "T1": [
            "VMRS{<c>}{<q>} <Rt>, <spec_reg>"
          ]
        }
      },
      "VMSR": {
        "authored": "Move general-purpose register to SIMD&FP Special register moves the value of a\ngeneral-purpose register to a floating-point System register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.\n\nWhen these settings permit the execution of floating-point and Advanced SIMD\ninstructions:\n  - If the specified floating-point System register is not the FPSCR, the\ninstruction is undefined if executed in User mode.\n  - If the specified floating-point System register is the FPSID and the\ninstruction is executed in a mode other than User mode the instruction is\nignored.",
        "heading": "VMSR",
        "templates": {
          "A1": [
            "VMSR{<c>}{<q>} <spec_reg>, <Rt>"
          ],
          "T1": [
            "VMSR{<c>}{<q>} <spec_reg>, <Rt>"
          ]
        }
      },
      "VMULL_i": {
        "authored": "Vector Multiply Long multiplies corresponding elements in two vectors. The\ndestination vector elements are twice as long as the elements that are\nmultiplied.\n\nFor information about multiplying polynomials see Polynomial arithmetic over {0,\n1}.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMULL (integer and polynomial)",
        "templates": {
          "A1": [
            "VMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ]
        }
      },
      "VMULL_s": {
        "authored": "Vector Multiply Long multiplies each element in a vector by a scalar, and places\nthe results in a second vector. The destination vector elements are twice as\nlong as the elements that are multiplied.\n\nFor more information about scalars see Advanced SIMD scalars.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMULL (by scalar)",
        "templates": {
          "A1": [
            "VMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>[<index>]"
          ],
          "T1": [
            "VMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>[<index>]"
          ]
        }
      },
      "VMUL_f": {
        "authored": "Vector Multiply multiplies corresponding elements in two vectors, and places the\nresults in the destination vector.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VMUL (floating-point)",
        "templates": {
          "A1": [
            "VMUL{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VMUL{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "A2": [
            "VMUL{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>",
            "VMUL{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>",
            "VMUL{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>"
          ],
          "T1": [
            "VMUL{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VMUL{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T2": [
            "VMUL{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>",
            "VMUL{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>",
            "VMUL{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>"
          ]
        }
      },
      "VMUL_i": {
        "authored": "Vector Multiply multiplies corresponding elements in two vectors.\n\nFor information about multiplying polynomials see Polynomial arithmetic over {0,\n1}.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMUL (integer and polynomial)",
        "templates": {
          "A1": [
            "VMUL{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VMUL{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VMUL{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VMUL{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VMUL_s": {
        "authored": "Vector Multiply multiplies each element in a vector by a scalar, and places the\nresults in a second vector.\n\nFor more information about scalars see Advanced SIMD scalars.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMUL (by scalar)",
        "templates": {
          "A1": [
            "VMUL{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>[<index>]",
            "VMUL{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm>[<index>]"
          ],
          "T1": [
            "VMUL{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>[<index>]",
            "VMUL{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm>[<index>]"
          ]
        }
      },
      "VMVN_i": {
        "authored": "Vector Bitwise NOT (immediate) places the bitwise inverse of an immediate\ninteger constant into every element of the destination register.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMVN (immediate)",
        "templates": {
          "A1": [
            "VMVN{<c>}{<q>}.I32 <Dd>, #<imm>",
            "VMVN{<c>}{<q>}.I32 <Qd>, #<imm>"
          ],
          "A2": [
            "VMVN{<c>}{<q>}.I16 <Dd>, #<imm>",
            "VMVN{<c>}{<q>}.I16 <Qd>, #<imm>"
          ],
          "A3": [
            "VMVN{<c>}{<q>}.I32 <Dd>, #<imm>",
            "VMVN{<c>}{<q>}.I32 <Qd>, #<imm>"
          ],
          "T1": [
            "VMVN{<c>}{<q>}.I32 <Dd>, #<imm>",
            "VMVN{<c>}{<q>}.I32 <Qd>, #<imm>"
          ],
          "T2": [
            "VMVN{<c>}{<q>}.I16 <Dd>, #<imm>",
            "VMVN{<c>}{<q>}.I16 <Qd>, #<imm>"
          ],
          "T3": [
            "VMVN{<c>}{<q>}.I32 <Dd>, #<imm>",
            "VMVN{<c>}{<q>}.I32 <Qd>, #<imm>"
          ]
        }
      },
      "VMVN_r": {
        "authored": "Vector Bitwise NOT (register) takes a value from a register, inverts the value\nof each bit, and places the result in the destination register. The registers\ncan be either doubleword or quadword.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VMVN (register)",
        "templates": {
          "A1": [
            "VMVN{<c>}{<q>}{.<dt>} <Dd>, <Dm>",
            "VMVN{<c>}{<q>}{.<dt>} <Qd>, <Qm>"
          ],
          "T1": [
            "VMVN{<c>}{<q>}{.<dt>} <Dd>, <Dm>",
            "VMVN{<c>}{<q>}{.<dt>} <Qd>, <Qm>"
          ]
        }
      },
      "VNEG": {
        "authored": "Vector Negate negates each element in a vector, and places the results in a\nsecond vector. The floating-point version only inverts the sign bit.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VNEG",
        "templates": {
          "A1": [
            "VNEG{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VNEG{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "A2": [
            "VNEG{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VNEG{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VNEG{<c>}{<q>}.F64 <Dd>, <Dm>"
          ],
          "T1": [
            "VNEG{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VNEG{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T2": [
            "VNEG{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VNEG{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VNEG{<c>}{<q>}.F64 <Dd>, <Dm>"
          ]
        }
      },
      "VNMLA": {
        "authored": "Vector Negate Multiply Accumulate multiplies together two floating-point\nregister values, adds the negation of the floating-point value in the\ndestination register to the negation of the product, and writes the result back\nto the destination register.\n\nARM recommends that software does not use the VNMLA instruction in the Round\ntowards Plus Infinity and Round towards Minus Infinity rounding modes, because\nthe rounding of the product and of the sum can change the result of the\ninstruction in opposite directions, defeating the purpose of these rounding\nmodes.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VNMLA",
        "templates": {
          "A1": [
            "VNMLA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VNMLA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VNMLA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VNMLA{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VNMLA{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VNMLA{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "VNMLS": {
        "authored": "Vector Negate Multiply Subtract multiplies together two floating-point register\nvalues, adds the negation of the floating-point value in the destination\nregister to the product, and writes the result back to the destination register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VNMLS",
        "templates": {
          "A1": [
            "VNMLS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VNMLS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VNMLS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VNMLS{<c>}{<q>}.F16 <Sd>, <Sn>, <Sm>",
            "VNMLS{<c>}{<q>}.F32 <Sd>, <Sn>, <Sm>",
            "VNMLS{<c>}{<q>}.F64 <Dd>, <Dn>, <Dm>"
          ]
        }
      },
      "VNMUL": {
        "authored": "Vector Negate Multiply multiplies together two floating-point register values,\nand writes the negation of the result to the destination register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VNMUL",
        "templates": {
          "A1": [
            "VNMUL{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>",
            "VNMUL{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>",
            "VNMUL{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>"
          ],
          "T1": [
            "VNMUL{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>",
            "VNMUL{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>",
            "VNMUL{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>"
          ]
        }
      },
      "VORN_VORR_i": {
        "authored": " performs a bitwise OR between a register value and the complement of an\nimmediate value, and returns the result into the destination vector",
        "heading": "VORN (immediate)",
        "templates": {
          "A1": [
            "VORN{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>",
            "VORN{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>"
          ],
          "A2": [
            "VORN{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>",
            "VORN{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>"
          ],
          "T1": [
            "VORN{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>",
            "VORN{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>"
          ],
          "T2": [
            "VORN{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>",
            "VORN{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>"
          ]
        }
      },
      "VORN_r": {
        "authored": "Vector bitwise OR NOT (register) performs a bitwise OR NOT operation between two\nregisters, and places the result in the destination register.  The operand and\nresult registers can be quadword or doubleword.  They must all be the same size.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VORN (register)",
        "templates": {
          "A1": [
            "VORN{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VORN{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ],
          "T1": [
            "VORN{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VORN{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ]
        }
      },
      "VORR_i": {
        "authored": "Vector Bitwise OR (immediate) performs a bitwise OR between a register value and\nan immediate value, and returns the result into the destination vector.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VORR (immediate)",
        "templates": {
          "A1": [
            "VORR{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>",
            "VORR{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>"
          ],
          "A2": [
            "VORR{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>",
            "VORR{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>"
          ],
          "T1": [
            "VORR{<c>}{<q>}.I32 {<Dd>,} <Dd>, #<imm>",
            "VORR{<c>}{<q>}.I32 {<Qd>,} <Qd>, #<imm>"
          ],
          "T2": [
            "VORR{<c>}{<q>}.I16 {<Dd>,} <Dd>, #<imm>",
            "VORR{<c>}{<q>}.I16 {<Qd>,} <Qd>, #<imm>"
          ]
        }
      },
      "VORR_r": {
        "authored": "Vector bitwise OR (register) performs a bitwise OR operation between two\nregisters, and places the result in the destination register. The operand and\nresult registers can be quadword or doubleword. They must all be the same size.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VORR (register)",
        "templates": {
          "A1": [
            "VORR{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VORR{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ],
          "T1": [
            "VORR{<c>}{<q>}{.<dt>} {<Dd>,} <Dn>, <Dm>",
            "VORR{<c>}{<q>}{.<dt>} {<Qd>,} <Qn>, <Qm>"
          ]
        }
      },
      "VPADAL": {
        "authored": "Vector Pairwise Add and Accumulate Long adds adjacent pairs of elements of a\nvector, and accumulates the results into the elements of the destination vector.\n\nThe vectors can be doubleword or quadword. The operand elements can be 8-bit,\n16-bit, or 32-bit integers. The result elements are twice the length of the\noperand elements.\n\n\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VPADAL",
        "templates": {
          "A1": [
            "VPADAL{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VPADAL{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VPADAL{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VPADAL{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VPADDL": {
        "authored": "Vector Pairwise Add Long adds adjacent pairs of elements of two vectors, and\nplaces the results in the destination vector.\n\nThe vectors can be doubleword or quadword. The operand elements can be 8-bit,\n16-bit, or 32-bit integers. The result elements are twice the length of the\noperand elements.\n\n\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VPADDL",
        "templates": {
          "A1": [
            "VPADDL{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VPADDL{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VPADDL{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VPADDL{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VPADD_f": {
        "authored": "Vector Pairwise Add (floating-point) adds adjacent pairs of elements of two\nvectors, and places the results in the destination vector.\n\nThe operands and result are doubleword vectors.\n\nThe operand and result elements are floating-point numbers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VPADD (floating-point)",
        "templates": {
          "A1": [
            "VPADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>"
          ],
          "T1": [
            "VPADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>"
          ]
        }
      },
      "VPADD_i": {
        "authored": "Vector Pairwise Add (integer) adds adjacent pairs of elements of two vectors,\nand places the results in the destination vector.\n\nThe operands and result are doubleword vectors.\n\nThe operand and result elements must all be the same type, and can be 8-bit,\n16-bit, or 32-bit integers. There is no distinction between signed and unsigned\nintegers.\n\n\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VPADD (integer)",
        "templates": {
          "A1": [
            "VPADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>"
          ],
          "T1": [
            "VPADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>"
          ]
        }
      },
      "VPMAX_f": {
        "authored": "Vector Pairwise Maximum compares adjacent pairs of elements in two doubleword\nvectors, and copies the larger of each pair into the corresponding element in\nthe destination doubleword vector.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VPMAX (floating-point)",
        "templates": {
          "A1": [
            "VPMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>"
          ],
          "T1": [
            "VPMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>"
          ]
        }
      },
      "VPMAX_i": {
        "authored": "Vector Pairwise Maximum compares adjacent pairs of elements in two doubleword\nvectors, and copies the larger of each pair into the corresponding element in\nthe destination doubleword vector.\n\n\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VPMAX (integer)",
        "templates": {
          "A1": [
            "VPMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>"
          ],
          "T1": [
            "VPMAX{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>"
          ]
        }
      },
      "VPMIN_f": {
        "authored": "Vector Pairwise Minimum compares adjacent pairs of elements in two doubleword\nvectors, and copies the smaller of each pair into the corresponding element in\nthe destination doubleword vector.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VPMIN (floating-point)",
        "templates": {
          "A1": [
            "VPMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>"
          ],
          "T1": [
            "VPMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>"
          ]
        }
      },
      "VPMIN_i": {
        "authored": "Vector Pairwise Minimum compares adjacent pairs of elements in two doubleword\nvectors, and copies the smaller of each pair into the corresponding element in\nthe destination doubleword vector.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VPMIN (integer)",
        "templates": {
          "A1": [
            "VPMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>"
          ],
          "T1": [
            "VPMIN{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>"
          ]
        }
      },
      "VPOP_VLDM": {
        "authored": " loads multiple consecutive Advanced SIMD and floating-point register file\nregisters from the stack",
        "heading": "VPOP",
        "templates": {
          "A1": [
            "VPOP{<c>}{<q>}{.<size>} <dreglist>"
          ],
          "A2": [
            "VPOP{<c>}{<q>}{.<size>} <sreglist>"
          ],
          "T1": [
            "VPOP{<c>}{<q>}{.<size>} <dreglist>"
          ],
          "T2": [
            "VPOP{<c>}{<q>}{.<size>} <sreglist>"
          ]
        }
      },
      "VPUSH_VSTM": {
        "authored": " stores multiple consecutive registers from the Advanced SIMD and floating-point\nregister file to the stack",
        "heading": "VPUSH",
        "templates": {
          "A1": [
            "VPUSH{<c>}{<q>}{.<size>} <dreglist>"
          ],
          "A2": [
            "VPUSH{<c>}{<q>}{.<size>} <sreglist>"
          ],
          "T1": [
            "VPUSH{<c>}{<q>}{.<size>} <dreglist>"
          ],
          "T2": [
            "VPUSH{<c>}{<q>}{.<size>} <sreglist>"
          ]
        }
      },
      "VQABS": {
        "authored": "Vector Saturating Absolute takes the absolute value of each element in a vector,\nand places the results in the destination vector.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQABS",
        "templates": {
          "A1": [
            "VQABS{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VQABS{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VQABS{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VQABS{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VQADD": {
        "authored": "Vector Saturating Add adds the values of corresponding elements of two vectors,\nand places the results in the destination vector.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQADD",
        "templates": {
          "A1": [
            "VQADD{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>",
            "VQADD{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>"
          ],
          "T1": [
            "VQADD{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>",
            "VQADD{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>"
          ]
        }
      },
      "VQDMLAL": {
        "authored": "Vector Saturating Doubling Multiply Accumulate Long multiplies corresponding\nelements in two doubleword vectors, doubles the products, and accumulates the\nresults into the elements of a quadword vector.\n\nThe second operand can be a scalar instead of a vector. For more information\nabout scalars see Advanced SIMD scalars.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQDMLAL",
        "templates": {
          "A1": [
            "VQDMLAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ],
          "A2": [
            "VQDMLAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>[<index>]"
          ],
          "T1": [
            "VQDMLAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ],
          "T2": [
            "VQDMLAL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>[<index>]"
          ]
        }
      },
      "VQDMLSL": {
        "authored": "Vector Saturating Doubling Multiply Subtract Long multiplies corresponding\nelements in two doubleword vectors, subtracts double the products from\ncorresponding elements of a quadword vector, and places the results in the same\nquadword vector.\n\nThe second operand can be a scalar instead of a vector. For more information\nabout scalars see Advanced SIMD scalars.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQDMLSL",
        "templates": {
          "A1": [
            "VQDMLSL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ],
          "A2": [
            "VQDMLSL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>[<index>]"
          ],
          "T1": [
            "VQDMLSL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ],
          "T2": [
            "VQDMLSL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>[<index>]"
          ]
        }
      },
      "VQDMULH": {
        "authored": "Vector Saturating Doubling Multiply Returning High Half multiplies corresponding\nelements in two vectors, doubles the results, and places the most significant\nhalf of the final results in the destination vector. The results are truncated,\nfor rounded results see VQRDMULH.\n\nThe second operand can be a scalar instead of a vector. For more information\nabout scalars see Advanced SIMD scalars.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQDMULH",
        "templates": {
          "A1": [
            "VQDMULH{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VQDMULH{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "A2": [
            "VQDMULH{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm[x]>",
            "VQDMULH{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm[x]>"
          ],
          "T1": [
            "VQDMULH{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VQDMULH{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T2": [
            "VQDMULH{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm[x]>",
            "VQDMULH{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm[x]>"
          ]
        }
      },
      "VQDMULL": {
        "authored": "Vector Saturating Doubling Multiply Long multiplies corresponding elements in\ntwo doubleword vectors, doubles the products, and places the results in a\nquadword vector.\n\nThe second operand can be a scalar instead of a vector. For more information\nabout scalars see Advanced SIMD scalars.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQDMULL",
        "templates": {
          "A1": [
            "VQDMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ],
          "A2": [
            "VQDMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>"
          ],
          "T1": [
            "VQDMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ],
          "T2": [
            "VQDMULL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm[x]>"
          ]
        }
      },
      "VQMOVN": {
        "authored": "Vector Saturating Move and Narrow copies each element of the operand vector to\nthe corresponding element of the destination vector.\n\nThe operand is a quadword vector. The elements can be any one of:\n  - 16-bit, 32-bit, or 64-bit signed integers.\n  - 16-bit, 32-bit, or 64-bit unsigned integers.\n\nThe result is a doubleword vector. The elements are half the length of the\noperand vector elements. If the operand is unsigned, the results are unsigned.\nIf the operand is signed, the results can be signed or unsigned.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQMOVN, VQMOVUN",
        "templates": {
          "A1": [
            "VQMOVN{<c>}{<q>}.<dt> <Dd>, <Qm>",
            "VQMOVUN{<c>}{<q>}.<dt> <Dd>, <Qm>"
          ],
          "T1": [
            "VQMOVN{<c>}{<q>}.<dt> <Dd>, <Qm>",
            "VQMOVUN{<c>}{<q>}.<dt> <Dd>, <Qm>"
          ]
        }
      },
      "VQNEG": {
        "authored": "Vector Saturating Negate negates each element in a vector, and places the\nresults in the destination vector.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQNEG",
        "templates": {
          "A1": [
            "VQNEG{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VQNEG{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VQNEG{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VQNEG{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VQRDMLAH": {
        "authored": "Vector Saturating Rounding Doubling Multiply Accumulate Returning High Half.\nThis instruction multiplies the vector elements of the first source SIMD&FP\nregister with either the corresponding vector elements of the second source\nSIMD&FP register or the value of a vector element of the second source SIMD&FP\nregister, without saturating the multiply results, doubles the results, and\naccumulates the most significant half of the final results with the vector\nelements of the destination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQRDMLAH",
        "templates": {
          "A1": [
            "VQRDMLAH{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VQRDMLAH{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "A2": [
            "VQRDMLAH{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>",
            "VQRDMLAH{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>"
          ],
          "T1": [
            "VQRDMLAH{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VQRDMLAH{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "T2": [
            "VQRDMLAH{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>",
            "VQRDMLAH{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>"
          ]
        }
      },
      "VQRDMLSH": {
        "authored": "Vector Saturating Rounding Doubling Multiply Subtract Returning High Half. This\ninstruction multiplies the vector elements of the first source SIMD&FP register\nwith either the corresponding vector elements of the second source SIMD&FP\nregister or the value of a vector element of the second source SIMD&FP register,\nwithout saturating the multiply results, doubles the results, and subtracts the\nmost significant half of the final results from the vector elements of the\ndestination SIMD&FP register. The results are rounded.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQRDMLSH",
        "templates": {
          "A1": [
            "VQRDMLSH{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VQRDMLSH{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "A2": [
            "VQRDMLSH{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>",
            "VQRDMLSH{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>"
          ],
          "T1": [
            "VQRDMLSH{<q>}.<dt> <Dd>, <Dn>, <Dm>",
            "VQRDMLSH{<q>}.<dt> <Qd>, <Qn>, <Qm>"
          ],
          "T2": [
            "VQRDMLSH{<q>}.<dt> <Dd>, <Dn>, <Dm[x]>",
            "VQRDMLSH{<q>}.<dt> <Qd>, <Qn>, <Dm[x]>"
          ]
        }
      },
      "VQRDMULH": {
        "authored": "Vector Saturating Rounding Doubling Multiply Returning High Half multiplies\ncorresponding elements in two vectors, doubles the results, and places the most\nsignificant half of the final results in the destination vector. The results are\nrounded. For truncated results see VQDMULH.\n\nThe second operand can be a scalar instead of a vector. For more information\nabout scalars see Advanced SIMD scalars.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQRDMULH",
        "templates": {
          "A1": [
            "VQRDMULH{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VQRDMULH{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "A2": [
            "VQRDMULH{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm[x]>",
            "VQRDMULH{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm[x]>"
          ],
          "T1": [
            "VQRDMULH{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VQRDMULH{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T2": [
            "VQRDMULH{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm[x]>",
            "VQRDMULH{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm[x]>"
          ]
        }
      },
      "VQRSHL": {
        "authored": "Vector Saturating Rounding Shift Left takes each element in a vector, shifts\nthem by a value from the least significant byte of the corresponding element of\na second vector, and places the results in the destination vector. If the shift\nvalue is positive, the operation is a left shift. Otherwise, it is a right\nshift.\n\nFor truncated results see VQSHL (register).\n\nThe first operand and result elements are the same data type, and can be any one\nof:\n  - 8-bit, 16-bit, 32-bit, or 64-bit signed integers.\n  - 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.\n\nThe second operand is a signed integer of the same size.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQRSHL",
        "templates": {
          "A1": [
            "VQRSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>",
            "VQRSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>"
          ],
          "T1": [
            "VQRSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>",
            "VQRSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>"
          ]
        }
      },
      "VQRSHRN": {
        "authored": "Vector Saturating Rounding Shift Right, Narrow takes each element in a quadword\nvector of integers, right shifts them by an immediate value, and places the\nrounded results in a doubleword vector.\n\nFor truncated results, see VQSHRN and VQSHRUN.\n\nThe operand elements must all be the same size, and can be any one of:\n  - 16-bit, 32-bit, or 64-bit signed integers.\n  - 16-bit, 32-bit, or 64-bit unsigned integers.\n\nThe result elements are half the width of the operand elements. If the operand\nelements are signed, the results can be either signed or unsigned. If the\noperand elements are unsigned, the result elements must also be unsigned.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQRSHRN, VQRSHRUN",
        "templates": {
          "A1": [
            "VQRSHRN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>",
            "VQRSHRUN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>"
          ],
          "T1": [
            "VQRSHRN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>",
            "VQRSHRUN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>"
          ]
        }
      },
      "VQRSHRN_VQMOVN": {
        "authored": " takes each element in a quadword vector of integers, right shifts them by an\nimmediate value, and places the signed rounded results in a doubleword vector",
        "heading": "VQRSHRN (zero)",
        "templates": {
          "A1": [
            "VQRSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0"
          ],
          "T1": [
            "VQRSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0"
          ]
        }
      },
      "VQRSHRUN_VQMOVN": {
        "authored": " takes each element in a quadword vector of integers, right shifts them by an\nimmediate value, and places the unsigned rounded results in a doubleword vector",
        "heading": "VQRSHRUN (zero)",
        "templates": {
          "A1": [
            "VQRSHRUN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0"
          ],
          "T1": [
            "VQRSHRUN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0"
          ]
        }
      },
      "VQSHL_i": {
        "authored": "Vector Saturating Shift Left (immediate) takes each element in a vector of\nintegers, left shifts them by an immediate value, and places the results in a\nsecond vector.\n\nThe operand elements must all be the same size, and can be any one of:\n  - 8-bit, 16-bit, 32-bit, or 64-bit signed integers.\n  - 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.\n\nThe result elements are the same size as the operand elements. If the operand\nelements are signed, the results can be either signed or unsigned. If the\noperand elements are unsigned, the result elements must also be unsigned.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQSHL, VQSHLU (immediate)",
        "templates": {
          "A1": [
            "VQSHL{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>",
            "VQSHL{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>",
            "VQSHLU{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>",
            "VQSHLU{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>"
          ],
          "T1": [
            "VQSHL{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>",
            "VQSHL{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>",
            "VQSHLU{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>",
            "VQSHLU{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>"
          ]
        }
      },
      "VQSHL_r": {
        "authored": "Vector Saturating Shift Left (register) takes each element in a vector, shifts\nthem by a value from the least significant byte of the corresponding element of\na second vector, and places the results in the destination vector. If the shift\nvalue is positive, the operation is a left shift. Otherwise, it is a right\nshift.\n\nThe results are truncated. For rounded results, see VQRSHL.\n\nThe first operand and result elements are the same data type, and can be any one\nof:\n  - 8-bit, 16-bit, 32-bit, or 64-bit signed integers.\n  - 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.\n\nThe second operand is a signed integer of the same size.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQSHL (register)",
        "templates": {
          "A1": [
            "VQSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>",
            "VQSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>"
          ],
          "T1": [
            "VQSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>",
            "VQSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>"
          ]
        }
      },
      "VQSHRN": {
        "authored": "Vector Saturating Shift Right, Narrow takes each element in a quadword vector of\nintegers, right shifts them by an immediate value, and places the truncated\nresults in a doubleword vector.\n\nFor rounded results, see VQRSHRN and VQRSHRUN.\n\nThe operand elements must all be the same size, and can be any one of:\n  - 16-bit, 32-bit, or 64-bit signed integers.\n  - 16-bit, 32-bit, or 64-bit unsigned integers.\n\nThe result elements are half the width of the operand elements. If the operand\nelements are signed, the results can be either signed or unsigned. If the\noperand elements are unsigned, the result elements must also be unsigned.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQSHRN, VQSHRUN",
        "templates": {
          "A1": [
            "VQSHRN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>",
            "VQSHRUN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>"
          ],
          "T1": [
            "VQSHRN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>",
            "VQSHRUN{<c>}{<q>}.<type><size> <Dd>, <Qm>, #<imm>"
          ]
        }
      },
      "VQSHRN_VQMOVN": {
        "authored": " takes each element in a quadword vector of integers, right shifts them by an\nimmediate value, and places the signed truncated results in a doubleword vector",
        "heading": "VQSHRN (zero)",
        "templates": {
          "A1": [
            "VQSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0"
          ],
          "T1": [
            "VQSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0"
          ]
        }
      },
      "VQSHRUN_VQMOVN": {
        "authored": " takes each element in a quadword vector of integers, right shifts them by an\nimmediate value, and places the unsigned truncated results in a doubleword\nvector",
        "heading": "VQSHRUN (zero)",
        "templates": {
          "A1": [
            "VQSHRUN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0"
          ],
          "T1": [
            "VQSHRUN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0"
          ]
        }
      },
      "VQSUB": {
        "authored": "Vector Saturating Subtract subtracts the elements of the second operand vector\nfrom the corresponding elements of the first operand vector, and places the\nresults in the destination vector. Signed and unsigned operations are distinct.\n\nThe operand and result elements must all be the same type, and can be any one\nof:\n  - 8-bit, 16-bit, 32-bit, or 64-bit signed integers.\n  - 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.\n\nIf any of the results overflow, they are saturated. The cumulative saturation\nbit, FPSCR.QC, is set if saturation occurs. For details see Pseudocode details\nof saturation.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VQSUB",
        "templates": {
          "A1": [
            "VQSUB{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>",
            "VQSUB{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>"
          ],
          "T1": [
            "VQSUB{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>",
            "VQSUB{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>"
          ]
        }
      },
      "VRADDHN": {
        "authored": "Vector Rounding Add and Narrow, returning High Half adds corresponding elements\nin two quadword vectors, and places the most significant half of each result in\na doubleword vector. The results are rounded.  For truncated results, see\nVADDHN.\n\nThe operand elements can be 16-bit, 32-bit, or 64-bit integers. There is no\ndistinction between signed and unsigned integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VRADDHN",
        "templates": {
          "A1": [
            "VRADDHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>"
          ],
          "T1": [
            "VRADDHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>"
          ]
        }
      },
      "VRECPE": {
        "authored": "Vector Reciprocal Estimate finds an approximate reciprocal of each element in\nthe operand vector, and places the results in the destination vector.\n\nThe operand and result elements are the same type, and can be floating-point\nnumbers or unsigned integers.\n\nFor details of the operation performed by this instruction see Floating-point\nreciprocal square root estimate and step.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VRECPE",
        "templates": {
          "A1": [
            "VRECPE{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VRECPE{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VRECPE{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VRECPE{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VRECPS": {
        "authored": "Vector Reciprocal Step multiplies the elements of one vector by the\ncorresponding elements of another vector, subtracts each of the products from\n2.0, and places the results into the elements of the destination vector.\n\nThe operand and result elements are floating-point numbers.\n\nFor details of the operation performed by this instruction see Floating-point\nreciprocal estimate and step.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VRECPS",
        "templates": {
          "A1": [
            "VRECPS{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VRECPS{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VRECPS{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VRECPS{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VREV16": {
        "authored": "Vector Reverse in halfwords reverses the order of 8-bit elements in each\nhalfword of the vector, and places the result in the corresponding destination\nvector.\n\nThere is no distinction between data types, other than size.\n\n\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VREV16",
        "templates": {
          "A1": [
            "VREV16{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VREV16{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VREV16{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VREV16{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VREV32": {
        "authored": "Vector Reverse in words reverses the order of 8-bit or 16-bit elements in each\nword of the vector, and places the result in the corresponding destination\nvector.\n\nThere is no distinction between data types, other than size.\n\n\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VREV32",
        "templates": {
          "A1": [
            "VREV32{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VREV32{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VREV32{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VREV32{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VREV64": {
        "authored": "Vector Reverse in doublewords reverses the order of 8-bit, 16-bit, or 32-bit\nelements in each doubleword of the vector, and places the result in the\ncorresponding destination vector.\n\nThere is no distinction between data types, other than size.\n\n\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VREV64",
        "templates": {
          "A1": [
            "VREV64{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VREV64{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VREV64{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VREV64{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VRHADD": {
        "authored": "Vector Rounding Halving Add adds corresponding elements in two vectors of\nintegers, shifts each result right one bit, and places the final results in the\ndestination vector.\n\nThe operand and result elements are all the same type, and can be any one of:\n  - 8-bit, 16-bit, or 32-bit signed integers.\n  - 8-bit, 16-bit, or 32-bit unsigned integers.\n\nThe results of the halving operations are rounded. For truncated results, see\nVHADD.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VRHADD",
        "templates": {
          "A1": [
            "VRHADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VRHADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VRHADD{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VRHADD{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VRINTA_asimd": {
        "authored": "Vector Round floating-point to integer towards Nearest with Ties to Away rounds\na vector of floating-point values to integral floating-point values of the same\nsize using the Round to Nearest with Ties to Away rounding mode. A zero input\ngives a zero result with the same sign, an infinite input gives an infinite\nresult with the same sign, and a NaN is propagated as for normal arithmetic.",
        "heading": "VRINTA (Advanced SIMD)",
        "templates": {
          "A1": [
            "VRINTA{<q>}.<dt> <Dd>, <Dm>",
            "VRINTA{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VRINTA{<q>}.<dt> <Dd>, <Dm>",
            "VRINTA{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VRINTA_vfp": {
        "authored": "Round floating-point to integer to Nearest with Ties to Away rounds a floating-\npoint value to an integral floating-point value of the same size using the Round\nto Nearest with Ties to Away rounding mode. A zero input gives a zero result\nwith the same sign, an infinite input gives an infinite result with the same\nsign, and a NaN is propagated as for normal arithmetic.",
        "heading": "VRINTA (floating-point)",
        "templates": {
          "A1": [
            "VRINTA{<q>}.F16 <Sd>, <Sm>",
            "VRINTA{<q>}.F32 <Sd>, <Sm>",
            "VRINTA{<q>}.F64 <Dd>, <Dm>"
          ],
          "T1": [
            "VRINTA{<q>}.F16 <Sd>, <Sm>",
            "VRINTA{<q>}.F32 <Sd>, <Sm>",
            "VRINTA{<q>}.F64 <Dd>, <Dm>"
          ]
        }
      },
      "VRINTM_asimd": {
        "authored": "Vector Round floating-point to integer towards -Infinity rounds a vector of\nfloating-point values to integral floating-point values of the same size, using\nthe Round towards -Infinity rounding mode. A zero input gives a zero result with\nthe same sign, an infinite input gives an infinite result with the same sign,\nand a NaN is propagated as for normal arithmetic.",
        "heading": "VRINTM (Advanced SIMD)",
        "templates": {
          "A1": [
            "VRINTM{<q>}.<dt> <Dd>, <Dm>",
            "VRINTM{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VRINTM{<q>}.<dt> <Dd>, <Dm>",
            "VRINTM{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VRINTM_vfp": {
        "authored": "Round floating-point to integer towards -Infinity rounds a floating-point value\nto an integral floating-point value of the same size using the Round towards\n-Infinity rounding mode. A zero input gives a zero result with the same sign, an\ninfinite input gives an infinite result with the same sign, and a NaN is\npropagated as for normal arithmetic.",
        "heading": "VRINTM (floating-point)",
        "templates": {
          "A1": [
            "VRINTM{<q>}.F16 <Sd>, <Sm>",
            "VRINTM{<q>}.F32 <Sd>, <Sm>",
            "VRINTM{<q>}.F64 <Dd>, <Dm>"
          ],
          "T1": [
            "VRINTM{<q>}.F16 <Sd>, <Sm>",
            "VRINTM{<q>}.F32 <Sd>, <Sm>",
            "VRINTM{<q>}.F64 <Dd>, <Dm>"
          ]
        }
      },
      "VRINTN_asimd": {
        "authored": "Vector Round floating-point to integer to Nearest rounds a vector of floating-\npoint values to integral floating-point values of the same size using the Round\nto Nearest rounding mode. A zero input gives a zero result with the same sign,\nan infinite input gives an infinite result with the same sign, and a NaN is\npropagated as for normal arithmetic.",
        "heading": "VRINTN (Advanced SIMD)",
        "templates": {
          "A1": [
            "VRINTN{<q>}.<dt> <Dd>, <Dm>",
            "VRINTN{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VRINTN{<q>}.<dt> <Dd>, <Dm>",
            "VRINTN{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VRINTN_vfp": {
        "authored": "Round floating-point to integer to Nearest rounds a floating-point value to an\nintegral floating-point value of the same size using the Round to Nearest\nrounding mode. A zero input gives a zero result with the same sign, an infinite\ninput gives an infinite result with the same sign, and a NaN is propagated as\nfor normal arithmetic.",
        "heading": "VRINTN (floating-point)",
        "templates": {
          "A1": [
            "VRINTN{<q>}.F16 <Sd>, <Sm>",
            "VRINTN{<q>}.F32 <Sd>, <Sm>",
            "VRINTN{<q>}.F64 <Dd>, <Dm>"
          ],
          "T1": [
            "VRINTN{<q>}.F16 <Sd>, <Sm>",
            "VRINTN{<q>}.F32 <Sd>, <Sm>",
            "VRINTN{<q>}.F64 <Dd>, <Dm>"
          ]
        }
      },
      "VRINTP_asimd": {
        "authored": "Vector Round floating-point to integer towards +Infinity rounds a vector of\nfloating-point values to integral floating-point values of the same size using\nthe Round towards +Infinity rounding mode. A zero input gives a zero result with\nthe same sign, an infinite input gives an infinite result with the same sign,\nand a NaN is propagated as for normal arithmetic.",
        "heading": "VRINTP (Advanced SIMD)",
        "templates": {
          "A1": [
            "VRINTP{<q>}.<dt> <Dd>, <Dm>",
            "VRINTP{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VRINTP{<q>}.<dt> <Dd>, <Dm>",
            "VRINTP{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VRINTP_vfp": {
        "authored": "Round floating-point to integer towards +Infinity rounds a floating-point value\nto an integral floating-point value of the same size using the Round towards\n+Infinity rounding mode. A zero input gives a zero result with the same sign, an\ninfinite input gives an infinite result with the same sign, and a NaN is\npropagated as for normal arithmetic.",
        "heading": "VRINTP (floating-point)",
        "templates": {
          "A1": [
            "VRINTP{<q>}.F16 <Sd>, <Sm>",
            "VRINTP{<q>}.F32 <Sd>, <Sm>",
            "VRINTP{<q>}.F64 <Dd>, <Dm>"
          ],
          "T1": [
            "VRINTP{<q>}.F16 <Sd>, <Sm>",
            "VRINTP{<q>}.F32 <Sd>, <Sm>",
            "VRINTP{<q>}.F64 <Dd>, <Dm>"
          ]
        }
      },
      "VRINTR_vfp": {
        "authored": "Round floating-point to integer rounds a floating-point value to an integral\nfloating-point value of the same size using the rounding mode specified in the\nFPSCR. A zero input gives a zero result with the same sign, an infinite input\ngives an infinite result with the same sign, and a NaN is propagated as for\nnormal arithmetic.",
        "heading": "VRINTR",
        "templates": {
          "A1": [
            "VRINTR{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VRINTR{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VRINTR{<c>}{<q>}.F64 <Dd>, <Dm>"
          ],
          "T1": [
            "VRINTR{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VRINTR{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VRINTR{<c>}{<q>}.F64 <Dd>, <Dm>"
          ]
        }
      },
      "VRINTX_asimd": {
        "authored": "Vector round floating-point to integer inexact rounds a vector of floating-point\nvalues to integral floating-point values of the same size, using the Round to\nNearest rounding mode, and raises the Inexact exception when the result value is\nnot numerically equal to the input value. A zero input gives a zero result with\nthe same sign, an infinite input gives an infinite result with the same sign,\nand a NaN is propagated as for normal arithmetic.",
        "heading": "VRINTX (Advanced SIMD)",
        "templates": {
          "A1": [
            "VRINTX{<q>}.<dt> <Dd>, <Dm>",
            "VRINTX{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VRINTX{<q>}.<dt> <Dd>, <Dm>",
            "VRINTX{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VRINTX_vfp": {
        "authored": "Round floating-point to integer inexact rounds a floating-point value to an\nintegral floating-point value of the same size, using the rounding mode\nspecified in the FPSCR, and raises an Inexact exception when the result value is\nnot numerically equal to the input value. A zero input gives a zero result with\nthe same sign, an infinite input gives an infinite result with the same sign,\nand a NaN is propagated as for normal arithmetic.",
        "heading": "VRINTX (floating-point)",
        "templates": {
          "A1": [
            "VRINTX{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VRINTX{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VRINTX{<c>}{<q>}.F64 <Dd>, <Dm>"
          ],
          "T1": [
            "VRINTX{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VRINTX{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VRINTX{<c>}{<q>}.F64 <Dd>, <Dm>"
          ]
        }
      },
      "VRINTZ_asimd": {
        "authored": "Vector round floating-point to integer towards Zero rounds a vector of floating-\npoint values to integral floating-point values of the same size, using the Round\ntowards Zero rounding mode. A zero input gives a zero result with the same sign,\nan infinite input gives an infinite result with the same sign, and a NaN is\npropagated as for normal arithmetic.",
        "heading": "VRINTZ (Advanced SIMD)",
        "templates": {
          "A1": [
            "VRINTZ{<q>}.<dt> <Dd>, <Dm>",
            "VRINTZ{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VRINTZ{<q>}.<dt> <Dd>, <Dm>",
            "VRINTZ{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VRINTZ_vfp": {
        "authored": "Round floating-point to integer towards Zero rounds a floating-point value to an\nintegral floating-point value of the same size, using the Round towards Zero\nrounding mode. A zero input gives a zero result with the same sign, an infinite\ninput gives an infinite result with the same sign, and a NaN is propagated as\nfor normal arithmetic.",
        "heading": "VRINTZ (floating-point)",
        "templates": {
          "A1": [
            "VRINTZ{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VRINTZ{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VRINTZ{<c>}{<q>}.F64 <Dd>, <Dm>"
          ],
          "T1": [
            "VRINTZ{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VRINTZ{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VRINTZ{<c>}{<q>}.F64 <Dd>, <Dm>"
          ]
        }
      },
      "VRSHL": {
        "authored": "Vector Rounding Shift Left takes each element in a vector, shifts them by a\nvalue from the least significant byte of the corresponding element of a second\nvector, and places the results in the destination vector. If the shift value is\npositive, the operation is a left shift. If the shift value is negative, it is a\nrounding right shift. For a truncating shift, see VSHL.\n\nThe first operand and result elements are the same data type, and can be any one\nof:\n  - 8-bit, 16-bit, 32-bit, or 64-bit signed integers.\n  - 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.\n\nThe second operand is always a signed integer of the same size.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VRSHL",
        "templates": {
          "A1": [
            "VRSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>",
            "VRSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>"
          ],
          "T1": [
            "VRSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>",
            "VRSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>"
          ]
        }
      },
      "VRSHR": {
        "authored": "Vector Rounding Shift Right takes each element in a vector, right shifts them by\nan immediate value, and places the rounded results in the destination vector.\nFor truncated results, see VSHR.\n\nThe operand and result elements must be the same size, and can be any one of:\n  - 8-bit, 16-bit, 32-bit, or 64-bit signed integers.\n  - 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VRSHR",
        "templates": {
          "A1": [
            "VRSHR{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>",
            "VRSHR{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>"
          ],
          "T1": [
            "VRSHR{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>",
            "VRSHR{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>"
          ]
        }
      },
      "VRSHRN": {
        "authored": "Vector Rounding Shift Right and Narrow takes each element in a vector, right\nshifts them by an immediate value, and places the rounded results in the\ndestination vector. For truncated results, see VSHRN.\n\nThe operand elements can be 16-bit, 32-bit, or 64-bit integers. There is no\ndistinction between signed and unsigned integers. The destination elements are\nhalf the size of the source elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VRSHRN",
        "templates": {
          "A1": [
            "VRSHRN{<c>}{<q>}.I<size> <Dd>, <Qm>, #<imm>"
          ],
          "T1": [
            "VRSHRN{<c>}{<q>}.I<size> <Dd>, <Qm>, #<imm>"
          ]
        }
      },
      "VRSHRN_VMOVN": {
        "authored": " takes each element in a vector, right shifts them by an immediate value, and\nplaces the rounded results in the destination vector",
        "heading": "VRSHRN (zero)",
        "templates": {
          "A1": [
            "VRSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0"
          ],
          "T1": [
            "VRSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0"
          ]
        }
      },
      "VRSHR_VORR_r": {
        "authored": " copies the contents of one SIMD register to another",
        "heading": "VRSHR (zero)",
        "templates": {
          "A1": [
            "VRSHR{<c>}{<q>}.<dt> <Dd>, <Dm>, #0",
            "VRSHR{<c>}{<q>}.<dt> <Qd>, <Qm>, #0"
          ],
          "T1": [
            "VRSHR{<c>}{<q>}.<dt> <Dd>, <Dm>, #0",
            "VRSHR{<c>}{<q>}.<dt> <Qd>, <Qm>, #0"
          ]
        }
      },
      "VRSQRTE": {
        "authored": "Vector Reciprocal Square Root Estimate finds an approximate reciprocal square\nroot of each element in a vector, and places the results in a second vector.\n\nThe operand and result elements are the same type, and can be floating-point\nnumbers or unsigned integers.\n\nFor details of the operation performed by this instruction see Floating-point\nreciprocal estimate and step.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VRSQRTE",
        "templates": {
          "A1": [
            "VRSQRTE{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VRSQRTE{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VRSQRTE{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VRSQRTE{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VRSQRTS": {
        "authored": "Vector Reciprocal Square Root Step multiplies the elements of one vector by the\ncorresponding elements of another vector, subtracts each of the products from\n3.0, divides these results by 2.0, and places the results into the elements of\nthe destination vector.\n\nThe operand and result elements are floating-point numbers.\n\nFor details of the operation performed by this instruction see Floating-point\nreciprocal estimate and step.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VRSQRTS",
        "templates": {
          "A1": [
            "VRSQRTS{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VRSQRTS{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VRSQRTS{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VRSQRTS{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VRSRA": {
        "authored": "Vector Rounding Shift Right and Accumulate takes each element in a vector, right\nshifts them by an immediate value, and accumulates the rounded results into the\ndestination vector.For truncated results, see VSRA.\n\nThe operand and result elements must all be the same type, and can be any one\nof:\n  - 8-bit, 16-bit, 32-bit, or 64-bit signed integers.\n  - 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VRSRA",
        "templates": {
          "A1": [
            "VRSRA{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>",
            "VRSRA{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>"
          ],
          "T1": [
            "VRSRA{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>",
            "VRSRA{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>"
          ]
        }
      },
      "VRSUBHN": {
        "authored": "Vector Rounding Subtract and Narrow, returning High Half subtracts the elements\nof one quadword vector from the corresponding elements of another quadword\nvector, takes the most significant half of each result, and places the final\nresults in a doubleword vector. The results are rounded. For truncated results,\nsee VSUBHN.\n\nThe operand elements can be 16-bit, 32-bit, or 64-bit integers. There is no\ndistinction between signed and unsigned integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VRSUBHN",
        "templates": {
          "A1": [
            "VRSUBHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>"
          ],
          "T1": [
            "VRSUBHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>"
          ]
        }
      },
      "VSDOT": {
        "authored": "Dot Product vector form with signed integers. This instruction performs the dot\nproduct of the four 8-bit elements in each 32-bit element of the first source\nregister with the four 8-bit elements of the corresponding 32-bit element in the\nsecond source register, accumulating the result into the corresponding 32-bit\nelement of the destination register.\n\nIn ARMv8.2 and ARMv8.3, this is an optional instruction. From ARMv8.4 it is\nmandatory for all implementations to support it.\n\nID_ISAR6.DP indicates whether this instruction is supported.",
        "heading": "VSDOT (vector)",
        "templates": {
          "A1": [
            "VSDOT{<q>}.S8 <Dd>, <Dn>, <Dm>",
            "VSDOT{<q>}.S8 <Qd>, <Qn>, <Qm>"
          ],
          "T1": [
            "VSDOT{<q>}.S8 <Dd>, <Dn>, <Dm>",
            "VSDOT{<q>}.S8 <Qd>, <Qn>, <Qm>"
          ]
        }
      },
      "VSDOT_s": {
        "authored": "Dot Product index form with signed integers. This instruction performs the dot\nproduct of the four 8-bit elements in each 32-bit element of the first source\nregister with the four 8-bit elements of an indexed 32-bit element in the second\nsource register, accumulating the result into the corresponding 32-bit element\nof the destination register.\n\nIn ARMv8.2 and ARMv8.3, this is an optional instruction. From ARMv8.4 it is\nmandatory for all implementations to support it.\n\nID_ISAR6.DP indicates whether this instruction is supported.",
        "heading": "VSDOT (by element)",
        "templates": {
          "A1": [
            "VSDOT{<q>}.S8 <Dd>, <Dn>, <Dm>[<index>]",
            "VSDOT{<q>}.S8 <Qd>, <Qn>, <Dm>[<index>]"
          ],
          "T1": [
            "VSDOT{<q>}.S8 <Dd>, <Dn>, <Dm>[<index>]",
            "VSDOT{<q>}.S8 <Qd>, <Qn>, <Dm>[<index>]"
          ]
        }
      },
      "VSEL": {
        "authored": "Floating-point conditional select allows the destination register to take the\nvalue in either one or the other source register according to the condition\ncodes in the APSR.",
        "heading": "VSELEQ, VSELGE, VSELGT, VSELVS",
        "templates": {
          "A1": [
            "VSELEQ.F64 <Dd>, <Dn>, <Dm>",
            "VSELEQ.F16 <Sd>, <Sn>, <Sm>",
            "VSELEQ.F32 <Sd>, <Sn>, <Sm>",
            "VSELGE.F64 <Dd>, <Dn>, <Dm>",
            "VSELGE.F16 <Sd>, <Sn>, <Sm>",
            "VSELGE.F32 <Sd>, <Sn>, <Sm>",
            "VSELGT.F64 <Dd>, <Dn>, <Dm>",
            "VSELGT.F16 <Sd>, <Sn>, <Sm>",
            "VSELGT.F32 <Sd>, <Sn>, <Sm>",
            "VSELVS.F64 <Dd>, <Dn>, <Dm>",
            "VSELVS.F16 <Sd>, <Sn>, <Sm>",
            "VSELVS.F32 <Sd>, <Sn>, <Sm>"
          ],
          "T1": [
            "VSELEQ.F64 <Dd>, <Dn>, <Dm>",
            "VSELEQ.F16 <Sd>, <Sn>, <Sm>",
            "VSELEQ.F32 <Sd>, <Sn>, <Sm>",
            "VSELGE.F64 <Dd>, <Dn>, <Dm>",
            "VSELGE.F16 <Sd>, <Sn>, <Sm>",
            "VSELGE.F32 <Sd>, <Sn>, <Sm>",
            "VSELGT.F64 <Dd>, <Dn>, <Dm>",
            "VSELGT.F16 <Sd>, <Sn>, <Sm>",
            "VSELGT.F32 <Sd>, <Sn>, <Sm>",
            "VSELVS.F64 <Dd>, <Dn>, <Dm>",
            "VSELVS.F16 <Sd>, <Sn>, <Sm>",
            "VSELVS.F32 <Sd>, <Sn>, <Sm>"
          ]
        }
      },
      "VSHLL": {
        "authored": "Vector Shift Left Long takes each element in a doubleword vector, left shifts\nthem by an immediate value, and places the results in a quadword vector.\n\nThe operand elements can be:\n  - 8-bit, 16-bit, or 32-bit signed integers.\n  - 8-bit, 16-bit, or 32-bit unsigned integers.\n  - 8-bit, 16-bit, or 32-bit untyped integers, maximum shift only.\n\nThe result elements are twice the length of the operand elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSHLL",
        "templates": {
          "A1": [
            "VSHLL{<c>}{<q>}.<type><size> <Qd>, <Dm>, #<imm>"
          ],
          "A2": [
            "VSHLL{<c>}{<q>}.<type><size> <Qd>, <Dm>, #<imm>"
          ],
          "T1": [
            "VSHLL{<c>}{<q>}.<type><size> <Qd>, <Dm>, #<imm>"
          ],
          "T2": [
            "VSHLL{<c>}{<q>}.<type><size> <Qd>, <Dm>, #<imm>"
          ]
        }
      },
      "VSHL_i": {
        "authored": "Vector Shift Left (immediate) takes each element in a vector of integers, left\nshifts them by an immediate value, and places the results in the destination\nvector.\n\nBits shifted out of the left of each element are lost.\n\nThe elements must all be the same size, and can be 8-bit, 16-bit, 32-bit, or\n64-bit integers. There is no distinction between signed and unsigned integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSHL (immediate)",
        "templates": {
          "A1": [
            "VSHL{<c>}{<q>}.I<size> {<Dd>,} <Dm>, #<imm>",
            "VSHL{<c>}{<q>}.I<size> {<Qd>,} <Qm>, #<imm>"
          ],
          "T1": [
            "VSHL{<c>}{<q>}.I<size> {<Dd>,} <Dm>, #<imm>",
            "VSHL{<c>}{<q>}.I<size> {<Qd>,} <Qm>, #<imm>"
          ]
        }
      },
      "VSHL_r": {
        "authored": "Vector Shift Left (register) takes each element in a vector, shifts them by a\nvalue from the least significant byte of the corresponding element of a second\nvector, and places the results in the destination vector. If the shift value is\npositive, the operation is a left shift. If the shift value is negative, it is a\ntruncating right shift.\n\nFor a rounding shift, see VRSHL.\n\nThe first operand and result elements are the same data type, and can be any one\nof:\n  - 8-bit, 16-bit, 32-bit, or 64-bit signed integers.\n  - 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.\n\nThe second operand is always a signed integer of the same size.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSHL (register)",
        "templates": {
          "A1": [
            "VSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>",
            "VSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>"
          ],
          "T1": [
            "VSHL{<c>}{<q>}.<dt> {<Dd>,} <Dm>, <Dn>",
            "VSHL{<c>}{<q>}.<dt> {<Qd>,} <Qm>, <Qn>"
          ]
        }
      },
      "VSHR": {
        "authored": "Vector Shift Right takes each element in a vector, right shifts them by an\nimmediate value, and places the truncated results in the destination vector. For\nrounded results, see VRSHR.\n\nThe operand and result elements must be the same size, and can be any one of:\n  - 8-bit, 16-bit, 32-bit, or 64-bit signed integers.\n  - 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSHR",
        "templates": {
          "A1": [
            "VSHR{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>",
            "VSHR{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>"
          ],
          "T1": [
            "VSHR{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>",
            "VSHR{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>"
          ]
        }
      },
      "VSHRN": {
        "authored": "Vector Shift Right Narrow takes each element in a vector, right shifts them by\nan immediate value, and places the truncated results in the destination vector.\nFor rounded results, see VRSHRN.\n\nThe operand elements can be 16-bit, 32-bit, or 64-bit integers. There is no\ndistinction between signed and unsigned integers. The destination elements are\nhalf the size of the source elements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSHRN",
        "templates": {
          "A1": [
            "VSHRN{<c>}{<q>}.I<size> <Dd>, <Qm>, #<imm>"
          ],
          "T1": [
            "VSHRN{<c>}{<q>}.I<size> <Dd>, <Qm>, #<imm>"
          ]
        }
      },
      "VSHRN_VMOVN": {
        "authored": " takes each element in a vector, right shifts them by an immediate value, and\nplaces the truncated results in the destination vector",
        "heading": "VSHRN (zero)",
        "templates": {
          "A1": [
            "VSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0"
          ],
          "T1": [
            "VSHRN{<c>}{<q>}.<dt> <Dd>, <Qm>, #0"
          ]
        }
      },
      "VSHR_VORR_r": {
        "authored": " copies the contents of one SIMD register to another",
        "heading": "VSHR (zero)",
        "templates": {
          "A1": [
            "VSHR{<c>}{<q>}.<dt> <Dd>, <Dm>, #0",
            "VSHR{<c>}{<q>}.<dt> <Qd>, <Qm>, #0"
          ],
          "T1": [
            "VSHR{<c>}{<q>}.<dt> <Dd>, <Dm>, #0",
            "VSHR{<c>}{<q>}.<dt> <Qd>, <Qm>, #0"
          ]
        }
      },
      "VSLI": {
        "authored": "Vector Shift Left and Insert takes each element in the operand vector, left\nshifts them by an immediate value, and inserts the results in the destination\nvector. Bits shifted out of the left of each element are lost.\n\nThe elements must all be the same size, and can be 8-bit, 16-bit, 32-bit, or\n64-bit. There is no distinction between data types.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSLI",
        "templates": {
          "A1": [
            "VSLI{<c>}{<q>}.<size> {<Dd>,} <Dm>, #<imm>",
            "VSLI{<c>}{<q>}.<size> {<Qd>,} <Qm>, #<imm>"
          ],
          "T1": [
            "VSLI{<c>}{<q>}.<size> {<Dd>,} <Dm>, #<imm>",
            "VSLI{<c>}{<q>}.<size> {<Qd>,} <Qm>, #<imm>"
          ]
        }
      },
      "VSQRT": {
        "authored": "Square Root calculates the square root of the value in a floating-point register\nand writes the result to another floating-point register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VSQRT",
        "templates": {
          "A1": [
            "VSQRT{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VSQRT{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VSQRT{<c>}{<q>}.F64 <Dd>, <Dm>"
          ],
          "T1": [
            "VSQRT{<c>}{<q>}.F16 <Sd>, <Sm>",
            "VSQRT{<c>}{<q>}.F32 <Sd>, <Sm>",
            "VSQRT{<c>}{<q>}.F64 <Dd>, <Dm>"
          ]
        }
      },
      "VSRA": {
        "authored": "Vector Shift Right and Accumulate takes each element in a vector, right shifts\nthem by an immediate value, and accumulates the truncated results into the\ndestination vector. For rounded results, see VRSRA.\n\nThe operand and result elements must all be the same type, and can be any one\nof:\n  - 8-bit, 16-bit, 32-bit, or 64-bit signed integers.\n  - 8-bit, 16-bit, 32-bit, or 64-bit unsigned integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSRA",
        "templates": {
          "A1": [
            "VSRA{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>",
            "VSRA{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>"
          ],
          "T1": [
            "VSRA{<c>}{<q>}.<type><size> {<Dd>,} <Dm>, #<imm>",
            "VSRA{<c>}{<q>}.<type><size> {<Qd>,} <Qm>, #<imm>"
          ]
        }
      },
      "VSRI": {
        "authored": "Vector Shift Right and Insert takes each element in the operand vector, right\nshifts them by an immediate value, and inserts the results in the destination\nvector. Bits shifted out of the right of each element are lost.\n\nThe elements must all be the same size, and can be 8-bit, 16-bit, 32-bit, or\n64-bit. There is no distinction between data types.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSRI",
        "templates": {
          "A1": [
            "VSRI{<c>}{<q>}.<size> {<Dd>,} <Dm>, #<imm>",
            "VSRI{<c>}{<q>}.<size> {<Qd>,} <Qm>, #<imm>"
          ],
          "T1": [
            "VSRI{<c>}{<q>}.<size> {<Dd>,} <Dm>, #<imm>",
            "VSRI{<c>}{<q>}.<size> {<Qd>,} <Qm>, #<imm>"
          ]
        }
      },
      "VST1_1": {
        "authored": "Store single element from one lane of one register stores one element to memory\nfrom one element of a register. For details of the addressing mode see Advanced\nSIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VST1 (single element from one lane)",
        "templates": {
          "A1": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A2": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A3": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T2": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T3": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VST1_m": {
        "authored": "Store multiple single elements from one, two, three, or four registers stores\nelements to memory from one, two, three, or four registers, without\ninterleaving.  Every element of each register is stored. For details of the\naddressing mode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VST1 (multiple single elements)",
        "templates": {
          "A1": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A2": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A3": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A4": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T2": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T3": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T4": [
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST1{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VST2_1": {
        "authored": "Store single 2-element structure from one lane of two registers stores one\n2-element structure to memory from corresponding elements of two registers. For\ndetails of the addressing mode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VST2 (single 2-element structure from one lane)",
        "templates": {
          "A1": [
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A2": [
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A3": [
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T2": [
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T3": [
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VST2_m": {
        "authored": "Store multiple 2-element structures from two or four registers stores multiple\n2-element structures from two or four registers to memory, with interleaving.\nFor more information, see Element and structure load/store instructions. Every\nelement of each register is saved. For details of the addressing mode see\nAdvanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VST2 (multiple 2-element structures)",
        "templates": {
          "A1": [
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A2": [
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T2": [
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST2{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VST3_1": {
        "authored": "Store single 3-element structure from one lane of three registers stores one\n3-element structure to memory from corresponding elements of three registers.\nFor details of the addressing mode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VST3 (single 3-element structure from one lane)",
        "templates": {
          "A1": [
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ],
          "A2": [
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ],
          "A3": [
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ],
          "T1": [
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ],
          "T2": [
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ],
          "T3": [
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>]",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>]!",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>], <Rm>"
          ]
        }
      },
      "VST3_m": {
        "authored": "Store multiple 3-element structures from three registers stores multiple\n3-element structures to memory from three registers, with interleaving. For more\ninformation, see Element and structure load/store instructions. Every element of\neach register is saved. For details of the addressing mode see Advanced SIMD\naddressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VST3 (multiple 3-element structures)",
        "templates": {
          "A1": [
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST3{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VST4_1": {
        "authored": "Store single 4-element structure from one lane of four registers stores one\n4-element structure to memory from corresponding elements of four registers. For\ndetails of the addressing mode see Advanced SIMD addressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VST4 (single 4-element structure from one lane)",
        "templates": {
          "A1": [
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A2": [
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "A3": [
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T2": [
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T3": [
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!"
          ]
        }
      },
      "VST4_m": {
        "authored": "Store multiple 4-element structures from four registers stores multiple\n4-element structures to memory from four registers, with interleaving. For more\ninformation, see Element and structure load/store instructions. Every element of\neach register is saved. For details of the addressing mode see Advanced SIMD\naddressing mode.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VST4 (multiple 4-element structures)",
        "templates": {
          "A1": [
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ],
          "T1": [
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}]!",
            "VST4{<c>}{<q>}.<size> <list>, [<Rn>{:<align>}], <Rm>"
          ]
        }
      },
      "VSTM": {
        "authored": "Store multiple SIMD&FP registers stores multiple registers from the Advanced\nSIMD and floating-point register file to consecutive memory locations using an\naddress from a general-purpose register.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VSTM, VSTMDB, VSTMIA",
        "templates": {
          "A1": [
            "VSTMDB{<c>}{<q>}{.<size>} <Rn>!, <dreglist>",
            "VSTM{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>",
            "VSTMIA{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>"
          ],
          "A2": [
            "VSTMDB{<c>}{<q>}{.<size>} <Rn>!, <sreglist>",
            "VSTM{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>",
            "VSTMIA{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>"
          ],
          "T1": [
            "VSTMDB{<c>}{<q>}{.<size>} <Rn>!, <dreglist>",
            "VSTM{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>",
            "VSTMIA{<c>}{<q>}{.<size>} <Rn>{!}, <dreglist>"
          ],
          "T2": [
            "VSTMDB{<c>}{<q>}{.<size>} <Rn>!, <sreglist>",
            "VSTM{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>",
            "VSTMIA{<c>}{<q>}{.<size>} <Rn>{!}, <sreglist>"
          ]
        }
      },
      "VSTR": {
        "authored": "Store SIMD&FP register stores a single register from the Advanced SIMD and\nfloating-point register file to memory, using an address from a general-purpose\nregister, with an optional offset.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VSTR",
        "templates": {
          "A1": [
            "VSTR{<c>}{<q>}.16 <Sd>, [<Rn>{, #{+/-}<imm>}]",
            "VSTR{<c>}{<q>}{.32} <Sd>, [<Rn>{, #{+/-}<imm>}]",
            "VSTR{<c>}{<q>}{.64} <Dd>, [<Rn>{, #{+/-}<imm>}]"
          ],
          "T1": [
            "VSTR{<c>}{<q>}.16 <Sd>, [<Rn>{, #{+/-}<imm>}]",
            "VSTR{<c>}{<q>}{.32} <Sd>, [<Rn>{, #{+/-}<imm>}]",
            "VSTR{<c>}{<q>}{.64} <Dd>, [<Rn>{, #{+/-}<imm>}]"
          ]
        }
      },
      "VSUBHN": {
        "authored": "Vector Subtract and Narrow, returning High Half subtracts the elements of one\nquadword vector from the corresponding elements of another quadword vector,\ntakes the most significant half of each result, and places the final results in\na doubleword vector. The results are truncated. For rounded results, see\nVRSUBHN.\n\nThere is no distinction between signed and unsigned integers.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSUBHN",
        "templates": {
          "A1": [
            "VSUBHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>"
          ],
          "T1": [
            "VSUBHN{<c>}{<q>}.<dt> <Dd>, <Qn>, <Qm>"
          ]
        }
      },
      "VSUBL": {
        "authored": "Vector Subtract Long subtracts the elements of one doubleword vector from the\ncorresponding elements of another doubleword vector, and places the results in a\nquadword vector. Before subtracting, it sign-extends or zero-extends the\nelements of both operands.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSUBL",
        "templates": {
          "A1": [
            "VSUBL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ],
          "T1": [
            "VSUBL{<c>}{<q>}.<dt> <Qd>, <Dn>, <Dm>"
          ]
        }
      },
      "VSUBW": {
        "authored": "Vector Subtract Wide subtracts the elements of a doubleword vector from the\ncorresponding elements of a quadword vector, and places the results in another\nquadword vector. Before subtracting, it sign-extends or zero-extends the\nelements of the doubleword operand.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSUBW",
        "templates": {
          "A1": [
            "VSUBW{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm>"
          ],
          "T1": [
            "VSUBW{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Dm>"
          ]
        }
      },
      "VSUB_f": {
        "authored": "Vector Subtract (floating-point) subtracts the elements of one vector from the\ncorresponding elements of another vector, and places the results in the\ndestination vector.\n\nDepending on settings in the CPACR, NSACR, HCPTR, and FPEXC registers, and the\nSecurity state and PE mode in which the instruction is executed, an attempt to\nexecute the instruction might be undefined, or trapped to Hyp mode. For more\ninformation see Enabling Advanced SIMD and floating-point support.",
        "heading": "VSUB (floating-point)",
        "templates": {
          "A1": [
            "VSUB{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VSUB{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "A2": [
            "VSUB{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>",
            "VSUB{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>",
            "VSUB{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>"
          ],
          "T1": [
            "VSUB{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VSUB{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T2": [
            "VSUB{<c>}{<q>}.F16 {<Sd>,} <Sn>, <Sm>",
            "VSUB{<c>}{<q>}.F32 {<Sd>,} <Sn>, <Sm>",
            "VSUB{<c>}{<q>}.F64 {<Dd>,} <Dn>, <Dm>"
          ]
        }
      },
      "VSUB_i": {
        "authored": "Vector Subtract (integer) subtracts the elements of one vector from the\ncorresponding elements of another vector, and places the results in the\ndestination vector.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSUB (integer)",
        "templates": {
          "A1": [
            "VSUB{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VSUB{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ],
          "T1": [
            "VSUB{<c>}{<q>}.<dt> {<Dd>, }<Dn>, <Dm>",
            "VSUB{<c>}{<q>}.<dt> {<Qd>, }<Qn>, <Qm>"
          ]
        }
      },
      "VSWP": {
        "authored": "Vector Swap exchanges the contents of two vectors. The vectors can be either\ndoubleword or quadword. There is no distinction between data types.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VSWP",
        "templates": {
          "A1": [
            "VSWP{<c>}{<q>}{.<dt>} <Dd>, <Dm>",
            "VSWP{<c>}{<q>}{.<dt>} <Qd>, <Qm>"
          ],
          "T1": [
            "VSWP{<c>}{<q>}{.<dt>} <Dd>, <Dm>",
            "VSWP{<c>}{<q>}{.<dt>} <Qd>, <Qm>"
          ]
        }
      },
      "VTBL": {
        "authored": "Vector Table Lookup uses byte indexes in a control vector to look up byte values\nin a table and generate a new vector. Indexes out of range return 0.\n\nVector Table Extension works in the same way, except that indexes out of range\nleave the destination element unchanged.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VTBL, VTBX",
        "templates": {
          "A1": [
            "VTBL{<c>}{<q>}.8 <Dd>, <list>, <Dm>",
            "VTBX{<c>}{<q>}.8 <Dd>, <list>, <Dm>"
          ],
          "T1": [
            "VTBL{<c>}{<q>}.8 <Dd>, <list>, <Dm>",
            "VTBX{<c>}{<q>}.8 <Dd>, <list>, <Dm>"
          ]
        }
      },
      "VTRN": {
        "authored": "Vector Transpose treats the elements of its operand vectors as elements of 2 x 2\nmatrices, and transposes the matrices.\n\nThe elements of the vectors can be 8-bit, 16-bit, or 32-bit. There is no\ndistinction between data types.\n\n\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VTRN",
        "templates": {
          "A1": [
            "VTRN{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VTRN{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VTRN{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VTRN{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VTST": {
        "authored": "Vector Test Bits takes each element in a vector, and bitwise ANDs it with the\ncorresponding element of a second vector. If the result is not zero, the\ncorresponding element in the destination vector is set to all ones. Otherwise,\nit is set to all zeros.\n\nThe operand vector elements can be any one of:\n  - 8-bit, 16-bit, or 32-bit fields.\n\nThe result vector elements are fields the same size as the operand vector\nelements.\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VTST",
        "templates": {
          "A1": [
            "VTST{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>",
            "VTST{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>"
          ],
          "T1": [
            "VTST{<c>}{<q>}.<dt> {<Dd>,} <Dn>, <Dm>",
            "VTST{<c>}{<q>}.<dt> {<Qd>,} <Qn>, <Qm>"
          ]
        }
      },
      "VUDOT": {
        "authored": "Dot Product vector form with unsigned integers. This instruction performs the\ndot product of the four 8-bit elements in each 32-bit element of the first\nsource register with the four 8-bit elements of the corresponding 32-bit element\nin the second source register, accumulating the result into the corresponding\n32-bit element of the destination register.\n\nIn ARMv8.2 and ARMv8.3, this is an optional instruction. From ARMv8.4 it is\nmandatory for all implementations to support it.\n\nID_ISAR6.DP indicates whether this instruction is supported.",
        "heading": "VUDOT (vector)",
        "templates": {
          "A1": [
            "VUDOT{<q>}.U8 <Dd>, <Dn>, <Dm>",
            "VUDOT{<q>}.U8 <Qd>, <Qn>, <Qm>"
          ],
          "T1": [
            "VUDOT{<q>}.U8 <Dd>, <Dn>, <Dm>",
            "VUDOT{<q>}.U8 <Qd>, <Qn>, <Qm>"
          ]
        }
      },
      "VUDOT_s": {
        "authored": "Dot Product index form with unsigned integers. This instruction performs the dot\nproduct of the four 8-bit elements in each 32-bit element of the first source\nregister with the four 8-bit elements of an indexed 32-bit element in the second\nsource register, accumulating the result into the corresponding 32-bit element\nof the destination register.\n\nIn ARMv8.2 and ARMv8.3, this is an optional instruction. From ARMv8.4 it is\nmandatory for all implementations to support it.\n\nID_ISAR6.DP indicates whether this instruction is supported.",
        "heading": "VUDOT (by element)",
        "templates": {
          "A1": [
            "VUDOT{<q>}.U8 <Dd>, <Dn>, <Dm>[<index>]",
            "VUDOT{<q>}.U8 <Qd>, <Qn>, <Dm>[<index>]"
          ],
          "T1": [
            "VUDOT{<q>}.U8 <Dd>, <Dn>, <Dm>[<index>]",
            "VUDOT{<q>}.U8 <Qd>, <Qn>, <Dm>[<index>]"
          ]
        }
      },
      "VUZP": {
        "authored": "Vector Unzip de-interleaves the elements of two vectors.\n\nThe elements of the vectors can be 8-bit, 16-bit, or 32-bit. There is no\ndistinction between data types.\n\n\n\n\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VUZP",
        "templates": {
          "A1": [
            "VUZP{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VUZP{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VUZP{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VUZP{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VUZP_VTRN": {
        "authored": " de-interleaves the elements of two vectors",
        "heading": "VUZP (alias)",
        "templates": {
          "A1": [
            "VUZP{<c>}{<q>}.32 <Dd>, <Dm>"
          ],
          "T1": [
            "VUZP{<c>}{<q>}.32 <Dd>, <Dm>"
          ]
        }
      },
      "VZIP": {
        "authored": "Vector Zip interleaves the elements of two vectors.\n\nThe elements of the vectors can be 8-bit, 16-bit, or 32-bit. There is no\ndistinction between data types.\n\n\n\n\n\nDepending on settings in the CPACR, NSACR, and HCPTR registers, and the Security\nstate and PE mode in which the instruction is executed, an attempt to execute\nthe instruction might be undefined, or trapped to Hyp mode. For more information\nsee Enabling Advanced SIMD and floating-point support.",
        "heading": "VZIP",
        "templates": {
          "A1": [
            "VZIP{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VZIP{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ],
          "T1": [
            "VZIP{<c>}{<q>}.<dt> <Dd>, <Dm>",
            "VZIP{<c>}{<q>}.<dt> <Qd>, <Qm>"
          ]
        }
      },
      "VZIP_VTRN": {
        "authored": " interleaves the elements of two vectors",
        "heading": "VZIP (alias)",
        "templates": {
          "A1": [
            "VZIP{<c>}{<q>}.32 <Dd>, <Dm>"
          ],
          "T1": [
            "VZIP{<c>}{<q>}.32 <Dd>, <Dm>"
          ]
        }
      }
    }
  },
  "keywords": {
    "DA": "Decrement After. The consecutive memory addresses end at the address in the base\nregister.",
    "DB": "Decrement Before. The consecutive memory addresses end one word below the\naddress in the base register.",
    "EA": "Empty Ascending.",
    "ED": "Empty Descending.",
    "FA": "Full Ascending.",
    "FD": "Full Descending.",
    "IA": "Increment After. The consecutive memory addresses start at the address in the\nbase register.",
    "IB": "Increment Before. The consecutive memory addresses start one word above the\naddress in the base register.",
    "ISH": "Inner Shareable is the required shareability domain, reads and writes are the\nrequired access types, both before and after the barrier instruction.",
    "ISHLD": "Inner Shareable is the required shareability domain, reads are the required\naccess type before the barrier instruction, and reads and writes are the\nrequired access types after the barrier instruction.",
    "ISHST": "Inner Shareable is the required shareability domain, writes are the required\naccess type, both before and after the barrier instruction.",
    "LD": "Full system is the required shareability domain, reads are the required access\ntype before the barrier instruction, and reads and writes are the required\naccess types after the barrier instruction.",
    "NSH": "Non-shareable is the required shareability domain, reads and writes are the\nrequired access, both before and after the barrier instruction.",
    "NSHLD": "Non-shareable is the required shareability domain, reads are the required access\ntype before the barrier instruction, and reads and writes are the required\naccess types after the barrier instruction.",
    "NSHST": "Non-shareable is the required shareability domain, writes are the required\naccess type both before and after the barrier instruction.",
    "OSH": "Outer Shareable is the required shareability domain, reads and writes are the\nrequired access types, both before and after the barrier instruction.",
    "OSHLD": "Outer Shareable is the required shareability domain, reads are the required\naccess type before the barrier instruction, and reads and writes are the\nrequired access types after the barrier instruction.",
    "OSHST": "Outer Shareable is the required shareability domain, writes are the required\naccess type, both before and after the barrier instruction.",
    "ST": "Full system is the required shareability domain, writes are the required access\ntype, both before and after the barrier instruction. SYST is a synonym for ST.\nEncoded as option = 0b1110.",
    "SY": "Full system barrier operation, encoded as option = 0b1111. Can be omitted."
  },
  "registers": {
    "base": {
      "D0": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D1": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D10": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D11": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D12": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D13": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D14": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D15": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D16": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D17": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D18": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D19": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D2": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D20": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D21": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D22": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D23": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D24": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D25": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D26": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D27": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D28": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D29": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D3": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D30": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "D31": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": ""
      },
      "D4": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D5": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D6": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D7": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "D8": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "D9": {
        "long_name": "64-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "LR": {
        "long_name": "32-bit Link Register",
        "purpose": "The link register is a special register that can hold return link information."
      },
      "PC": {
        "long_name": "32-bit Program Counter",
        "purpose": "  - When executing an A32 instruction, PC reads as the address of the current\n    instruction plus 8.\n  - When executing a T32 instruction, PC reads as the address of the current\n    instruction plus 4.\n  - Writing an address to PC causes a branch to that address."
      },
      "Q0": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "Q1": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "Q10": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q11": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q12": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q13": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q14": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q15": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q2": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "Q3": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "Q4": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "Q5": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "Q6": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "Q7": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "Q8": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "Q9": {
        "long_name": "128-bit SIMD and VFP Register",
        "purpose": "Registers D16-D31 (Q8-Q15) do not need to be preserved."
      },
      "R0": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument / result / scratch register 1.\n\nThe first four registers R0-R3 are used to pass argument values into a\nsubroutine and to return a result value from a function. They may also be used\nto hold intermediate values within a routine (but, in general, only between\nsubroutine calls)."
      },
      "R1": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument / result / scratch register 2.\n\nThe first four registers R0-R3 are used to pass argument values into a\nsubroutine and to return a result value from a function. They may also be used\nto hold intermediate values within a routine (but, in general, only between\nsubroutine calls)."
      },
      "R10": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 7.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R11": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 8.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R12": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Intra-Procedure-call scratch register.\n\nRegister R12 (IP) may be used by a linker as a scratch register between a\nroutine and any subroutine it calls. It can also be used within a routine to\nhold intermediate values between subroutine calls."
      },
      "R2": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument / scratch register 3.\n\nThe first four registers R0-R3 are used to pass argument values into a\nsubroutine and to return a result value from a function. They may also be used\nto hold intermediate values within a routine (but, in general, only between\nsubroutine calls)."
      },
      "R3": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Argument / scratch register 4.\n\nThe first four registers R0-R3 are used to pass argument values into a\nsubroutine and to return a result value from a function. They may also be used\nto hold intermediate values within a routine (but, in general, only between\nsubroutine calls)."
      },
      "R4": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 1.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R5": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 2.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R6": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 3.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R7": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 4.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R8": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Variable register 5.\n\nTypically, the registers R4-R8, R10 and R11 are used to hold the values of a\nroutine's local variables."
      },
      "R9": {
        "long_name": "32-bit General Purpose Register",
        "purpose": "Platform register.\n\nThe role of register R9 is platform specific. A virtual platform may assign any\nrole to this register and must document this usage. For example, it may\ndesignate it as the static base  in a position-independent data model, or it may\ndesignate it as the thread register in an environment with thread-local storage.\nThe usage of this register may require that the value held is persistent across\nall calls. A virtual platform that has no need for such a special register may\ndesignate R9 as an additional callee-saved variable register."
      },
      "S0": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S1": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S10": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S11": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S12": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S13": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S14": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S15": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S16": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S17": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S18": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S19": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S2": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S20": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S21": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S22": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S23": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S24": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S25": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S26": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S27": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S28": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S29": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S3": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S30": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S31": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S16-S31 (D8-D15, Q4-Q7) must be preserved across subroutine calls."
      },
      "S4": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S5": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S6": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S7": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S8": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "S9": {
        "long_name": "32-bit SIMD and VFP Register",
        "purpose": "Registers S0-S15 (D0-D7, Q0-Q3) do not need to be preserved (and can be used for\npassing arguments or returning results in standard procedure-call variants)."
      },
      "SP": {
        "long_name": "32-bit Stack Pointer",
        "purpose": "The processor uses SP as a pointer to the active stack."
      }
    },
    "encodings": {
      "MCRR|MRRC": {
        "AMEVCNTR0<n>": ["1111", "xxx", "000x"],
        "AMEVCNTR1<n>": ["1111", "xxx", "010x"],
        "CNTHP_CVAL": ["1111", "0110", "1110"],
        "CNTHV_CVAL": ["1111", "0011", "1110"],
        "CNTPCT": ["1111", "0000", "1110"],
        "CNTP_CVAL": ["1111", "0010", "1110"],
        "CNTVCT": ["1111", "0001", "1110"],
        "CNTVOFF": ["1111", "0100", "1110"],
        "CNTV_CVAL": ["1111", "0011", "1110"],
        "DBGDRAR": ["1110", "0000", "0001"],
        "DBGDSAR": ["1110", "0000", "0010"],
        "HTTBR": ["1111", "0100", "0010"],
        "ICC_ASGI1R": ["1111", "0001", "1100"],
        "ICC_SGI0R": ["1111", "0010", "1100"],
        "ICC_SGI1R": ["1111", "0000", "1100"],
        "PAR": ["1111", "0000", "0111"],
        "PMCCNTR": ["1111", "0000", "1001"],
        "TTBR0": ["1111", "0000", "0010"],
        "TTBR1": ["1111", "0001", "0010"],
        "VTTBR": ["1111", "0110", "0010"]
      },
      "MCR|MRC": {
        "ACTLR": ["1111", "000", "0001", "0000", "001"],
        "ACTLR2": ["1111", "000", "0001", "0000", "011"],
        "ADFSR": ["1111", "000", "0101", "0001", "000"],
        "AIDR": ["1111", "001", "0000", "0000", "111"],
        "AIFSR": ["1111", "000", "0101", "0001", "001"],
        "AMAIR0": ["1111", "000", "1010", "0011", "000"],
        "AMAIR1": ["1111", "000", "1010", "0011", "001"],
        "AMCFGR": ["1111", "000", "1101", "0010", "001"],
        "AMCGCR": ["1111", "000", "1101", "0010", "010"],
        "AMCNTENCLR0": ["1111", "000", "1101", "0010", "100"],
        "AMCNTENCLR1": ["1111", "000", "1101", "0011", "000"],
        "AMCNTENSET0": ["1111", "000", "1101", "0010", "101"],
        "AMCNTENSET1": ["1111", "000", "1101", "0011", "001"],
        "AMCR": ["1111", "000", "1101", "0010", "000"],
        "AMEVTYPER0<n>": ["1111", "000", "1101", "110x", "xxx"],
        "AMEVTYPER1<n>": ["1111", "000", "1101", "111x", "xxx"],
        "AMUSERENR": ["1111", "000", "1101", "0010", "011"],
        "ATS12NSOPR": ["1111", "000", "0111", "1000", "100"],
        "ATS12NSOPW": ["1111", "000", "0111", "1000", "101"],
        "ATS12NSOUR": ["1111", "000", "0111", "1000", "110"],
        "ATS12NSOUW": ["1111", "000", "0111", "1000", "111"],
        "ATS1CPR": ["1111", "000", "0111", "1000", "000"],
        "ATS1CPRP": ["1111", "000", "0111", "1001", "000"],
        "ATS1CPW": ["1111", "000", "0111", "1000", "001"],
        "ATS1CPWP": ["1111", "000", "0111", "1001", "001"],
        "ATS1CUR": ["1111", "000", "0111", "1000", "010"],
        "ATS1CUW": ["1111", "000", "0111", "1000", "011"],
        "ATS1HR": ["1111", "100", "0111", "1000", "000"],
        "ATS1HW": ["1111", "100", "0111", "1000", "001"],
        "BPIALL": ["1111", "000", "0111", "0101", "110"],
        "BPIALLIS": ["1111", "000", "0111", "0001", "110"],
        "BPIMVA": ["1111", "000", "0111", "0101", "111"],
        "CCSIDR": ["1111", "001", "0000", "0000", "000"],
        "CCSIDR2": ["1111", "001", "0000", "0000", "010"],
        "CFPRCTX": ["1111", "000", "0111", "0011", "100"],
        "CLIDR": ["1111", "001", "0000", "0000", "001"],
        "CNTFRQ": ["1111", "000", "1110", "0000", "000"],
        "CNTHCTL": ["1111", "100", "1110", "0001", "000"],
        "CNTHP_CTL": ["1111", "100", "1110", "0010", "001"],
        "CNTHP_TVAL": ["1111", "100", "1110", "0010", "000"],
        "CNTHV_CTL": ["1111", "000", "1110", "0011", "001"],
        "CNTHV_TVAL": ["1111", "000", "1110", "0011", "000"],
        "CNTKCTL": ["1111", "000", "1110", "0001", "000"],
        "CNTP_CTL": ["1111", "000", "1110", "0010", "001"],
        "CNTP_TVAL": ["1111", "000", "1110", "0010", "000"],
        "CNTV_CTL": ["1111", "000", "1110", "0011", "001"],
        "CNTV_TVAL": ["1111", "000", "1110", "0011", "000"],
        "CONTEXTIDR": ["1111", "000", "1101", "0000", "001"],
        "CP15DMB": ["1111", "000", "0111", "1010", "101"],
        "CP15DSB": ["1111", "000", "0111", "1010", "100"],
        "CP15ISB": ["1111", "000", "0111", "0101", "100"],
        "CPACR": ["1111", "000", "0001", "0000", "010"],
        "CPPRCTX": ["1111", "000", "0111", "0011", "111"],
        "CSSELR": ["1111", "010", "0000", "0000", "000"],
        "CTR": ["1111", "000", "0000", "0000", "001"],
        "DACR": ["1111", "000", "0011", "0000", "000"],
        "DBGAUTHSTATUS": ["1110", "000", "0111", "1110", "110"],
        "DBGBCR<n>": ["1110", "000", "0000", "xxxx", "101"],
        "DBGBVR<n>": ["1110", "000", "0000", "xxxx", "100"],
        "DBGBXVR<n>": ["1110", "000", "0001", "xxxx", "001"],
        "DBGCLAIMCLR": ["1110", "000", "0111", "1001", "110"],
        "DBGCLAIMSET": ["1110", "000", "0111", "1000", "110"],
        "DBGDCCINT": ["1110", "000", "0000", "0010", "000"],
        "DBGDEVID": ["1110", "000", "0111", "0010", "111"],
        "DBGDEVID1": ["1110", "000", "0111", "0001", "111"],
        "DBGDEVID2": ["1110", "000", "0111", "0000", "111"],
        "DBGDIDR": ["1110", "000", "0000", "0000", "000"],
        "DBGDRAR": ["1110", "000", "0001", "0000", "000"],
        "DBGDSAR": ["1110", "000", "0010", "0000", "000"],
        "DBGDSCRext": ["1110", "000", "0000", "0010", "010"],
        "DBGDSCRint": ["1110", "000", "0000", "0001", "000"],
        "DBGDTRRXext": ["1110", "000", "0000", "0000", "010"],
        "DBGDTRRXint": ["1110", "000", "0000", "0101", "000"],
        "DBGDTRTXext": ["1110", "000", "0000", "0011", "010"],
        "DBGDTRTXint": ["1110", "000", "0000", "0101", "000"],
        "DBGOSDLR": ["1110", "000", "0001", "0011", "100"],
        "DBGOSECCR": ["1110", "000", "0000", "0110", "010"],
        "DBGOSLAR": ["1110", "000", "0001", "0000", "100"],
        "DBGOSLSR": ["1110", "000", "0001", "0001", "100"],
        "DBGPRCR": ["1110", "000", "0001", "0100", "100"],
        "DBGVCR": ["1110", "000", "0000", "0111", "000"],
        "DBGWCR<n>": ["1110", "000", "0000", "xxxx", "111"],
        "DBGWFAR": ["1110", "000", "0000", "0110", "000"],
        "DBGWVR<n>": ["1110", "000", "0000", "xxxx", "110"],
        "DCCIMVAC": ["1111", "000", "0111", "1110", "001"],
        "DCCISW": ["1111", "000", "0111", "1110", "010"],
        "DCCMVAC": ["1111", "000", "0111", "1010", "001"],
        "DCCMVAU": ["1111", "000", "0111", "1011", "001"],
        "DCCSW": ["1111", "000", "0111", "1010", "010"],
        "DCIMVAC": ["1111", "000", "0111", "0110", "001"],
        "DCISW": ["1111", "000", "0111", "0110", "010"],
        "DFAR": ["1111", "000", "0110", "0000", "000"],
        "DFSR": ["1111", "000", "0101", "0000", "000"],
        "DISR": ["1111", "000", "1100", "0001", "001"],
        "DLR": ["1111", "011", "0100", "0101", "001"],
        "DSPSR": ["1111", "011", "0100", "0101", "000"],
        "DTLBIALL": ["1111", "000", "1000", "0110", "000"],
        "DTLBIASID": ["1111", "000", "1000", "0110", "010"],
        "DTLBIMVA": ["1111", "000", "1000", "0110", "001"],
        "DVPRCTX": ["1111", "000", "0111", "0011", "101"],
        "ERRIDR": ["1111", "000", "0101", "0011", "000"],
        "ERRSELR": ["1111", "000", "0101", "0011", "001"],
        "ERXADDR": ["1111", "000", "0101", "0100", "011"],
        "ERXADDR2": ["1111", "000", "0101", "0100", "111"],
        "ERXCTLR": ["1111", "000", "0101", "0100", "001"],
        "ERXCTLR2": ["1111", "000", "0101", "0100", "101"],
        "ERXFR": ["1111", "000", "0101", "0100", "000"],
        "ERXFR2": ["1111", "000", "0101", "0100", "100"],
        "ERXMISC0": ["1111", "000", "0101", "0101", "000"],
        "ERXMISC1": ["1111", "000", "0101", "0101", "001"],
        "ERXMISC2": ["1111", "000", "0101", "0101", "100"],
        "ERXMISC3": ["1111", "000", "0101", "0101", "101"],
        "ERXMISC4": ["1111", "000", "0101", "0101", "010"],
        "ERXMISC5": ["1111", "000", "0101", "0101", "011"],
        "ERXMISC6": ["1111", "000", "0101", "0101", "110"],
        "ERXMISC7": ["1111", "000", "0101", "0101", "111"],
        "ERXSTATUS": ["1111", "000", "0101", "0100", "010"],
        "FCSEIDR": ["1111", "000", "1101", "0000", "000"],
        "HACR": ["1111", "100", "0001", "0001", "111"],
        "HACTLR": ["1111", "100", "0001", "0000", "001"],
        "HACTLR2": ["1111", "100", "0001", "0000", "011"],
        "HADFSR": ["1111", "100", "0101", "0001", "000"],
        "HAIFSR": ["1111", "100", "0101", "0001", "001"],
        "HAMAIR0": ["1111", "100", "1010", "0011", "000"],
        "HAMAIR1": ["1111", "100", "1010", "0011", "001"],
        "HCPTR": ["1111", "100", "0001", "0001", "010"],
        "HCR": ["1111", "100", "0001", "0001", "000"],
        "HCR2": ["1111", "100", "0001", "0001", "100"],
        "HDCR": ["1111", "100", "0001", "0001", "001"],
        "HDFAR": ["1111", "100", "0110", "0000", "000"],
        "HIFAR": ["1111", "100", "0110", "0000", "010"],
        "HMAIR0": ["1111", "100", "1010", "0010", "000"],
        "HMAIR1": ["1111", "100", "1010", "0010", "001"],
        "HPFAR": ["1111", "100", "0110", "0000", "100"],
        "HRMR": ["1111", "100", "1100", "0000", "010"],
        "HSCTLR": ["1111", "100", "0001", "0000", "000"],
        "HSR": ["1111", "100", "0101", "0010", "000"],
        "HSTR": ["1111", "100", "0001", "0001", "011"],
        "HTCR": ["1111", "100", "0010", "0000", "010"],
        "HTPIDR": ["1111", "100", "1101", "0000", "010"],
        "HTRFCR": ["1111", "100", "0001", "0010", "001"],
        "HVBAR": ["1111", "100", "1100", "0000", "000"],
        "ICC_AP0R<n>": ["1111", "000", "1100", "1000", "1xx"],
        "ICC_AP1R<n>": ["1111", "000", "1100", "1001", "0xx"],
        "ICC_BPR0": ["1111", "000", "1100", "1000", "011"],
        "ICC_BPR1": ["1111", "000", "1100", "1100", "011"],
        "ICC_CTLR": ["1111", "000", "1100", "1100", "100"],
        "ICC_DIR": ["1111", "000", "1100", "1011", "001"],
        "ICC_EOIR0": ["1111", "000", "1100", "1000", "001"],
        "ICC_EOIR1": ["1111", "000", "1100", "1100", "001"],
        "ICC_HPPIR0": ["1111", "000", "1100", "1000", "010"],
        "ICC_HPPIR1": ["1111", "000", "1100", "1100", "010"],
        "ICC_HSRE": ["1111", "100", "1100", "1001", "101"],
        "ICC_IAR0": ["1111", "000", "1100", "1000", "000"],
        "ICC_IAR1": ["1111", "000", "1100", "1100", "000"],
        "ICC_IGRPEN0": ["1111", "000", "1100", "1100", "110"],
        "ICC_IGRPEN1": ["1111", "000", "1100", "1100", "111"],
        "ICC_MCTLR": ["1111", "110", "1100", "1100", "100"],
        "ICC_MGRPEN1": ["1111", "110", "1100", "1100", "111"],
        "ICC_MSRE": ["1111", "110", "1100", "1100", "101"],
        "ICC_PMR": ["1111", "000", "0100", "0110", "000"],
        "ICC_RPR": ["1111", "000", "1100", "1011", "011"],
        "ICC_SRE": ["1111", "000", "1100", "1100", "101"],
        "ICH_AP0R<n>": ["1111", "100", "1100", "1000", "0xx"],
        "ICH_AP1R<n>": ["1111", "100", "1100", "1001", "0xx"],
        "ICH_EISR": ["1111", "100", "1100", "1011", "011"],
        "ICH_ELRSR": ["1111", "100", "1100", "1011", "101"],
        "ICH_HCR": ["1111", "100", "1100", "1011", "000"],
        "ICH_LR<n>": ["1111", "100", "1100", "011x", "xxx"],
        "ICH_LRC<n>": ["1111", "100", "1100", "111x", "xxx"],
        "ICH_MISR": ["1111", "100", "1100", "1011", "010"],
        "ICH_VMCR": ["1111", "100", "1100", "1011", "111"],
        "ICH_VTR": ["1111", "100", "1100", "1011", "001"],
        "ICIALLU": ["1111", "000", "0111", "0101", "000"],
        "ICIALLUIS": ["1111", "000", "0111", "0001", "000"],
        "ICIMVAU": ["1111", "000", "0111", "0101", "001"],
        "ICV_AP0R<n>": ["1111", "000", "1100", "1000", "1xx"],
        "ICV_AP1R<n>": ["1111", "000", "1100", "1001", "0xx"],
        "ICV_BPR0": ["1111", "000", "1100", "1000", "011"],
        "ICV_BPR1": ["1111", "000", "1100", "1100", "011"],
        "ICV_CTLR": ["1111", "000", "1100", "1100", "100"],
        "ICV_DIR": ["1111", "000", "1100", "1011", "001"],
        "ICV_EOIR0": ["1111", "000", "1100", "1000", "001"],
        "ICV_EOIR1": ["1111", "000", "1100", "1100", "001"],
        "ICV_HPPIR0": ["1111", "000", "1100", "1000", "010"],
        "ICV_HPPIR1": ["1111", "000", "1100", "1100", "010"],
        "ICV_IAR0": ["1111", "000", "1100", "1000", "000"],
        "ICV_IAR1": ["1111", "000", "1100", "1100", "000"],
        "ICV_IGRPEN0": ["1111", "000", "1100", "1100", "110"],
        "ICV_IGRPEN1": ["1111", "000", "1100", "1100", "111"],
        "ICV_PMR": ["1111", "000", "0100", "0110", "000"],
        "ICV_RPR": ["1111", "000", "1100", "1011", "011"],
        "ID_AFR0": ["1111", "000", "0000", "0001", "011"],
        "ID_DFR0": ["1111", "000", "0000", "0001", "010"],
        "ID_ISAR0": ["1111", "000", "0000", "0010", "000"],
        "ID_ISAR1": ["1111", "000", "0000", "0010", "001"],
        "ID_ISAR2": ["1111", "000", "0000", "0010", "010"],
        "ID_ISAR3": ["1111", "000", "0000", "0010", "011"],
        "ID_ISAR4": ["1111", "000", "0000", "0010", "100"],
        "ID_ISAR5": ["1111", "000", "0000", "0010", "101"],
        "ID_ISAR6": ["1111", "000", "0000", "0010", "111"],
        "ID_MMFR0": ["1111", "000", "0000", "0001", "100"],
        "ID_MMFR1": ["1111", "000", "0000", "0001", "101"],
        "ID_MMFR2": ["1111", "000", "0000", "0001", "110"],
        "ID_MMFR3": ["1111", "000", "0000", "0001", "111"],
        "ID_MMFR4": ["1111", "000", "0000", "0010", "110"],
        "ID_PFR0": ["1111", "000", "0000", "0001", "000"],
        "ID_PFR1": ["1111", "000", "0000", "0001", "001"],
        "ID_PFR2": ["1111", "000", "0000", "0011", "100"],
        "IFAR": ["1111", "000", "0110", "0000", "010"],
        "IFSR": ["1111", "000", "0101", "0000", "001"],
        "ISR": ["1111", "000", "1100", "0001", "000"],
        "ITLBIALL": ["1111", "000", "1000", "0101", "000"],
        "ITLBIASID": ["1111", "000", "1000", "0101", "010"],
        "ITLBIMVA": ["1111", "000", "1000", "0101", "001"],
        "JIDR": ["1110", "111", "0000", "0000", "000"],
        "JMCR": ["1110", "111", "0010", "0000", "000"],
        "JOSCR": ["1110", "111", "0001", "0000", "000"],
        "MAIR0": ["1111", "000", "1010", "0010", "000"],
        "MAIR1": ["1111", "000", "1010", "0010", "001"],
        "MIDR": ["1111", "000", "0000", "0000", "000"],
        "MPIDR": ["1111", "000", "0000", "0000", "101"],
        "MVBAR": ["1111", "000", "1100", "0000", "001"],
        "NMRR": ["1111", "000", "1010", "0010", "001"],
        "NSACR": ["1111", "000", "0001", "0001", "010"],
        "PAR": ["1111", "000", "0111", "0100", "000"],
        "PMCCFILTR": ["1111", "000", "1110", "1111", "111"],
        "PMCCNTR": ["1111", "000", "1001", "1101", "000"],
        "PMCEID0": ["1111", "000", "1001", "1100", "110"],
        "PMCEID1": ["1111", "000", "1001", "1100", "111"],
        "PMCEID2": ["1111", "000", "1001", "1110", "100"],
        "PMCEID3": ["1111", "000", "1001", "1110", "101"],
        "PMCNTENCLR": ["1111", "000", "1001", "1100", "010"],
        "PMCNTENSET": ["1111", "000", "1001", "1100", "001"],
        "PMCR": ["1111", "000", "1001", "1100", "000"],
        "PMEVCNTR<n>": ["1111", "000", "1110", "01xx", "xxx"],
        "PMEVTYPER<n>": ["1111", "000", "1110", "11xx", "xxx"],
        "PMINTENCLR": ["1111", "000", "1001", "1110", "010"],
        "PMINTENSET": ["1111", "000", "1001", "1110", "001"],
        "PMMIR": ["1111", "000", "1001", "1110", "110"],
        "PMOVSR": ["1111", "000", "1001", "1100", "011"],
        "PMOVSSET": ["1111", "000", "1001", "1110", "011"],
        "PMSELR": ["1111", "000", "1001", "1100", "101"],
        "PMSWINC": ["1111", "000", "1001", "1100", "100"],
        "PMUSERENR": ["1111", "000", "1001", "1110", "000"],
        "PMXEVCNTR": ["1111", "000", "1001", "1101", "010"],
        "PMXEVTYPER": ["1111", "000", "1001", "1101", "001"],
        "PRRR": ["1111", "000", "1010", "0010", "000"],
        "REVIDR": ["1111", "000", "0000", "0000", "110"],
        "RMR": ["1111", "000", "1100", "0000", "010"],
        "RVBAR": ["1111", "000", "1100", "0000", "001"],
        "SCR": ["1111", "000", "0001", "0001", "000"],
        "SCTLR": ["1111", "000", "0001", "0000", "000"],
        "SDCR": ["1111", "000", "0001", "0011", "001"],
        "SDER": ["1111", "000", "0001", "0001", "001"],
        "TCMTR": ["1111", "000", "0000", "0000", "010"],
        "TLBIALL": ["1111", "000", "1000", "0111", "000"],
        "TLBIALLH": ["1111", "100", "1000", "0111", "000"],
        "TLBIALLHIS": ["1111", "100", "1000", "0011", "000"],
        "TLBIALLIS": ["1111", "000", "1000", "0011", "000"],
        "TLBIALLNSNH": ["1111", "100", "1000", "0111", "100"],
        "TLBIALLNSNHIS": ["1111", "100", "1000", "0011", "100"],
        "TLBIASID": ["1111", "000", "1000", "0111", "010"],
        "TLBIASIDIS": ["1111", "000", "1000", "0011", "010"],
        "TLBIIPAS2": ["1111", "100", "1000", "0100", "001"],
        "TLBIIPAS2IS": ["1111", "100", "1000", "0000", "001"],
        "TLBIIPAS2L": ["1111", "100", "1000", "0100", "101"],
        "TLBIIPAS2LIS": ["1111", "100", "1000", "0000", "101"],
        "TLBIMVA": ["1111", "000", "1000", "0111", "001"],
        "TLBIMVAA": ["1111", "000", "1000", "0111", "011"],
        "TLBIMVAAIS": ["1111", "000", "1000", "0011", "011"],
        "TLBIMVAAL": ["1111", "000", "1000", "0111", "111"],
        "TLBIMVAALIS": ["1111", "000", "1000", "0011", "111"],
        "TLBIMVAH": ["1111", "100", "1000", "0111", "001"],
        "TLBIMVAHIS": ["1111", "100", "1000", "0011", "001"],
        "TLBIMVAIS": ["1111", "000", "1000", "0011", "001"],
        "TLBIMVAL": ["1111", "000", "1000", "0111", "101"],
        "TLBIMVALH": ["1111", "100", "1000", "0111", "101"],
        "TLBIMVALHIS": ["1111", "100", "1000", "0011", "101"],
        "TLBIMVALIS": ["1111", "000", "1000", "0011", "101"],
        "TLBTR": ["1111", "000", "0000", "0000", "011"],
        "TPIDRPRW": ["1111", "000", "1101", "0000", "100"],
        "TPIDRURO": ["1111", "000", "1101", "0000", "011"],
        "TPIDRURW": ["1111", "000", "1101", "0000", "010"],
        "TRFCR": ["1111", "000", "0001", "0010", "001"],
        "TTBCR": ["1111", "000", "0010", "0000", "010"],
        "TTBCR2": ["1111", "000", "0010", "0000", "011"],
        "TTBR0": ["1111", "000", "0010", "0000", "000"],
        "TTBR1": ["1111", "000", "0010", "0000", "001"],
        "VBAR": ["1111", "000", "1100", "0000", "000"],
        "VDFSR": ["1111", "100", "0101", "0010", "011"],
        "VDISR": ["1111", "100", "1100", "0001", "001"],
        "VMPIDR": ["1111", "100", "0000", "0000", "101"],
        "VPIDR": ["1111", "100", "0000", "0000", "000"],
        "VTCR": ["1111", "100", "0010", "0001", "010"]
      },
      "MRS|MSR": {
        "ELR_hyp": ["0", "1", "1110"],
        "SPSR_abt": ["1", "1", "0100"],
        "SPSR_fiq": ["1", "0", "1110"],
        "SPSR_hyp": ["1", "1", "1110"],
        "SPSR_irq": ["1", "1", "0000"],
        "SPSR_mon": ["1", "1", "1100"],
        "SPSR_svc": ["1", "1", "0010"],
        "SPSR_und": ["1", "1", "0110"]
      },
      "VMRS|VMSR": {
        "FPEXC": ["1000"],
        "FPSCR": ["0001"],
        "FPSID": ["0000"],
        "MVFR0": ["0111"],
        "MVFR1": ["0110"],
        "MVFR2": ["0101"]
      }
    },
    "instructions": {
      "ATS12NSOPR": {
        "long_name": "Address Translate Stages 1 and 2 Non-secure Only PL1 Read",
        "purpose": "Performs stage 1 and 2 address translations as defined for PL1 and the Non-\nsecure state, with permissions as if reading from the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This instruction takes a VA as input. The resulting\n              address is the PA that is the output address of the stage 2\n              translation."
      },
      "ATS12NSOPW": {
        "long_name": "Address Translate Stages 1 and 2 Non-secure Only PL1 Write",
        "purpose": "Performs stage 1 and 2 address translations as defined for PL1 and the Non-\nsecure state, with permissions as if writing to the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This instruction takes a VA as input. The resulting\n              address is the PA that is the output address of the stage 2\n              translation."
      },
      "ATS12NSOUR": {
        "long_name": "Address Translate Stages 1 and 2 Non-secure Only Unprivileged Read",
        "purpose": "Performs stage 1 and 2 address translations as defined for PL0 and the Non-\nsecure state, with permissions as if reading from the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This instruction takes a VA as input. The resulting\n              address is the PA that is the output address of the stage 2\n              translation."
      },
      "ATS12NSOUW": {
        "long_name": "Address Translate Stages 1 and 2 Non-secure Only Unprivileged Write",
        "purpose": "Performs stage 1 and 2 address translations as defined for PL0 and the Non-\nsecure state, with permissions as if writing to the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This instruction takes a VA as input. The resulting\n              address is the PA that is the output address of the stage 2\n              translation."
      },
      "ATS1CPR": {
        "long_name": "Address Translate Stage 1 Current state PL1 Read",
        "purpose": "Performs stage 1 address translation as defined for PL1 and the current Security\nstate, with permissions as if reading from the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This instruction takes a VA as input. In an\n              implementation where EL2 is enabled for the current Security\n              state, the resulting address is the IPA that is the output address\n              of the stage 1 translation. Otherwise, the resulting address is a\n              PA."
      },
      "ATS1CPRP": {
        "long_name": "Address Translate Stage 1 Current state PL1 Read PAN",
        "purpose": "Performs a stage 1 address translation at PL1 and in the current Security state,\nwhere the value of PSTATE.PAN determines if a read from a location will generate\na permission fault for a privileged access.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This instruction takes a VA as input. In an\n              implementation where EL2 is enabled for the current Security\n              state, the resulting address is the IPA that is the output address\n              of the stage 1 translation. Otherwise, the resulting address is a\n              PA."
      },
      "ATS1CPW": {
        "long_name": "Address Translate Stage 1 Current state PL1 Write",
        "purpose": "Performs stage 1 address translation as defined for PL1 and the current Security\nstate, with permissions as if writing to the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This instruction takes a VA as input. In an\n              implementation where EL2 is enabled for the current Security\n              state, the resulting address is the IPA that is the output address\n              of the stage 1 translation. Otherwise, the resulting address is a\n              PA."
      },
      "ATS1CPWP": {
        "long_name": "Address Translate Stage 1 Current state PL1 Write PAN",
        "purpose": "When ARMv8.2-ATS1E1 is implemented, performs a stage 1 address translation at\nPL1 and in the current Security state, where the value of PSTATE.PAN determines\nif a write to the location will generate a permission fault for a privileged\naccess.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This instruction takes a VA as input. In an\n              implementation where EL2 is enabled for the current Security\n              state, the resulting address is the IPA that is the output address\n              of the stage 1 translation. Otherwise, the resulting address is a\n              PA."
      },
      "ATS1CUR": {
        "long_name": "Address Translate Stage 1 Current state Unprivileged Read",
        "purpose": "Performs stage 1 address translation as defined for PL0 and the current Security\nstate, with permissions as if reading from the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This instruction takes a VA as input. In an\n              implementation where EL2 is enabled for the current Security\n              state, the resulting address is the IPA that is the output address\n              of the stage 1 translation. Otherwise, the resulting address is a\n              PA."
      },
      "ATS1CUW": {
        "long_name": "Address Translate Stage 1 Current state Unprivileged Write",
        "purpose": "Performs stage 1 address translation as defined for PL0 and the current Security\nstate, with permissions as if writing to the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This instruction takes a VA as input. In an\n              implementation where EL2 is enabled for the current Security\n              state, the resulting address is the IPA that is the output address\n              of the stage 1 translation. Otherwise, the resulting address is a\n              PA."
      },
      "ATS1HR": {
        "long_name": "Address Translate Stage 1 Hyp mode Read",
        "purpose": "Performs stage 1 address translation as defined for PL2 and the Non-secure\nstate, with permissions as if reading from the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This instruction takes a VA as input. The resulting\n              address is the PA that is the output address of the translation."
      },
      "ATS1HW": {
        "long_name": "Address Translate Stage 1 Hyp mode Write",
        "purpose": "Performs stage 1 address translation as defined for PL2 and the Non-secure\nstate, with permissions as if writing to the given virtual address.\n\nbits [0:31] - Input address for translation. The resulting address can be read\n              from the PAR. This instruction takes a VA as input. The resulting\n              address is the PA that is the output address of the translation."
      },
      "BPIALL": {
        "long_name": "Branch Predictor Invalidate All",
        "purpose": "Invalidate all entries from branch predictors."
      },
      "BPIALLIS": {
        "long_name": "Branch Predictor Invalidate All, Inner Shareable",
        "purpose": "Invalidate all entries from branch predictors Inner Shareable."
      },
      "BPIMVA": {
        "long_name": "Branch Predictor Invalidate by VA",
        "purpose": "Invalidate virtual address from branch predictors.\n\nbits [0:31] - Virtual address to use."
      },
      "CFPRCTX": {
        "long_name": "Control Flow Prediction Restriction by Context",
        "purpose": "Control Flow Prediction Restriction by Context applies to all Control Flow\nPrediction Resources that predict execution based on information gathered within\nthe target execution context or contexts.\n\nWhen this instruction is complete and synchronized Control Flow Prediction\nResources are prevented from:\n\n  - Affecting later speculative execution within the target execution context or\ncontexts.\n  - Being observable through side channels.\n\nThis  instruction is guaranteed to be complete following a DSB that covers both\nread and write behavior on the same PE as executed the original restriction\ninstruction, and a subsequent context synchronization event is required to\nensure that the effect of the completion of the instructions is synchronized to\nthe current execution.\n\nThis instruction does not require the invalidation of prediction structures so\nlong as the behavior described for completion of this instruction is met by the\nimplementation.On some implementations the instruction is likely to take a\nsignificant number of cycles to execute. This instruction is expected to be used\nvery rarely, such as on the roll-over of an ASID or VMID, but should not be used\non every context switch.\n\nGVMID, bit [27]    - Execution of this instruction applies to all VMIDs or a\n                     specified VMID.\nNS, bit [26]       - Security State.\nEL, bits [24:25]   - Exception Level.\nVMID, bits [16:23] - Only applies when bit[27] is 0 and either of.\nGASID, bit [8]     - Execution of this instruction applies to all ASIDs or a\n                     specified ASID.\nASID, bits [0:7]   - Only applies for an EL0 context and when bit[8] is 0."
      },
      "CP15DMB": {
        "long_name": "Data Memory Barrier System instruction",
        "purpose": "Performs a Data Memory Barrier.\n\nARM deprecates any use of this operation, and strongly recommends that software\nuse the DMB instruction instead."
      },
      "CP15DSB": {
        "long_name": "Data Synchronization Barrier System instruction",
        "purpose": "Performs a Data Synchronization Barrier.\n\nARM deprecates any use of this operation, and strongly recommends that software\nuse the DSB instruction instead."
      },
      "CP15ISB": {
        "long_name": "Instruction Synchronization Barrier System instruction",
        "purpose": "Performs an Instruction Synchronization Barrier.\n\nARM deprecates any use of this operation, and strongly recommends that software\nuse the ISB instruction instead."
      },
      "CPPRCTX": {
        "long_name": "Cache Prefetch Prediction Restriction by Context",
        "purpose": "Cache Prefetch Prediction Restriction by Context applies to all Cache Allocation\nResources that predict cache allocations based on information gathered within\nthe target execution context or contexts.\n\nWhen this instruction is complete and synchronized Cache Allocation Resources\nare prevented from:\n\n  - Affecting later speculative execution within the target execution context or\ncontexts.\n  - Being observable through side channels.\n\nThis instruction applies to all:\n\n  - Instruction caches.\n  - Data caches.\n  - TLB prefetching hardware used by the executing PE that applies to the\nsupplied context or contexts.\n\nThis  instruction is guaranteed to be complete following a DSB that covers both\nread and write behavior on the same PE as executed the original restriction\ninstruction, and a subsequent context synchronization event is required to\nensure that the effect of the completion of the instructions is synchronized to\nthe current execution.\n\nThis instruction does not require the invalidation of Cache Allocation Resources\nso long as the behavior described for completion of this instruction is met by\nthe implementation.On some implementations the instruction is likely to take a\nsignificant number of cycles to execute. This instruction is expected to be used\nvery rarely, such as on the roll-over of an ASID or VMID, but should not be used\non every context switch.\n\nGVMID, bit [27]    - Execution of this instruction applies to all VMIDs or a\n                     specified VMID.\nNS, bit [26]       - Security State.\nEL, bits [24:25]   - Exception Level.\nVMID, bits [16:23] - Only applies when bit[27] is 0 and either.\nGASID, bit [8]     - Execution of this instruction applies to all ASIDs or a\n                     specified ASID.\nASID, bits [0:7]   - Only applies for an EL0 context and when bit[8] is 0."
      },
      "DCCIMVAC": {
        "long_name": "Data Cache line Clean and Invalidate by VA to PoC",
        "purpose": "Clean and Invalidate data or unified cache line by virtual address to PoC.\n\nbits [0:31] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "DCCISW": {
        "long_name": "Data Cache line Clean and Invalidate by Set/Way",
        "purpose": "Clean and Invalidate data or unified cache line by set/way.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "DCCMVAC": {
        "long_name": "Data Cache line Clean by VA to PoC",
        "purpose": "Clean data or unified cache line by virtual address to PoC.\n\nbits [0:31] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "DCCMVAU": {
        "long_name": "Data Cache line Clean by VA to PoU",
        "purpose": "Clean data or unified cache line by virtual address to PoU.\n\nbits [0:31] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "DCCSW": {
        "long_name": "Data Cache line Clean by Set/Way",
        "purpose": "Clean data or unified cache line by set/way.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "DCIMVAC": {
        "long_name": "Data Cache line Invalidate by VA to PoC",
        "purpose": "Invalidate data or unified cache line by virtual address to PoC.\n\nbits [0:31] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "DCISW": {
        "long_name": "Data Cache line Invalidate by Set/Way",
        "purpose": "Invalidate data or unified cache line by set/way.\n\nSetWay, bits [4:31] - Contains two fields:\n                        - Way, bits[31:32-A], the number of the way to operate\n                      on.\n                        - Set, bits[B-1:L], the number of the set to operate on.\n                      Bits[L-1:4] are res0. A = Log_2(ASSOCIATIVITY), L =\n                      Log_2(LINELEN), B = (L + S), S = Log_2(NSETS).\n                      ASSOCIATIVITY, LINELEN (line length, in bytes), and NSETS\n                      (number of sets) have their usual meanings and are the\n                      values for the cache level being operated on. The values\n                      of A and S are rounded up to the next integer.\nLevel, bits [1:3]   - Cache level to operate on, minus 1. For example, this\n                      field is 0 for operations on L1 cache, or 1 for operations\n                      on L2 cache."
      },
      "DTLBIALL": {
        "long_name": "Data TLB Invalidate All",
        "purpose": "Invalidate all cached copies of translation table entries from data TLBs that\nare from any level of the translation table walk. The entries that are\ninvalidated are as follows:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, all entries that would\nbe required for the Secure EL1&0 translation regime.\n  - If executed in Secure state when EL3 is using AArch32, all entries that\nwould be required for the Secure PL1&0 translation regime.\n  - If executed at Non-secure EL1, all stage 1 translation table entries that\nwould be required for the Non-secure PL1&0 translation regime and, if EL2 is\nimplemented, they must match the current VMID.\n  - If executed at EL2, the stage 1 or stage 2 translation table entries that\nwould be required for the Non-secure PL1&0 translation regime and matches the\ncurrent VMID.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nARM deprecates the use of this instruction. It is only provided for backwards\ncompatibility with earlier versions of the ARM architecture."
      },
      "DTLBIASID": {
        "long_name": "Data TLB Invalidate by ASID match",
        "purpose": "Invalidate all cached copies of translation table entries from data TLBs that\nmeet the following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used for the specified ASID, and either:\n    - Is from a level of lookup above the final level.\n    - Is a non-global entry from the final level of lookup.\n  - If EL2 is implemented, the entry would be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nARM deprecates the use of this instruction. It is only provided for backwards\ncompatibility with earlier versions of the ARM architecture.\n\nASID, bits [0:7] - ASID value to match. Any TLB entries for non-global pages\n                   that match the ASID values will be affected by this\n                   operation."
      },
      "DTLBIMVA": {
        "long_name": "Data TLB Invalidate by VA",
        "purpose": "Invalidate all cached copies of translation table entries from data TLBs that\nmeet the following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified address, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - If EL2 is implemented, the entry would be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nARM deprecates the use of this instruction. It is only provided for backwards\ncompatibility with earlier versions of the ARM architecture.\n\nVA, bits [12:31] - Virtual address to match.\nASID, bits [0:7] - ASID value to match."
      },
      "DVPRCTX": {
        "long_name": "Data Value Prediction Restriction by Context",
        "purpose": "Data Value Prediction Restriction by Context applies to all Data Value\nPrediction Resources that predict execution based on information gathered within\nthe target execution context or contexts.\n\nWhen this instruction is complete and synchronized Data Value Prediction\nResources are prevented from:\n\n  - Affecting later speculative execution within the target execution context or\ncontexts.\n  - Being observable through side channels.\n\nThis  instruction is guaranteed to be complete following a DSB that covers both\nread and write behavior on the same PE as executed the original restriction\ninstruction, and a subsequent context synchronization event is required to\nensure that the effect of the completion of the instructions is synchronized to\nthe current execution.\n\nThis instruction does not require the invalidation of prediction structures so\nlong as the behavior described for completion of this instruction is met by the\nimplementation.On some implementations the instruction is likely to take a\nsignificant number of cycles to execute. This instruction is expected to be used\nvery rarely, such as on the roll-over of an ASID or VMID, but should not be used\non every context switch.\n\nGVMID, bit [27]    - Execution of this instruction applies to all VMIDs or a\n                     specified VMID.\nNS, bit [26]       - Security State.\nEL, bits [24:25]   - Exception Level\nVMID, bits [16:23] - Only applies when bit[27] is 0 and either.\nGASID, bit [8]     - Execution of this instruction applies to all ASIDs or a\n                     specified ASID.\nASID, bits [0:7]   - Only applies for an EL0 context and when bit[8] is 0."
      },
      "ICIALLU": {
        "long_name": "Instruction Cache Invalidate All to PoU",
        "purpose": "Invalidate all instruction caches to PoU. If branch predictors are\narchitecturally visible, also flush branch predictors."
      },
      "ICIALLUIS": {
        "long_name": "Instruction Cache Invalidate All to PoU, Inner Shareable",
        "purpose": "Invalidate all instruction caches Inner Shareable to PoU. If branch predictors\nare architecturally visible, also flush branch predictors."
      },
      "ICIMVAU": {
        "long_name": "Instruction Cache line Invalidate by VA to PoU",
        "purpose": "Invalidate instruction cache line by virtual address to PoU.\n\nbits [0:31] - Virtual address to use. No alignment restrictions apply to this\n              VA."
      },
      "ITLBIALL": {
        "long_name": "Instruction TLB Invalidate All",
        "purpose": "Invalidate all cached copies of translation table entries from instruction TLBs\nthat are from any level of the translation table walk. The entries that are\ninvalidated are as follows:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, all entries that would\nbe required for the Secure EL1&0 translation regime.\n  - If executed in Secure state when EL3 is using AArch32, all entries that\nwould be required for the Secure PL1&0 translation regime.\n  - If executed at Non-secure EL1, all stage 1 translation table entries that\nwould be required for the Non-secure PL1&0 translation regime and, if EL2 is\nimplemented, they must match the current VMID.\n  - If executed at EL2, the stage 1 or stage 2 translation table entries that\nwould be required for the Non-secure PL1&0 translation regime and matches the\ncurrent VMID.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nARM deprecates the use of this instruction. It is only provided for backwards\ncompatibility with earlier versions of the ARM architecture."
      },
      "ITLBIASID": {
        "long_name": "Instruction TLB Invalidate by ASID match",
        "purpose": "Invalidate all cached copies of translation table entries from instruction TLBs\nthat meet the following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used for the specified ASID, and either:\n    - Is from a level of lookup above the final level.\n    - Is a non-global entry from the final level of lookup.\n  - If EL2 is implemented, the entry would be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nARM deprecates the use of this instruction. It is only provided for backwards\ncompatibility with earlier versions of the ARM architecture.\n\nASID, bits [0:7] - ASID value to match. Any TLB entries for non-global pages\n                   that match the ASID values will be affected by this\n                   operation."
      },
      "ITLBIMVA": {
        "long_name": "Instruction TLB Invalidate by VA",
        "purpose": "Invalidate all cached copies of translation table entries from instruction TLBs\nthat meet the following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified address, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - If EL2 is implemented, the entry would be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nARM deprecates the use of this instruction. It is only provided for backwards\ncompatibility with earlier versions of the ARM architecture.\n\nVA, bits [12:31] - Virtual address to match.\nASID, bits [0:7] - ASID value to match."
      },
      "TLBIALL": {
        "long_name": "TLB Invalidate All",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that are\nfrom any level of the translation table walk. The entries that are invalidated\nare as follows:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, all entries that would\nbe required for the Secure EL1&0 translation regime.\n  - If executed in Secure state when EL3 is using AArch32, all entries that\nwould be required for the Secure PL1&0 translation regime.\n  - If executed at Non-secure EL1, all stage 1 translation table entries that\nwould be required for the Non-secure PL1&0 translation regime and, if EL2 is\nimplemented, they must match the current VMID.\n  - If executed at EL2, and if EL2 is enabled in the current Security state, the\nstage 1 or stage 2 translation table entries that would be required for the\nPL1&0 translation regime and matches the current VMID.\n\nThe invalidation only applies to the PE that executes this instruction."
      },
      "TLBIALLH": {
        "long_name": "TLB Invalidate All, Hyp mode",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from any level of the translation table walk that would be\nrequired for the Non-secure EL2 translation regime.\n\nThe invalidation only applies to the PE that executes this instruction."
      },
      "TLBIALLHIS": {
        "long_name": "TLB Invalidate All, Hyp mode, Inner Shareable",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from any level of the translation table walk that would be\nrequired for the Non-secure EL2 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this instructions."
      },
      "TLBIALLIS": {
        "long_name": "TLB Invalidate All, Inner Shareable",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that are\nfrom any level of the translation table walk. The entries that are invalidated\nare as follows:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, all entries that would\nbe required for the Secure EL1&0 translation regime.\n  - If executed in Secure state when EL3 is using AArch32, all entries that\nwould be required for the Secure PL1&0 translation regime.\n  - If executed at Non-secure EL1, all stage 1 translation table entries that\nwould be required for the Non-secure PL1&0 translation regime and, if EL2 is\nimplemented, they must match the current VMID.\n  - If executed at EL2 and if EL2 is enabled in the current Security state, the\nstage 1 or stage 2 translation table entries that would be required for the\nPL1&0 translation regime and matches the current VMID.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this instructions."
      },
      "TLBIALLNSNH": {
        "long_name": "TLB Invalidate All, Non-Secure Non-Hyp",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from any level of the translation table walk that would be\nrequired for stage 1 or stage 2 of the Non-secure PL1&0 translation regime,\nregardless of the associated VMID.\n\nThe invalidation only applies to the PE that executes this instruction."
      },
      "TLBIALLNSNHIS": {
        "long_name": "TLB Invalidate All, Non-Secure Non-Hyp, Inner Shareable",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from any level of the translation table walk that would be\nrequired for stage 1 or stage 2 of the Non-secure PL1&0 translation regime,\nregardless of the associated VMID.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this instructions."
      },
      "TLBIASID": {
        "long_name": "TLB Invalidate by ASID match",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used for the specified ASID, and either:\n    - Is from a level of lookup above the final level.\n    - Is a non-global entry from the final level of lookup.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nASID, bits [0:7] - ASID value to match. Any TLB entries for non-global pages\n                   that match the ASID values will be affected by this\n                   operation."
      },
      "TLBIASIDIS": {
        "long_name": "TLB Invalidate by ASID match, Inner Shareable",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used for the specified ASID, and either:\n    - Is from a level of lookup above the final level.\n    - Is a non-global entry from the final level of lookup.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this instructions.\n\nASID, bits [0:7] - ASID value to match. Any TLB entries for non-global pages\n                   that match the ASID values will be affected by this\n                   operation."
      },
      "TLBIIPAS2": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that meet the following requirements:\n\n  - The entry is a stage 2 only translation table entry, from any level of the\ntranslation table walk.\n  - SCR.NS is 1.\n  - The entry would be used for the specified IPA.\n  - The entry would be used with the current VMID.\n  - The entry would be required for the PL1&0 translation regime.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nIPA[39:12], bits [0:27] - Bits[39:12] of the intermediate physical address to\n                          match."
      },
      "TLBIIPAS2IS": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2, Inner Shareable",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that meet the following requirements:\n\n  - The entry is a stage 2 only translation table entry, from any level of the\ntranslation table walk.\n  - SCR.NS is 1.\n  - The entry would be used for the specified IPA.\n  - The entry would be used with the current VMID.\n  - The entry would be required for the PL1&0 translation regime.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this instructions.\n\nIPA[39:12], bits [0:27] - Bits[39:12] of the intermediate physical address to\n                          match."
      },
      "TLBIIPAS2L": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2, Last level",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that meet the following requirements:\n\n  - The entry is a stage 2 only translation table entry, from the final level of\nthe translation table walk.\n  - SCR.NS is 1.\n  - The entry would be used for the specified IPA.\n  - The entry would be used with the current VMID.\n  - The entry would be required for the PL1&0 translation regime.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nIPA[39:12], bits [0:27] - Bits[39:12] of the intermediate physical address to\n                          match."
      },
      "TLBIIPAS2LIS": {
        "long_name": "TLB Invalidate by Intermediate Physical Address, Stage 2, Last level, Inner Shareable",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that meet the following requirements:\n\n  - The entry is a stage 2 only translation table entry, from the final level of\nthe translation table walk.\n  - SCR.NS is 1.\n  - The entry would be used for the specified IPA.\n  - The entry would be used with the current VMID.\n  - The entry would be required for the PL1&0 translation regime.\n\nThe invalidation is not required to apply to caching structures that combine\nstage 1 and stage 2 translation table entries.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this instructions.\n\nIPA[39:12], bits [0:27] - Bits[39:12] of the intermediate physical address to\n                          match."
      },
      "TLBIMVA": {
        "long_name": "TLB Invalidate by VA",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified address, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nVA, bits [12:31] - Virtual address to match.\nASID, bits [0:7] - ASID value to match."
      },
      "TLBIMVAA": {
        "long_name": "TLB Invalidate by VA, All ASID",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified address.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nVA, bits [12:31] - Virtual address to match. Any unlocked TLB entries that match\n                   the VA will be affected by this operation, regardless of the\n                   ASID."
      },
      "TLBIMVAAIS": {
        "long_name": "TLB Invalidate by VA, All ASID, Inner Shareable",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from any level of the\ntranslation table walk.\n  - The entry would be used to translate the specified address.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this instructions.\n\nVA, bits [12:31] - Virtual address to match. Any unlocked TLB entries that match\n                   the VA will be affected by this operation, regardless of the\n                   ASID."
      },
      "TLBIMVAAL": {
        "long_name": "TLB Invalidate by VA, All ASID, Last level",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - The entry would be used to translate the specified address.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nVA, bits [12:31] - Virtual address to match. Any unlocked TLB entries that match\n                   the VA will be affected by this operation, regardless of the\n                   ASID."
      },
      "TLBIMVAALIS": {
        "long_name": "TLB Invalidate by VA, All ASID, Last level, Inner Shareable",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry, from the final level of the\ntranslation table walk.\n  - The entry would be used to translate the specified address.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this instructions.\n\nVA, bits [12:31] - Virtual address to match. Any unlocked TLB entries that match\n                   the VA will be affected by this operation, regardless of the\n                   ASID."
      },
      "TLBIMVAH": {
        "long_name": "TLB Invalidate by VA, Hyp mode",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from any level of the translation table walk that would be\nrequired for the Non-secure EL2 translation regime and used to translate the\nspecified address.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nVA, bits [12:31] - Virtual address to match. Any TLB entries that match the ASID\n                   value and VA value will be affected by this operation."
      },
      "TLBIMVAHIS": {
        "long_name": "TLB Invalidate by VA, Hyp mode, Inner Shareable",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from any level of the translation table walk that would be\nrequired for the Non-secure EL2 translation regime and used to translate the\nspecified address.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this instructions.\n\nVA, bits [12:31] - Virtual address to match. Any TLB entries that match the ASID\n                   value and VA value will be affected by this operation."
      },
      "TLBIMVAIS": {
        "long_name": "TLB Invalidate by VA, Inner Shareable",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified address, and one of the\nfollowing applies:\n    - The entry is from a level of lookup above the final level and matches the\nspecified ASID.\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this instructions.\n\nVA, bits [12:31] - Virtual address to match.\nASID, bits [0:7] - ASID value to match."
      },
      "TLBIMVAL": {
        "long_name": "TLB Invalidate by VA, Last level",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified address, and one of the\nfollowing applies:\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nVA, bits [12:31] - Virtual address to match. Any TLB entries that match the ASID\n                   value and VA value will be affected by this operation.\nASID, bits [0:7] - ASID value to match. Any TLB entries that match the ASID\n                   value and VA value will be affected by this operation. Global\n                   TLB entries that match the VA value will be affected by this\n                   operation, regardless of the value of the ASID field."
      },
      "TLBIMVALH": {
        "long_name": "TLB Invalidate by VA, Last level, Hyp mode",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from the final level of the translation table walk that would\nbe required for the Non-secure EL2 translation regime and used to translate the\nspecified address.\n\nThe invalidation only applies to the PE that executes this instruction.\n\nVA, bits [12:31] - Virtual address to match. Any TLB entries that match the ASID\n                   value and VA value will be affected by this operation."
      },
      "TLBIMVALHIS": {
        "long_name": "TLB Invalidate by VA, Last level, Hyp mode, Inner Shareable",
        "purpose": "If EL2 is implemented, invalidate all cached copies of translation table entries\nfrom TLBs that are from the final level of the translation table walk that would\nbe required for the Non-secure EL2 translation regime and used to translate the\nspecified address.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this instructions.\n\nVA, bits [12:31] - Virtual address to match. Any TLB entries that match the ASID\n                   value and VA value will be affected by this operation."
      },
      "TLBIMVALIS": {
        "long_name": "TLB Invalidate by VA, Last level, Inner Shareable",
        "purpose": "Invalidate all cached copies of translation table entries from TLBs that meet\nthe following requirements:\n\n  - The entry is a stage 1 translation table entry.\n  - The entry would be used to translate the specified address, and one of the\nfollowing applies:\n    - The entry is a global entry from the final level of lookup.\n    - The entry is a non-global entry from the final level of lookup that\nmatches the specified ASID.\n  - If EL2 is implemented and enabled in the current Security state, the entry\nwould be used with the current VMID.\n\nFrom the entries that match these requirement, the entries that are invalidated\nare required for the following translation regime:\n\n  - If executed at Secure EL1 when EL3 is using AArch64, the Secure EL1&0\ntranslation regime.\n  - If executed in Secure state when EL3 is using AArch32, the Secure PL1&0\ntranslation regime.\n  - If executed in Non-secure state, the Non-secure PL1&0 translation regime.\n\nThe invalidation applies to all PEs in the same Inner Shareable shareability\ndomain as the PE that executes this instructions.\n\nVA, bits [12:31] - Virtual address to match. Any TLB entries that match the ASID\n                   value and VA value will be affected by this operation.\nASID, bits [0:7] - ASID value to match. Any TLB entries that match the ASID\n                   value and VA value will be affected by this operation. Global\n                   TLB entries that match the VA value will be affected by this\n                   operation, regardless of the value of the ASID field."
      }
    },
    "registers": {
      "ACTLR": {
        "long_name": "Auxiliary Control Register",
        "purpose": "Provides implementation defined configuration and control options for execution\nat EL1 and EL0."
      },
      "ACTLR2": {
        "long_name": "Auxiliary Control Register 2",
        "purpose": "Provides additional space to the ACTLR register to hold implementation defined\ntrap functionality for execution at EL1 and EL0."
      },
      "ADFSR": {
        "long_name": "Auxiliary Data Fault Status Register",
        "purpose": "Provides additional implementation defined fault status information for Data\nAbort exceptions taken to EL1 modes, and EL3 modes when EL3 is implemented and\nis using AArch32."
      },
      "AIDR": {
        "long_name": "Auxiliary ID Register",
        "purpose": "Provides implementation defined identification information.\n\nThe value of this register must be used in conjunction with the value of MIDR."
      },
      "AIFSR": {
        "long_name": "Auxiliary Instruction Fault Status Register",
        "purpose": "Provides additional implementation defined fault status information for Prefetch\nAbort exceptions taken to EL1 modes, and EL3 modes when EL3 is implemented and\nis using AArch32."
      },
      "AMAIR0": {
        "long_name": "Auxiliary Memory Attribute Indirection Register 0",
        "purpose": "When using the Long-descriptor format translation tables for stage 1\ntranslations, provides implementation defined memory attributes for the memory\nregions specified by MAIR0."
      },
      "AMAIR1": {
        "long_name": "Auxiliary Memory Attribute Indirection Register 1",
        "purpose": "When using the Long-descriptor format translation tables for stage 1\ntranslations, provides implementation defined memory attributes for the memory\nregions specified by MAIR1."
      },
      "AMCFGR": {
        "long_name": "Activity Monitors Configuration Register",
        "purpose": "Global configuration register for the activity monitors.\n\nProvides information on supported features, the number of counter groups\nimplemented, the total number of activity monitor event counters implemented,\nand the size of the counters. AMCFGR is applicable to both the architected and\nthe auxiliary counter groups.\n\nNCG, bits [28:31] - Defines the number of counter groups. The number of\n                    implemented counter groups is defined as [AMCFGR.NCG + 1].\n                    If the number of implemented auxiliary activity monitor\n                    event counters is zero, this field has a value of 0b0000.\n                    Otherwise, this field has a value of 0b0001.\nHDBG, bit [24]    - Halt-on-debug supported. In ARMv8, this feature must be\n                    supported, and so this bit is 0b1.\n                        0b0 AMCR.HDBG is res0.\n                        0b1 AMCR.HDBG is read/write.\nSIZE, bits [8:13] - Defines the size of activity monitor event counters. The\n                    size of the activity monitor event counters implemented by\n                    the Activity Monitors Extension is defined as [AMCFGR.SIZE +\n                    1]. In ARMv8, the counters are 64-bit, and so this field is\n                    0b111111. Software also uses this field to determine the\n                    spacing of counters in the memory-map. In ARMv8, the\n                    counters are at doubleword-aligned addresses.\nN, bits [0:7]     - Defines the number of activity monitor event counters. The\n                    total number of counters implemented in all groups by the\n                    Activity Monitors Extension is defined as [AMCFGR.N + 1]."
      },
      "AMCGCR": {
        "long_name": "Activity Monitors Counter Group Configuration Register",
        "purpose": "Provides information on the number of activity monitor event counters\nimplemented within each counter group.\n\nCG1NC, bits [8:15] - Counter Group 1 Number of Counters. The number of counters\n                     in the auxiliary counter group. In AMUv1, the permitted\n                     range of values is 0 to 16.\nCG0NC, bits [0:7]  - Counter Group 0 Number of Counters. The number of counters\n                     in the architected counter group. In AMUv1, the value of\n                     this field is 4."
      },
      "AMCNTENCLR0": {
        "long_name": "Activity Monitors Count Enable Clear Register 0",
        "purpose": "Disable control bits for the architected activity monitors event counters,\nAMEVCNTR0<n>.\n\nP<n>, bits [0:31] - Activity monitor event counter disable bit for AMEVCNTR0<n>.\n                    Bits [31:N] are RAZ/WI. N is the value in AMCGCR.CG0NC.\n                    Possible values of each bit are:\n                        0b0 When read, means that AMEVCNTR0<n> is disabled. When\n                    written, has no effect.\n                        0b1 When read, means that AMEVCNTR0<n> is enabled. When\n                    written, disables AMEVCNTR0<n>."
      },
      "AMCNTENCLR1": {
        "long_name": "Activity Monitors Count Enable Clear Register 1",
        "purpose": "Disable control bits for the auxiliary activity monitors event counters,\nAMEVCNTR1<n>.\n\nP<n>, bits [0:31] - Activity monitor event counter disable bit for AMEVCNTR1<n>.\n                    Bits [31:N] are RAZ/WI. N is the value in AMCGCR_EL1.CG1NC.\n                    Possible values of each bit are:\n                        0b0 When read, means that AMEVCNTR1<n> is disabled. When\n                    written, has no effect.\n                        0b1 When read, means that AMEVCNTR1<n> is enabled. When\n                    written, disables AMEVCNTR1<n>."
      },
      "AMCNTENSET0": {
        "long_name": "Activity Monitors Count Enable Set Register 0",
        "purpose": "Enable control bits for the architected activity monitors event counters,\nAMEVCNTR0<n>.\n\nP<n>, bits [0:31] - Activity monitor event counter enable bit for AMEVCNTR0<n>.\n                    Bits [31:N] are RAZ/WI. N is the value in AMCGCR.CG0NC.\n                    Possible values of each bit are:\n                        0b0 When read, means that AMEVCNTR0<n> is disabled. When\n                    written, has no effect.\n                        0b1 When read, means that AMEVCNTR0<n> is enabled. When\n                    written, enables AMEVCNTR0<n>."
      },
      "AMCNTENSET1": {
        "long_name": "Activity Monitors Count Enable Set Register 1",
        "purpose": "Enable control bits for the auxiliary activity monitors event counters,\nAMEVCNTR1<n>.\n\nP<n>, bits [0:31] - Activity monitor event counter enable bit for AMEVCNTR1<n>.\n                    Bits [31:N] are RAZ/WI. N is the value in AMCGCR.CG1NC.\n                    Possible values of each bit are:\n                        0b0 When read, means that AMEVCNTR1<n> is disabled. When\n                    written, has no effect.\n                        0b1 When read, means that AMEVCNTR1<n> is enabled. When\n                    written, enables AMEVCNTR1<n>."
      },
      "AMCR": {
        "long_name": "Activity Monitors Control Register",
        "purpose": "Global control register for the activity monitors implementation. AMCR is\napplicable to both the architected and the auxiliary counter groups.\n\nHDBG, bit [10] - This bit controls whether activity monitor counting is halted\n                 when the PE is halted in Debug state.\n                     0b0 Activity monitors do not halt counting when the PE is\n                 halted in Debug state.\n                     0b1 Activity monitors halt counting when the PE is halted\n                 in Debug state."
      },
      "AMEVCNTR0<n>": {
        "long_name": "Activity Monitors Event Counter Registers 0",
        "purpose": "Provides access to the architected activity monitor event counters.\n\nACNT, bits [0:63] - Architected activity monitor event counter n. Value of\n                    architected activity monitor event counter n, where n is the\n                    number of this register and is a number from 0 to 15.\n                    If the counter is enabled, writes to this register have\n                    unpredictable results."
      },
      "AMEVCNTR1<n>": {
        "long_name": "Activity Monitors Event Counter Registers 1",
        "purpose": "Provides access to the auxiliary activity monitor event counters.\n\nACNT, bits [0:63] - Auxiliary activity monitor event counter n. Value of\n                    auxiliary activity monitor event counter n, where n is the\n                    number of this register and is a number from 0 to 15.\n                    If the counter is enabled, writes to this register have\n                    unpredictable results."
      },
      "AMEVTYPER0<n>": {
        "long_name": "Activity Monitors Event Type Registers 0",
        "purpose": "Provides information on the events that an architected activity monitor event\ncounter AMEVCNTR0<n> counts.\n\nevtCount, bits [0:15] - Event to count. The event number of the event that is\n                        counted by the architected activity monitor event\n                        counter AMEVCNTR0<n>. The value of this field is\n                        architecturally mandated for each architected counter.\n                        The following table shows the mapping between required\n                        event numbers and the corresponding counters:\n                            0x0011 Processor frequency cycles\n                            0x4004 Constant frequency cycles\n                            0x0008 Instructions retired\n                            0x4005 Memory stall cycles"
      },
      "AMEVTYPER1<n>": {
        "long_name": "Activity Monitors Event Type Registers 1",
        "purpose": "Provides information on the events that an auxiliary activity monitor event\ncounter AMEVCNTR1<n> counts.\n\nevtCount, bits [0:15] - Event to count. The event number of the event that is\n                        counted by the auxiliary activity monitor event counter\n                        AMEVCNTR1<n>. It is implementation defined what values\n                        are supported by each counter. If software writes a\n                        value to this field which is not supported by the\n                        corresponding counter AMEVCNTR1<n>, then:\n                          - It is unpredictable which event will be counted.\n                          - The value read back is unknown. The event counted by\n                        AMEVCNTR1<n> might be fixed at implementation. In this\n                        case, the field is read-only and writes are undefined.\n                        If the corresponding counter AMEVCNTR1<n> is enabled,\n                        writes to this register have unpredictable results."
      },
      "AMUSERENR": {
        "long_name": "Activity Monitors User Enable Register",
        "purpose": "Global user enable register for the activity monitors. Enables or disables EL0\naccess to the activity monitors. AMUSERENR is applicable to both the architected\nand the auxiliary counter groups.\n\nEN, bit [0] - Traps EL0 accesses to the activity monitors registers to EL1.\n                  0b0 EL0 accesses to the activity monitors registers are\n              trapped to EL1.\n                  0b1 This control does not cause any instructions to be\n              trapped. Software can access all activity monitor registers at\n              EL0.\n              \n                - AMUSERENR can always be read at EL0 and is not governed by\n              this bit."
      },
      "APSR": {
        "long_name": "Application Program Status Register",
        "purpose": "Hold program status and control information.\n\nN, bit [31]      - Negative condition flag. Set to bit[31] of the result of the\n                   last flag-setting instruction. If the result is regarded as a\n                   two's complement signed integer, then N is set to 1 if the\n                   result was negative, and N is set to 0 if the result was\n                   positive or zero.\nZ, bit [30]      - Zero condition flag. Set to 1 if the result of the last flag-\n                   setting instruction was zero, and to 0 otherwise. A result of\n                   zero often indicates an equal result from a comparison.\nC, bit [29]      - Carry condition flag. Set to 1 if the last flag-setting\n                   instruction resulted in a carry condition, for example an\n                   unsigned overflow on an addition.\nV, bit [28]      - Overflow condition flag. Set to 1 if the last flag-setting\n                   instruction resulted in an overflow condition, for example a\n                   signed overflow on an addition.\nQ, bit [27]      - Cumulative saturation bit. Set to 1 to indicate that overflow\n                   or saturation occurred in some instructions.\nGE, bits [16:19] - Greater than or Equal flags, for parallel addition and\n                   subtraction."
      },
      "CCSIDR": {
        "long_name": "Current Cache Size ID Register",
        "purpose": "Provides information about the architecture of the currently selected cache.\n\nWhen ARMv8.3-CCIDX is implemented, this register is used in conjunction with\nCCSIDR2.\n\nAssociativity, bits [3:23] - (Associativity of cache) - 1, therefore a value of\n                             0 indicates an associativity of 1. The\n                             associativity does not have to be a power of 2.\nLineSize, bits [0:2]       - (Log_2(Number of bytes in cache line)) - 4. For\n                             example: For a line length of 16 bytes: Log_2(16) =\n                             4, LineSize entry = 0. This is the minimum line\n                             length. For a line length of 32 bytes: Log_2(32) =\n                             5, LineSize entry = 1."
      },
      "CCSIDR2": {
        "long_name": "Current Cache Size ID Register 2",
        "purpose": "When ARMv8.3-CCIDX is implemented, in conjunction with CCSIDR, provides\ninformation about the architecture of the currently selected cache.\n\nWhen ARMv8.3-CCIDX is not implemented, this register is not implemented.\n\nNumSets, bits [0:23] - (Number of sets in cache) - 1, therefore a value of 0\n                       indicates 1 set in the cache. The number of sets does not\n                       have to be a power of 2."
      },
      "CLIDR": {
        "long_name": "Cache Level ID Register",
        "purpose": "Identifies the type of cache, or caches, that are implemented at each level and\ncan be managed using the architected cache maintenance instructions that operate\nby set/way, up to a maximum of seven levels. Also identifies the Level of\nCoherence (LoC) and Level of Unification (LoU) for the cache hierarchy.\n\nICB, bits [30:31]     - Inner cache boundary. This field indicates the boundary\n                        for caching Inner Cacheable memory regions. The possible\n                        values are:\n                            0b00 Not disclosed by this mechanism.\n                            0b01 L1 cache is the highest Inner Cacheable level.\n                            0b10 L2 cache is the highest Inner Cacheable level.\n                            0b11 L3 cache is the highest Inner Cacheable level.\nLoUU, bits [27:29]    - Level of Unification Uniprocessor for the cache\n                        hierarchy.\nLoC, bits [24:26]     - Level of Coherence for the cache hierarchy.\nLoUIS, bits [21:23]   - Level of Unification Inner Shareable for the cache\n                        hierarchy.\nCtype<n>, bits [0:20] - Cache Type fields. Indicate the type of cache that is\n                        implemented and can be managed using the architected\n                        cache maintenance instructions that operate by set/way\n                        at each level, from Level 1 up to a maximum of seven\n                        levels of cache hierarchy. Possible values of each field\n                        are:\n                            0b000 No cache.\n                            0b001 Instruction cache only.\n                            0b010 Data cache only.\n                            0b011 Separate instruction and data caches.\n                            0b100 Unified cache."
      },
      "CNTFRQ": {
        "long_name": "Counter-timer Frequency register",
        "purpose": "This register is provided so that software can discover the frequency of the\nsystem counter. It must be programmed with this value as part of system\ninitialization. The value of the register is not interpreted by hardware.\n\nbits [0:31] - Clock frequency. Indicates the system counter clock frequency, in\n              Hz."
      },
      "CNTHCTL": {
        "long_name": "Counter-timer Hyp Control register",
        "purpose": "Controls the generation of an event stream from the physical counter, and access\nfrom Non-secure EL1 modes to the physical counter and the Non-secure EL1\nphysical timer.\n\nEVNTI, bits [4:7] - Selects which bit (0 to 15) of the counter register CNTPCT\n                    is the trigger for the event stream generated from that\n                    counter, when that stream is enabled.\nEVNTDIR, bit [3]  - Controls which transition of the counter register CNTPCT\n                    trigger bit, defined by EVNTI, generates an event when the\n                    event stream is enabled:\nEVNTEN, bit [2]   - Enables the generation of an event stream from the counter\n                    register CNTPCT:\nPL1PCEN, bit [1]  - Traps Non-secure EL0 and EL1 accesses to the physical timer\n                    registers to Hyp mode.\nPL1PCTEN, bit [0] - Traps Non-secure EL0 and EL1 accesses to the physical\n                    counter register to Hyp mode."
      },
      "CNTHPS_CTL": {
        "long_name": "Counter-timer Secure Physical Timer Control Register (EL2)",
        "purpose": "Provides AArch32 access to the Secure EL2 physical timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the CNTHPS_CTL.ENABLE bit is 1, ISTATUS\n                   indicates whether the timer condition is met. ISTATUS takes\n                   no account of the value of the IMASK bit. If the value of\n                   ISTATUS is 1 and the value of IMASK is 0 then the timer\n                   interrupt is asserted. When the value of the\n                   CNTHPS_CTL.ENABLE bit is 0, the ISTATUS field is unknown. For\n                   more information see 'Operation of the CompareValue views of\n                   the timers' and 'Operation of the TimerValue views of the\n                   timers' in the ARM ARM, chapter D6. This bit is read-only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTHPS_TVAL_EL2 continues to\n                   count down. Disabling the output signal might be a power-\n                   saving option."
      },
      "CNTHPS_CVAL": {
        "long_name": "Counter-timer Secure Physical Timer CompareValue Register (EL2)",
        "purpose": "Provides AArch32 access to the compare value for the Secure EL2 physical timer.\n\nCompareValue, bits [0:63] - Holds the EL2 physical timer CompareValue. When\n                            CNTHPS_CTL_EL2.ENABLE is 1, the timer condition is\n                            met when (CNTPCT_EL0 - CompareValue) is greater than\n                            or equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTHPS_CTL_EL2.ISTATUS is set to 1.\n                              - If CNTHPS_CTL_EL2.IMASK is 0, an interrupt is\n                            generated. When CNTHPS_CTL_EL2.ENABLE is 0, the\n                            timer condition is not met, but CNTPCT_EL0 continues\n                            to count."
      },
      "CNTHPS_TVAL": {
        "long_name": "Counter-timer Secure Physical Timer TimerValue Register (EL2)",
        "purpose": "Provides AArch32 access to the timer value for the Secure EL2 physical timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL2 physical timer. On a\n                          read of this register:\n                            - If CNTHPS_CTL_EL2.ENABLE is 0, the value returned\n                          is unknown.\n                            - If CNTHPS_CTL_EL2.ENABLE is 1, the value returned\n                          is (CNTHPS_CVAL_EL2 - CNTPCT_EL0). On a write of this\n                          register, CNTHPS_CVAL_EL2 is set to (CNTPCT_EL0 +\n                          TimerValue), where TimerValue is treated as a signed\n                          32-bit integer. When CNTHPS_CTL_EL2.ENABLE is 1, the\n                          timer condition is met when (CNTPCT_EL0 -\n                          CNTHPS_CVAL_EL2) is greater than or equal to zero.\n                          This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTHPS_CTL_EL2.ISTATUS is set to 1.\n                            - If CNTHPS_CTL_EL2.IMASK is 0, an interrupt is\n                          generated. When CNTHPS_CTL_EL2.ENABLE is 0, the timer\n                          condition is not met, but CNTPCT_EL0 continues to\n                          count, so the TimerValue view appears to continue to\n                          count down."
      },
      "CNTHP_CTL": {
        "long_name": "Counter-timer Hyp Physical Timer Control register",
        "purpose": "Control register for the Hyp mode physical timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown. For more information see 'Operation of the\n                   CompareValue views of the timers' and 'Operation of the\n                   TimerValue views of the timers' in the ARM ARM, chapter D6.\n                   This bit is read-only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTHP_TVAL continues to count\n                   down. Disabling the output signal might be a power-saving\n                   option."
      },
      "CNTHP_CVAL": {
        "long_name": "Counter-timer Hyp Physical CompareValue register",
        "purpose": "Holds the compare value for the Hyp mode physical timer.\n\nCompareValue, bits [0:63] - Holds the EL2 physical timer CompareValue. When\n                            CNTHP_CTL.ENABLE is 1, the timer condition is met\n                            when (CNTPCT - CompareValue) is greater than or\n                            equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTHP_CTL.ISTATUS is set to 1.\n                              - If CNTHP_CTL.IMASK is 0, an interrupt is\n                            generated. When CNTHP_CTL.ENABLE is 0, the timer\n                            condition is not met, but CNTPCT continues to count."
      },
      "CNTHP_TVAL": {
        "long_name": "Counter-timer Hyp Physical Timer TimerValue register",
        "purpose": "Holds the timer value for the Hyp mode physical timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL2 physical timer. On a\n                          read of this register:\n                            - If CNTHP_CTL.ENABLE is 0, the value returned is\n                          unknown.\n                            - If CNTHP_CTL.ENABLE is 1, the value returned is\n                          (CNTHP_CVAL - CNTPCT). On a write of this register,\n                          CNTHP_CVAL is set to (CNTPCT + TimerValue), where\n                          TimerValue is treated as a signed 32-bit integer. When\n                          CNTHP_CTL.ENABLE is 1, the timer condition is met when\n                          (CNTPCT - CNTHP_CVAL) is greater than or equal to\n                          zero. This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTHP_CTL.ISTATUS is set to 1.\n                            - If CNTHP_CTL.IMASK is 0, an interrupt is\n                          generated. When CNTHP_CTL.ENABLE is 0, the timer\n                          condition is not met, but CNTPCT continues to count,\n                          so the TimerValue view appears to continue to count\n                          down."
      },
      "CNTHVS_CTL": {
        "long_name": "Counter-timer Secure Virtual Timer Control Register (EL2)",
        "purpose": "Provides AArch32 access to the Secure EL2 virtual timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown. For more information see 'Operation of the\n                   CompareValue views of the timers' and 'Operation of the\n                   TimerValue views of the timers' in the ARM ARM, chapter D8.\n                   This bit is read-only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTHVS_TVAL continues to\n                   count down. Disabling the output signal might be a power-\n                   saving option."
      },
      "CNTHVS_CVAL": {
        "long_name": "Counter-timer Secure Virtual Timer CompareValue Register (EL2)",
        "purpose": "Provides AArch32 access to the compare value for the Secure EL2 virtual timer.\n\nCompareValue, bits [0:63] - Holds the EL2 virtual timer CompareValue. When\n                            CNTHVS_CTL.ENABLE is 1, the timer condition is met\n                            when (CNTVCT - CompareValue) is greater than or\n                            equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTHVS_CTL.ISTATUS is set to 1.\n                              - If CNTHVS_CTL.IMASK is 0, an interrupt is\n                            generated. When CNTHVS_CTL.ENABLE is 0, the timer\n                            condition is not met, but CNTVCT continues to count."
      },
      "CNTHVS_TVAL": {
        "long_name": "Counter-timer Secure Virtual Timer TimerValue Register (EL2)",
        "purpose": "Provides AArch32 access to the timer value for the Secure EL2 virtual timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL2 virtual timer. On a\n                          read of this register:\n                            - If CNTHVS_CTL.ENABLE is 0, the value returned is\n                          unknown.\n                            - If CNTHVS_CTL.ENABLE is 1, the value returned is\n                          (CNTHVS_CVAL - CNTVCT). On a write of this register,\n                          CNTHVS_CVAL is set to (CNTVCT + TimerValue), where\n                          TimerValue is treated as a signed 32-bit integer. When\n                          CNTHVS_CTL.ENABLE is 1, the timer condition is met\n                          when (CNTVCT - CNTHVS_CVAL) is greater than or equal\n                          to zero. This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTHVS_CTL.ISTATUS is set to 1.\n                            - If CNTHVS_CTL.IMASK is 0, an interrupt is\n                          generated. When CNTHVS_CTL.ENABLE is 0, the timer\n                          condition is not met, but CNTVCT continues to count,\n                          so the TimerValue view appears to continue to count\n                          down."
      },
      "CNTHV_CTL": {
        "long_name": "Counter-timer Virtual Timer Control register (EL2)",
        "purpose": "Provides AArch32 access to the control register for the EL2 virtual timer.\n\nThe EL2 virtual timer is implemented by ARMv8.1-VHE. It is only accessible from\nAArch32 state when EL0 is using AArch32, EL2 is using AArch64, and the value of\nHCR_EL2.{E2H, TGE} is {1, 1}.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown. For more information see 'Operation of the\n                   CompareValue views of the timers' and 'Operation of the\n                   TimerValue views of the timers' in the ARM ARM, chapter D6.\n                   This bit is read-only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTHV_TVAL continues to count\n                   down. Disabling the output signal might be a power-saving\n                   option."
      },
      "CNTHV_CVAL": {
        "long_name": "Counter-timer Virtual Timer CompareValue register (EL2)",
        "purpose": "Provides AArch32 access to the compare value for the EL2 virtual timer.\n\nThe EL2 virtual timer is implemented by ARMv8.1-VHE. It is only accessible from\nAArch32 state when EL0 is using AArch32, EL2 is using AArch64, and the value of\nHCR_EL2.{E2H, TGE} is {1, 1}.\n\nCompareValue, bits [0:63] - Holds the EL2 virtual timer CompareValue. When\n                            CNTHV_CTL.ENABLE is 1, the timer condition is met\n                            when (CNTVCT - CompareValue) is greater than or\n                            equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTHV_CTL.ISTATUS is set to 1.\n                              - If CNTHV_CTL.IMASK is 0, an interrupt is\n                            generated. When CNTHV_CTL.ENABLE is 0, the timer\n                            condition is not met, but CNTVCT continues to count."
      },
      "CNTHV_TVAL": {
        "long_name": "Counter-timer Virtual Timer TimerValue register (EL2)",
        "purpose": "Provides AArch32 access to the timer value for the EL2 virtual timer.\n\nThe EL2 virtual timer is implemented by  ARMv8.1-VHE. It is only accessible from\nAArch32 state when EL0 is using AArch32, EL2 is using AArch64, and the value of\nHCR_EL2.{E2H, TGE} is {1, 1}.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL2 virtual timer. On a\n                          read of this register:\n                            - If CNTHV_CTL.ENABLE is 0, the value returned is\n                          unknown.\n                            - If CNTHV_CTL.ENABLE is 1, the value returned is\n                          (CNTHV_CVAL - CNTVCT). On a write of this register,\n                          CNTHV_CVAL is set to (CNTVCT + TimerValue), where\n                          TimerValue is treated as a signed 32-bit integer. When\n                          CNTHV_CTL.ENABLE is 1, the timer condition is met when\n                          (CNTVCT - CNTHV_CVAL) is greater than or equal to\n                          zero. This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTHV_CTL.ISTATUS is set to 1.\n                            - If CNTHV_CTL.IMASK is 0, an interrupt is\n                          generated. When CNTHV_CTL.ENABLE is 0, the timer\n                          condition is not met, but CNTVCT continues to count,\n                          so the TimerValue view appears to continue to count\n                          down."
      },
      "CNTKCTL": {
        "long_name": "Counter-timer Kernel Control register",
        "purpose": "Controls the generation of an event stream from the virtual counter, and access\nfrom EL0 modes to the physical counter, virtual counter, EL1 physical timers,\nand the virtual timer.\n\nPL0PTEN, bit [9]  - Traps PL0 accesses to the physical timer registers to\n                    Undefined mode.\nPL0VTEN, bit [8]  - Traps PL0 accesses to the virtual timer registers to\n                    Undefined mode.\nEVNTI, bits [4:7] - Selects which bit (0 to 15) of the counter register CNTVCT\n                    is the trigger for the event stream generated from that\n                    counter, when that stream is enabled.\nEVNTDIR, bit [3]  - Controls which transition of the counter register CNTVCT\n                    trigger bit, defined by EVNTI, generates an event when the\n                    event stream is enabled:\nEVNTEN, bit [2]   - Enables the generation of an event stream from the counter\n                    register CNTVCT:\nPL0VCTEN, bit [1] - Traps PL0 accesses to the frequency register and virtual\n                    counter register to Undefined mode.\nPL0PCTEN, bit [0] - Traps PL0 accesses to the frequency register and physical\n                    counter register to Undefined mode."
      },
      "CNTPCT": {
        "long_name": "Counter-timer Physical Count register",
        "purpose": "Holds the 64-bit physical count value.\n\nbits [0:63] - Physical count value."
      },
      "CNTP_CTL": {
        "long_name": "Counter-timer Physical Timer Control register",
        "purpose": "Control register for the EL1 physical timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown. For more information see 'Operation of the\n                   CompareValue views of the timers' and 'Operation of the\n                   TimerValue views of the timers' in the ARM ARM, chapter D6.\n                   This bit is read-only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTP_TVAL continues to count\n                   down. Disabling the output signal might be a power-saving\n                   option."
      },
      "CNTP_CVAL": {
        "long_name": "Counter-timer Physical Timer CompareValue register",
        "purpose": "Holds the compare value for the EL1 physical timer.\n\nCompareValue, bits [0:63] - Holds the EL1 physical timer CompareValue. When\n                            CNTP_CTL.ENABLE is 1, the timer condition is met\n                            when (CNTPCT - CompareValue) is greater than or\n                            equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTP_CTL.ISTATUS is set to 1.\n                              - If CNTP_CTL.IMASK is 0, an interrupt is\n                            generated. When CNTP_CTL.ENABLE is 0, the timer\n                            condition is not met, but CNTPCT continues to count."
      },
      "CNTP_TVAL": {
        "long_name": "Counter-timer Physical Timer TimerValue register",
        "purpose": "Holds the timer value for the EL1 physical timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the EL1 physical timer. On a\n                          read of this register:\n                            - If CNTP_CTL.ENABLE is 0, the value returned is\n                          unknown.\n                            - If CNTP_CTL.ENABLE is 1, the value returned is\n                          (CNTP_CVAL - CNTPCT). On a write of this register,\n                          CNTP_CVAL is set to (CNTPCT + TimerValue), where\n                          TimerValue is treated as a signed 32-bit integer. When\n                          CNTP_CTL.ENABLE is 1, the timer condition is met when\n                          (CNTPCT - CNTP_CVAL) is greater than or equal to zero.\n                          This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTP_CTL.ISTATUS is set to 1.\n                            - If CNTP_CTL.IMASK is 0, an interrupt is generated.\n                          When CNTP_CTL.ENABLE is 0, the timer condition is not\n                          met, but CNTPCT continues to count, so the TimerValue\n                          view appears to continue to count down."
      },
      "CNTVCT": {
        "long_name": "Counter-timer Virtual Count register",
        "purpose": "Holds the 64-bit virtual count value. The virtual count value is equal to the\nphysical count value visible in CNTPCT minus the virtual offset visible in\nCNTVOFF.\n\nbits [0:63] - Virtual count value."
      },
      "CNTVOFF": {
        "long_name": "Counter-timer Virtual Offset register",
        "purpose": "Holds the 64-bit virtual offset. This is the offset between the physical count\nvalue visible in CNTPCT and the virtual count value visible in CNTVCT.\n\nbits [0:63] - Virtual offset."
      },
      "CNTV_CTL": {
        "long_name": "Counter-timer Virtual Timer Control register",
        "purpose": "Control register for the virtual timer.\n\nISTATUS, bit [2] - The status of the timer. This bit indicates whether the timer\n                   condition is met:\n                       0b0 Timer condition is not met.\n                       0b1 Timer condition is met.\n                   When the value of the ENABLE bit is 1, ISTATUS indicates\n                   whether the timer condition is met. ISTATUS takes no account\n                   of the value of the IMASK bit. If the value of ISTATUS is 1\n                   and the value of IMASK is 0 then the timer interrupt is\n                   asserted. When the value of the ENABLE bit is 0, the ISTATUS\n                   field is unknown. For more information see 'Operation of the\n                   CompareValue views of the timers' and 'Operation of the\n                   TimerValue views of the timers' in the ARM ARM, chapter D6.\n                   This bit is read-only.\nIMASK, bit [1]   - Timer interrupt mask bit. Permitted values are:\n                       0b0 Timer interrupt is not masked by the IMASK bit.\n                       0b1 Timer interrupt is masked by the IMASK bit.\n                   For more information, see the description of the ISTATUS bit.\nENABLE, bit [0]  - Enables the timer. Permitted values are:\n                       0b0 Timer disabled.\n                       0b1 Timer enabled.\n                   Setting this bit to 0 disables the timer output signal, but\n                   the timer value accessible from CNTV_TVAL continues to count\n                   down. Disabling the output signal might be a power-saving\n                   option."
      },
      "CNTV_CVAL": {
        "long_name": "Counter-timer Virtual Timer CompareValue register",
        "purpose": "Holds the compare value for the virtual timer.\n\nCompareValue, bits [0:63] - Holds the EL1 virtual timer CompareValue. When\n                            CNTV_CTL.ENABLE is 1, the timer condition is met\n                            when (CNTVCT - CompareValue) is greater than or\n                            equal to zero. This means that CompareValue acts\n                            like a 64-bit upcounter timer. When the timer\n                            condition is met:\n                              - CNTV_CTL.ISTATUS is set to 1.\n                              - If CNTV_CTL.IMASK is 0, an interrupt is\n                            generated. When CNTV_CTL.ENABLE is 0, the timer\n                            condition is not met, but CNTVCT continues to count."
      },
      "CNTV_TVAL": {
        "long_name": "Counter-timer Virtual Timer TimerValue register",
        "purpose": "Holds the timer value for the virtual timer.\n\nTimerValue, bits [0:31] - The TimerValue view of the virtual timer. On a read of\n                          this register:\n                            - If CNTV_CTL.ENABLE is 0, the value returned is\n                          unknown.\n                            - If CNTV_CTL.ENABLE is 1, the value returned is\n                          (CNTV_CVAL - CNTVCT). On a write of this register,\n                          CNTV_CVAL is set to (CNTVCT + TimerValue), where\n                          TimerValue is treated as a signed 32-bit integer. When\n                          CNTP_CTL.ENABLE is 1, the timer condition is met when\n                          (CNTVCT - CNTP_CVAL) is greater than or equal to zero.\n                          This means that TimerValue acts like a 32-bit\n                          downcounter timer. When the timer condition is met:\n                            - CNTV_CTL.ISTATUS is set to 1.\n                            - If CNTV_CTL.IMASK is 0, an interrupt is generated.\n                          When CNTV_CTL.ENABLE is 0, the timer condition is not\n                          met, but CNTVCT continues to count, so the TimerValue\n                          view appears to continue to count down."
      },
      "CONTEXTIDR": {
        "long_name": "Context ID Register",
        "purpose": "Identifies the current Process Identifier and, when using the Short-descriptor\ntranslation table format, the Address Space Identifier.\n\nThe value of the whole of this register is called the Context ID and is used by:\n\n  - The debug logic, for Linked and Unlinked Context ID matching.\n  - The trace logic, to identify the current process.\n\nThe significance of this register is for debug and trace use only.\n\nPROCID, bits [8:31] - Process Identifier. This field must be programmed with a\n                      unique value that identifies the current process.\nASID, bits [0:7]    - Address Space Identifier. This field is programmed with\n                      the value of the current ASID."
      },
      "CPACR": {
        "long_name": "Architectural Feature Access Control Register",
        "purpose": "Controls access to trace, and to Advanced SIMD and floating-point functionality\nfrom EL0, EL1, and EL3.\n\nIn an implementation that includes EL2, the CPACR has no effect on instructions\nexecuted at EL2.\n\nASEDIS, bit [31]   - Disables PL0 and PL1 execution of Advanced SIMD\n                     instructions.\nTRCDIS, bit [28]   - Traps PL0 and PL1 System register accesses to all\n                     implemented trace registers to Undefined mode.\ncp11, bits [22:23] - The value of this field is ignored. If this field is\n                     programmed with a different value to the cp10 field then\n                     this field is unknown on a direct read of the CPACR. If the\n                     implementation does not include Advanced SIMD and floating-\n                     point functionality, this field is res0. In Non-secure\n                     state, if EL3 is implemented and is using AArch32, when the\n                     value of NSACR.cp10 is 0, this field behaves as RAZ/WI,\n                     regardless of its actual value.\ncp10, bits [20:21] - Defines the access rights for the floating-point and\n                     Advanced SIMD functionality."
      },
      "CPSR": {
        "long_name": "Current Program Status Register",
        "purpose": "Holds PE status and control information.\n\nN, bit [31]      - Negative condition flag. Set to bit[31] of the result of the\n                   last flag-setting instruction. If the result is regarded as a\n                   two's complement signed integer, then N is set to 1 if the\n                   result was negative, and N is set to 0 if the result was\n                   positive or zero.\nZ, bit [30]      - Zero condition flag. Set to 1 if the result of the last flag-\n                   setting instruction was zero, and to 0 otherwise. A result of\n                   zero often indicates an equal result from a comparison.\nC, bit [29]      - Carry condition flag. Set to 1 if the last flag-setting\n                   instruction resulted in a carry condition, for example an\n                   unsigned overflow on an addition.\nV, bit [28]      - Overflow condition flag. Set to 1 if the last flag-setting\n                   instruction resulted in an overflow condition, for example a\n                   signed overflow on an addition.\nQ, bit [27]      - Cumulative saturation bit. Set to 1 to indicate that overflow\n                   or saturation occurred in some instructions.\nPAN, bit [22]    - Privileged Access Never.\nDIT, bit [21]    - Data Independent Timing.\nGE, bits [16:19] - Greater than or Equal flags, for parallel addition and\n                   subtraction.\nE, bit [9]       - Endianness state bit.\nA, bit [8]       - SError interrupt mask bit.\nI, bit [7]       - IRQ mask bit.\nF, bit [6]       - FIQ mask bit.\nM, bits [0:3]    - Current PE mode."
      },
      "CSSELR": {
        "long_name": "Cache Size Selection Register",
        "purpose": "Selects the current Cache Size ID Register, CCSIDR, by specifying the required\ncache level and the cache type, which is either instruction cache or data cache.\n\nIf ARMv8.3-CCIDX is implemented, CSSELR also selects the current CCSIDR2.\n\nLevel, bits [1:3] - Cache level of required cache. Permitted values are:\n                        0b000 Level 1 cache.\n                        0b001 Level 2 cache.\n                        0b010 Level 3 cache.\n                        0b011 Level 4 cache.\n                        0b100 Level 5 cache.\n                        0b101 Level 6 cache.\n                        0b110 Level 7 cache.\n                    All other values are reserved. If CSSELR.Level is programmed\n                    to a cache level that is not implemented, then the value for\n                    this field on a read of CSSELR is unknown.\nInD, bit [0]      - Instruction not Data bit. Permitted values are:\n                        0b0 Data or unified cache.\n                        0b1 Instruction cache.\n                    If CSSELR.Level is programmed to a cache level that is not\n                    implemented, then the value for this field on a read of\n                    CSSELR is unknown."
      },
      "CTR": {
        "long_name": "Cache Type Register",
        "purpose": "Provides information about the architecture of the caches.\n\nDIC, bit [29]          - Instruction cache invalidation requirements for\n                         instruction to data coherence.\nIDC, bit [28]          - Data cache clean requirements for instruction to data\n                         coherence.\nCWG, bits [24:27]      - Cache writeback granule.\nERG, bits [20:23]      - Exclusives reservation granule.\nDminLine, bits [16:19] - Log_2 of the number of words in the smallest cache line\n                         of all the data caches and unified caches that are\n                         controlled by the PE.\nL1Ip, bits [14:15]     - Level 1 instruction cache policy.\nIminLine, bits [0:3]   - Log_2 of the number of words in the smallest cache line\n                         of all the instruction caches that are controlled by\n                         the PE."
      },
      "DACR": {
        "long_name": "Domain Access Control Register",
        "purpose": "Defines the access permission for each of the sixteen memory domains.\n\nD<n>, bits [0:31] - Domain n access permission, where n = 0 to 15. Permitted\n                    values are:\n                        0b00 No access. Any access to the domain generates a\n                    Domain fault.\n                        0b01 Client. Accesses are checked against the permission\n                    bits in the translation tables.\n                        0b11 Manager. Accesses are not checked against the\n                    permission bits in the translation tables.\n                    The value 0b10 is reserved."
      },
      "DBGAUTHSTATUS": {
        "long_name": "Debug Authentication Status register",
        "purpose": "Provides information about the state of the implementation defined\nauthentication interface for debug.\n\nSNID, bits [6:7]  - Secure Non-Invasive Debug.\nSNID, bits [6:7]  - Secure Non-Invasive Debug.\nSID, bits [4:5]   - Secure Invasive Debug.\nNSNID, bits [2:3] - Non-secure Non-invasive debug.\nNSNID, bits [2:3] - Non-secure Non-Invasive Debug.\nNSID, bits [0:1]  - Non-secure Invasive Debug."
      },
      "DBGBCR<n>": {
        "long_name": "Debug Breakpoint Control Registers",
        "purpose": "Holds control information for a breakpoint. \nForms breakpoint n together with value register DBGBVR<n>. \nIf EL2 is implemented and this breakpoint supports Context matching, DBGBVR<n>\ncan be associated with a Breakpoint Extended Value\nRegister DBGBXVR<n> for VMID matching.\n\nBT, bits [20:23]  - Breakpoint Type.\nLBN, bits [16:19] - Linked breakpoint number.\nSSC, bits [14:15] - Security state control.\nHMC, bit [13]     - Higher mode control.\nBAS, bits [5:8]   - Byte address select.\nPMC, bits [1:2]   - Privilege mode control.\nE, bit [0]        - Enable breakpoint DBGBVR<n>."
      },
      "DBGBVR<n>": {
        "long_name": "Debug Breakpoint Value Registers",
        "purpose": "Holds a value for use in breakpoint matching, either the virtual address of an\ninstruction or a context ID. Forms breakpoint n together with control register\nDBGBCR<n>. If EL2 is implemented and this breakpoint supports Context matching,\nDBGBVR<n> can be associated with a Breakpoint Extended Value Register DBGBXVR<n>\nfor VMID matching.\n\nVA[31:2], bits [2:31] - Bits[31:2] of the address value for comparison."
      },
      "DBGBXVR<n>": {
        "long_name": "Debug Breakpoint Extended Value Registers",
        "purpose": "Holds a value for use in breakpoint matching, to support VMID matching. Used in\nconjunction with a control register DBGBCR<n> and a value register DBGBVR<n>,\nwhere EL2 is implemented and breakpoint n supports Context matching.\n\nVMID[15:8], bits [8:15] - Extension to VMID[7:0]. See VMID[7:0] for more\n                          details.\nVMID[7:0], bits [0:7]   - VMID value for comparison. The VMID is 8 bits in the\n                          following cases.\n                            - EL2 is using AArch32.\n                            - ARMv8.1-VMID16 is not implemented. When\n                          ARMv8.1-VMID16 is implemented and EL2 is using\n                          AArch64, it is implementation defined whether the VMID\n                          is 8 bits or 16 bits. VMID[15:8] is res0 if any of the\n                          following applies:\n                            - The implementation has an 8-bit VMID.\n                            - VTCR_EL2.VS has a value of 0.\n                            - EL2 is using AArch32."
      },
      "DBGCLAIMCLR": {
        "long_name": "Debug Claim Tag Clear register",
        "purpose": "Used by software to read the values of the CLAIM tag bits, and to clear these\nbits to 0.\n\nThe architecture does not define any functionality for the CLAIM tag bits.\n\nCLAIM tags are typically used for communication between the debugger and target\nsoftware.\n\nUsed in conjunction with the DBGCLAIMSET register.\n\nCLAIM, bits [0:7] - Read or clear CLAIM tag bits. Reading this field returns the\n                    current value of the CLAIM tag bits. Writing a 1 to one of\n                    these bits clears the corresponding CLAIM tag bit to 0. This\n                    is an indirect write to the CLAIM tag bits. A single write\n                    operation can clear multiple CLAIM tag bits to 0. Writing 0\n                    to one of these bits has no effect."
      },
      "DBGCLAIMSET": {
        "long_name": "Debug Claim Tag Set register",
        "purpose": "Used by software to set the CLAIM tag bits to 1.\n\nThe architecture does not define any functionality for the CLAIM tag bits.\n\nCLAIM tags are typically used for communication between the debugger and target\nsoftware.\n\nUsed in conjunction with the DBGCLAIMCLR register.\n\nCLAIM, bits [0:7] - Set CLAIM tag bits. RAO. Writing a 1 to one of these bits\n                    sets the corresponding CLAIM tag bit to 1. This is an\n                    indirect write to the CLAIM tag bits. A single write\n                    operation can set multiple CLAIM tag bits to 1. Writing 0 to\n                    one of these bits has no effect."
      },
      "DBGDCCINT": {
        "long_name": "DCC Interrupt Enable Register",
        "purpose": "Enables interrupt requests to be signaled based on the DCC status flags.\n\nRX, bit [30] - DCC interrupt request enable control for DTRRX. Enables a common\n               COMMIRQ interrupt request to be signaled based on the DCC status\n               flags.\n                   0b0 No interrupt request generated by DTRRX.\n                   0b1 Interrupt request will be generated on RXfull == 1.\n               If legacy COMMRX and COMMTX signals are implemented, then these\n               are not affected by the value of this bit.\nTX, bit [29] - DCC interrupt request enable control for DTRTX. Enables a common\n               COMMIRQ interrupt request to be signaled based on the DCC status\n               flags.\n                   0b0 No interrupt request generated by DTRTX.\n                   0b1 Interrupt request will be generated on TXfull == 0.\n               If legacy COMMRX and COMMTX signals are implemented, then these\n               are not affected by the value of this bit."
      },
      "DBGDEVID": {
        "long_name": "Debug Device ID register 0",
        "purpose": "Adds to the information given by the DBGDIDR by describing other features of the\ndebug implementation.\n\nCIDMask, bits [28:31]     - Indicates the level of support for the Context ID\n                            matching breakpoint masking capability.\nAuxRegs, bits [24:27]     - Indicates support for Auxiliary registers.\nDoubleLock, bits [20:23]  - OS Double Lock implemented. This field indicates the\n                            presence of the OS Double Lock and the behavior of\n                            the DBGOSDLR, OS Double Lock Register.\nVirtExtns, bits [16:19]   - Indicates whether EL2 is implemented.\nVectorCatch, bits [12:15] - Defines the form of Vector Catch exception\n                            implemented.\nBPAddrMask, bits [8:11]   - Indicates the level of support for the instruction\n                            address matching breakpoint masking capability.\nWPAddrMask, bits [4:7]    - Indicates the level of support for the data address\n                            matching watchpoint masking capability.\nPCSample, bits [0:3]      - Indicates the level of PC Sample-based Profiling\n                            support using external debug registers."
      },
      "DBGDEVID1": {
        "long_name": "Debug Device ID register 1",
        "purpose": "Adds to the information given by the DBGDIDR by describing other features of the\ndebug implementation.\n\nPCSROffset, bits [0:3] - This field indicates the offset applied to PC samples\n                         returned by reads of EDPCSR. Permitted values of this\n                         field in ARMv8 are:\n                             0b0000 EDPCSR is not implemented.\n                             0b0010 EDPCSR implemented. Samples have no offset\n                         applied and do not sample the instruction set state in\n                         AArch32 state.\n                         When ARMv8.2-PCSample is implemented, the only\n                         permitted value is 0b0000. ARMv8.2-PCSample implements\n                         the PC Sample-based Profiling Extension in the\n                         Performance Monitors register space, as indicated by\n                         the value of PMDEVID.PCSample."
      },
      "DBGDEVID2": {
        "long_name": "Debug Device ID register 2",
        "purpose": "Reserved for future descriptions of features of the debug implementation."
      },
      "DBGDIDR": {
        "long_name": "Debug ID Register",
        "purpose": "Specifies which version of the Debug architecture is implemented, and some\nfeatures of the debug implementation.\n\nWRPs, bits [28:31]     - The number of watchpoints implemented, minus 1.\n                         Permitted values of this field are from 0b0001 for 2\n                         implemented watchpoints, to 0b1111 for 16 implemented\n                         watchpoints. The value of 0b0000 is reserved. If\n                         AArch64 is implemented, this field has the same value\n                         as ID_AA64DFR0_EL1.WRPs.\nBRPs, bits [24:27]     - The number of breakpoints implemented, minus 1.\n                         Permitted values of this field are from 0b0001 for 2\n                         implemented breakpoint, to 0b1111 for 16 implemented\n                         breakpoints. The value of 0b0000 is reserved. If\n                         AArch64 is implemented, this field has the same value\n                         as ID_AA64DFR0_EL1.BRPs.\nCTX_CMPs, bits [20:23] - The number of breakpoints that can be used for Context\n                         matching, minus 1. Permitted values of this field are\n                         from 0b0000 for 1 Context matching breakpoint, to\n                         0b1111 for 16 Context matching breakpoints. The Context\n                         matching breakpoints must be the highest addressed\n                         breakpoints. For example, if six breakpoints are\n                         implemented and two are Context matching breakpoints,\n                         they must be breakpoints 4 and 5. If AArch64 is\n                         implemented, this field has the same value as\n                         ID_AA64DFR0_EL1.CTX_CMPs.\nVersion, bits [16:19]  - The Debug architecture version.\nnSUHD_imp, bit [14]    - In ARMv7-A, was Secure User Halting Debug not\n                         implemented. The value of this bit must match the value\n                         of the SE_imp bit.\nSE_imp, bit [12]       - EL3 implemented."
      },
      "DBGDRAR": {
        "long_name": "Debug ROM Address Register",
        "purpose": "Defines the base physical address of a 4KB-aligned memory-mapped debug\ncomponent, usually a ROM table that locates and describes the memory-mapped\ndebug components in the system. ARMv8 deprecates any use of this register.\n\nROMADDR[31:12], bits [12:31] - Bits[31:12] of the ROM table physical address.\n                               Bits [11:0] of the address are zero. In an\n                               implementation that includes EL3, ROMADDR is an\n                               address in Non-secure memory. It is\n                               implementation defined whether the ROM table is\n                               also accessible in Secure memory.\nValid, bits [0:1]            - This field indicates whether the ROM Table\n                               address is valid. The permitted values of this\n                               field are:\n                                   0b00 ROM Table address is not valid. Software\n                               must ignore ROMADDR.\n                                   0b11 ROM Table address is valid.\n                               Other values are reserved."
      },
      "DBGDSAR": {
        "long_name": "Debug Self Address Register",
        "purpose": "In earlier versions of the ARM Architecture, this register defines the offset\nfrom the base address defined in DBGDRAR of the physical base address of the\ndebug registers for the PE. ARMv8 deprecates any use of this register.\n\nOffset, bits [0:31] - This register value is RAZ."
      },
      "DBGDSCRext": {
        "long_name": "Debug Status and Control Register, External View",
        "purpose": "Main control register for the debug implementation.\n\nTFO, bit [31]        - Trace Filter override.\nRXfull, bit [30]     - DTRRX full.\nTXfull, bit [29]     - DTRTX full.\nRXO, bit [27]        - Used for save/restore of EDSCR.RXO.\nTXU, bit [26]        - Used for save/restore of EDSCR.TXU.\nINTdis, bits [22:23] - Used for save/restore of EDSCR.INTdis.\nTDA, bit [21]        - Used for save/restore of EDSCR.TDA.\nSC2, bit [19]        - Used for save/restore of EDSCR.SC2.\nNS, bit [18]         - Non-secure status.\nSPNIDdis, bit [17]   - Secure privileged profiling disabled status bit.\nSPIDdis, bit [16]    - Secure privileged AArch32 invasive self-hosted debug\n                       disabled status bit.\nMDBGen, bit [15]     - Monitor debug events enable.\nHDE, bit [14]        - Used for save/restore of EDSCR.HDE.\nUDCCdis, bit [12]    - Traps EL0 accesses to the DCC registers to Undefined\n                       mode.\nERR, bit [6]         - Used for save/restore of EDSCR.ERR.\nMOE, bits [2:5]      - Method of Entry for debug exception."
      },
      "DBGDSCRint": {
        "long_name": "Debug Status and Control Register, Internal View",
        "purpose": "Main control register for the debug implementation. This is an internal, read-\nonly view.\n\nRXfull, bit [30]   - DTRRX full. Read-only view of the equivalent bit in the\n                     EDSCR.\nTXfull, bit [29]   - DTRTX full. Read-only view of the equivalent bit in the\n                     EDSCR.\nNS, bit [18]       - Non-secure status. Read-only view of the equivalent bit in\n                     the DBGDSCRext. ARM deprecates use of this field.\nSPNIDdis, bit [17] - Secure privileged non-invasive debug disable. Read-only\n                     view of the equivalent bit in the DBGDSCRext. ARM\n                     deprecates use of this field.\nSPIDdis, bit [16]  - Secure privileged invasive debug disable. Read-only view of\n                     the equivalent bit in the DBGDSCRext. ARM deprecates use of\n                     this field.\nMDBGen, bit [15]   - Monitor debug events enable. Read-only view of the\n                     equivalent bit in the DBGDSCRext.\nUDCCdis, bit [12]  - User mode access to Debug Communications Channel disable.\n                     Read-only view of the equivalent bit in the DBGDSCRext. ARM\n                     deprecates use of this field.\nMOE, bits [2:5]    - Method of Entry for debug exception. When a debug exception\n                     is taken to an Exception level using AArch32, this field is\n                     set to indicate the event that caused the exception:\n                         0b0001 Breakpoint\n                         0b0011 Software breakpoint (BKPT) instruction\n                         0b0101 Vector catch\n                         0b1010 Watchpoint\n                     Read-only view of the equivalent bit in the DBGDSCRext."
      },
      "DBGDTRRXext": {
        "long_name": "Debug OS Lock Data Transfer Register, Receive, External View",
        "purpose": "Used for save/restore of DBGDTRRXint. It is a component of the Debug\nCommunications Channel.\n\nbits [0:31] - Update DTRRX without side-effect. Writes to this register update\n              the value in DTRRX and do not change RXfull. Reads of this\n              register return the last value written to DTRRX and do not change\n              RXfull. For the full behavior of the Debug Communications Channel,\n              see 'The Debug Communication Channel and Instruction Transfer\n              Register' in the ARM ARM, chapter H4."
      },
      "DBGDTRRXint": {
        "long_name": "Debug Data Transfer Register, Receive",
        "purpose": "Transfers data from an external debugger to the PE. For example, it is used by a\ndebugger transferring commands and data to a debug target. It is a component of\nthe Debug Communications Channel.\n\nbits [0:31] - Update DTRRX. If RXfull is set to 1, then reads of this register\n              return the last value written to DTRRX and clear RXfull to 0. For\n              the full behavior of the Debug Communications Channel, see 'The\n              Debug Communication Channel and Instruction Transfer Register' in\n              the ARM ARM, chapter H4."
      },
      "DBGDTRTXext": {
        "long_name": "Debug OS Lock Data Transfer Register, Transmit",
        "purpose": "Used for save/restore of DBGDTRTXint. It is a component of the Debug\nCommunication Channel.\n\nbits [0:31] - Return DTRTX without side-effect. Reads of this register return\n              the value in DTRTX and do not change TXfull. Writes of this\n              register update the value in DTRTX and do not change TXfull. For\n              the full behavior of the Debug Communications Channel, see 'The\n              Debug Communication Channel and Instruction Transfer Register' in\n              the ARM ARM, chapter H4."
      },
      "DBGDTRTXint": {
        "long_name": "Debug Data Transfer Register, Transmit",
        "purpose": "Transfers data from the PE to an external debugger. For example, it is used by a\ndebug target to transfer data to the debugger. It is a component of the Debug\nCommunication Channel.\n\nbits [0:31] - Return DTRTX. If TXfull is set to 0, then writes of this register\n              update the value in DTRTX and set TXfull to 1. For the full\n              behavior of the Debug Communications Channel, see 'The Debug\n              Communication Channel and Instruction Transfer Register' in the\n              ARM ARM, chapter H4."
      },
      "DBGOSDLR": {
        "long_name": "Debug OS Double Lock Register",
        "purpose": "Locks out the external debug interface.\n\nDLK, bit [0] - OS Double Lock control bit. Possible values are:\n                   0b0 OS Double Lock unlocked.\n                   0b1 OS Double Lock locked, if DBGPRCR.CORENPDRQ (Core no\n               powerdown request) bit is set to 0 and the PE is in Non-debug\n               state."
      },
      "DBGOSECCR": {
        "long_name": "Debug OS Lock Exception Catch Control Register",
        "purpose": "Provides a mechanism for an operating system to access the contents of EDECCR\nthat are otherwise invisible to software, so it can save/restore the contents of\nEDECCR over powerdown on behalf of the external debugger.\n\nEDECCR, bits [0:31] - Used for save/restore to EDECCR over powerdown. Reads or\n                      writes to this field are indirect accesses to EDECCR."
      },
      "DBGOSLAR": {
        "long_name": "Debug OS Lock Access Register",
        "purpose": "Provides a lock for the debug registers. The OS Lock also disables some debug\nexceptions and debug events.\n\nOS Lock Access, bits [0:31] - OS Lock Access. Writing the value 0xC5ACCE55 to\n                              the DBGOSLAR sets the OS lock to 1. Writing any\n                              other value sets the OS lock to 0. Use\n                              DBGOSLSR.OSLK to check the current status of the\n                              lock."
      },
      "DBGOSLSR": {
        "long_name": "Debug OS Lock Status Register",
        "purpose": "Provides status information for the OS Lock.\n\nOSLM[3,0], bit [3] - OS lock model implemented. Bits [3] and [0] interpreted\n                     together identify the form of OS save and restore mechanism\n                     implemented.\n                         0b00 OS Lock not implemented.\n                         0b10 OS Lock implemented.\n                     All other values are reserved. In an ARMv8 implementation\n                     the value 0b00 is not permitted.\nnTT, bit [2]       - Not 32-bit access. This bit is always RAZ. It indicates\n                     that a 32-bit access is needed to write the key to the OS\n                     Lock Access Register.\nOSLK, bit [1]      - OS Lock Status. The possible values are:\n                         0b0 OS Lock unlocked.\n                         0b1 OS Lock locked.\n                     The OS Lock is locked and unlocked by writing to the OS\n                     Lock Access Register.\nOSLM[3,0], bit [0] - OS lock model implemented. Bits [3] and [0] interpreted\n                     together identify the form of OS save and restore mechanism\n                     implemented.\n                         0b00 OS Lock not implemented.\n                         0b10 OS Lock implemented.\n                     All other values are reserved. In an ARMv8 implementation\n                     the value 0b00 is not permitted."
      },
      "DBGPRCR": {
        "long_name": "Debug Power Control Register",
        "purpose": "Controls behavior of the PE on powerdown request.\n\nCORENPDRQ, bit [0] - Core no powerdown request. Requests emulation of powerdown.\n                     This request is typically passed to an external power\n                     controller. This means that whether a request causes power\n                     up is dependent on the implementation defined nature of the\n                     system. The power controller must not allow the Core power\n                     domain to switch off while this bit is 1.\n                         0b0 If the system responds to a powerdown request, it\n                     powers down Core power domain.\n                         0b1 If the system responds to a powerdown request, it\n                     does not powerdown the Core power domain, but instead\n                     emulates a powerdown of that domain.\n                     In an implementation that includes the recommended external\n                     debug interface, this bit drives the DBGNOPWRDWN signal. It\n                     is implementation defined whether this bit is reset to the\n                     value of EDPRCR.COREPURQ on exit from an implementation\n                     defined software-visible retention state. Writes to this\n                     bit are not prohibited by the implementation defined\n                     authentication interface. This means that a debugger can\n                     request emulation of powerdown regardless of whether\n                     invasive debug is permitted."
      },
      "DBGVCR": {
        "long_name": "Debug Vector Catch Register",
        "purpose": "Controls Vector Catch debug events.\n\nNSF, bit [31] - FIQ vector catch enable in Non-secure state.\nNSI, bit [30] - IRQ vector catch enable in Non-secure state.\nNSD, bit [28] - Data Abort vector catch enable in Non-secure state.\nNSP, bit [27] - Prefetch Abort vector catch enable in Non-secure state.\nNSS, bit [26] - Supervisor Call (SVC) vector catch enable in Non-secure state.\nNSU, bit [25] - Undefined Instruction vector catch enable in Non-secure state.\nMF, bit [15]  - FIQ vector catch enable in Monitor mode.\nMI, bit [14]  - IRQ vector catch enable in Monitor mode.\nMD, bit [12]  - Data Abort vector catch enable in Monitor mode.\nMP, bit [11]  - Prefetch Abort vector catch enable in Monitor mode.\nMS, bit [10]  - Secure Monitor Call (SMC) vector catch enable in Monitor mode.\nSF, bit [7]   - FIQ vector catch enable in Secure state.\nSI, bit [6]   - IRQ vector catch enable in Secure state.\nSD, bit [4]   - Data Abort vector catch enable in Secure state.\nSP, bit [3]   - Prefetch Abort vector catch enable in Secure state.\nSS, bit [2]   - Supervisor Call (SVC) vector catch enable in Secure state.\nSU, bit [1]   - Undefined Instruction vector catch enable in Secure state."
      },
      "DBGWCR<n>": {
        "long_name": "Debug Watchpoint Control Registers",
        "purpose": "Holds control information for a watchpoint. Forms watchpoint n together with\nvalue register DBGWVR<n>.\n\nMASK, bits [24:28] - Address mask.\nWT, bit [20]       - Watchpoint type.\nLBN, bits [16:19]  - Linked breakpoint number.\nSSC, bits [14:15]  - Security state control.\nHMC, bit [13]      - Higher mode control.\nBAS, bits [5:12]   - Byte address select.\nLSC, bits [3:4]    - Load/store control.\nPAC, bits [1:2]    - Privilege of access control.\nE, bit [0]         - Enable watchpoint n."
      },
      "DBGWFAR": {
        "long_name": "Debug Watchpoint Fault Address Register",
        "purpose": "Previously returned information about the address of the instruction that\naccessed a watchpointed address. Is now deprecated and res0."
      },
      "DBGWVR<n>": {
        "long_name": "Debug Watchpoint Value Registers",
        "purpose": "Holds a data address value for use in watchpoint matching. Forms watchpoint n\ntogether with control register DBGWCR<n>.\n\nVA, bits [2:31] - Bits[31:2] of the address value for comparison. ARM deprecates\n                  setting DBGWVR<n>[2] == 1."
      },
      "DFAR": {
        "long_name": "Data Fault Address Register",
        "purpose": "Holds the virtual address of the faulting address that caused a synchronous Data\nAbort exception.\n\nbits [0:31] - VA of faulting address of synchronous Data Abort exception."
      },
      "DFSR": {
        "long_name": "Data Fault Status Register",
        "purpose": "Holds status information about the last data fault.\n\nFnV, bit [16]           - FAR not Valid, for a synchronous External abort other\n                          than a synchronous External abort on a translation\n                          table walk.\nAET, bits [14:15]       - Asynchronous Error Type.\nCM, bit [13]            - Cache maintenance fault.\nExT, bit [12]           - External abort type.\nWnR, bit [11]           - Write not Read bit.\nFS[10, 3:0], bit [10]   - Fault status bits.\nLPAE, bit [9]           - On taking a Data Abort exception, this bit is set as\n                          follows:\nDomain, bits [4:7]      - The domain of the fault address.\nFS[10, 3:0], bits [0:3] - Fault status bits."
      },
      "DISR": {
        "long_name": "Deferred Interrupt Status Register",
        "purpose": "Records that an SError interrupt has been consumed by an ESB instruction.\n\nA, bit [31]       - Set to 1 when an ESB instruction defers an asynchronous\n                    SError interrupt. If the implementation does not include any\n                    sources of SError interrupt that can be synchronized by an\n                    Error Synchronization Barrier, then this bit is res0.\nAET, bits [10:11] - Asynchronous Error Type. See the description of HSR.AET for\n                    an SError interrupt.\nEA, bit [9]       - External Abort Type. See the description of HSR.EA for an\n                    SError interrupt.\nDFSC, bits [0:5]  - Fault Status Code. See the description of HSR.DFSC for an\n                    SError interrupt."
      },
      "DLR": {
        "long_name": "Debug Link Register",
        "purpose": "In Debug state, holds the address to restart from.\n\nbits [0:31] - Restart address."
      },
      "DSPSR": {
        "long_name": "Debug Saved Program Status Register",
        "purpose": "Holds the saved process state on entry to Debug state.\n\nN, bit [31]        - Set to the value of PSTATE.N on entering Debug state, and\n                     copied to PSTATE.N on exiting Debug state.\nZ, bit [30]        - Set to the value of PSTATE.Z on entering Debug state, and\n                     copied to PSTATE.Z on exiting Debug state.\nC, bit [29]        - Set to the value of PSTATE.C on entering Debug state, and\n                     copied to PSTATE.C on exiting Debug state.\nV, bit [28]        - Set to the value of PSTATE.V on entering Debug state, and\n                     copied to PSTATE.V on exiting Debug state.\nQ, bit [27]        - Set to the value of PSTATE.Q on entering Debug state, and\n                     copied to PSTATE.Q on exiting Debug state.\nIT, bits [25:26]   - IT block state bits for the T32 IT (If-Then) instruction.\nDIT, bit [24]      - Data Independent Timing.\nPAN, bit [22]      - Privileged Access Never.\nSS, bit [21]       - Software step.\nIL, bit [20]       - Illegal Execution state bit.\nGE, bits [16:19]   - Greater than or Equal flags, for parallel addition and\n                     subtraction.\nIT, bits [10:15]   - IT block state bits for the T32 IT (If-Then) instruction.\nE, bit [9]         - Endianness state bit.\nA, bit [8]         - SError interrupt mask bit.\nI, bit [7]         - IRQ mask bit.\nF, bit [6]         - FIQ mask bit.\nT, bit [5]         - T32 Instruction set state bit.\nM[4], bit [4]      - Execution state that Debug state was entered from.\nM[3:0], bits [0:3] - AArch32 mode that Debug state was entered from."
      },
      "ELR_hyp": {
        "long_name": "Exception Link Register (Hyp mode)",
        "purpose": "When taking an exception to Hyp mode, holds the address to return to.\n\nbits [0:31] - Return address."
      },
      "ERRIDR": {
        "long_name": "Error Record ID Register",
        "purpose": "Defines the highest numbered index of the error records that can be accessed\nthrough the Error Record System registers.\n\nNUM, bits [0:15] - Highest numbered index of the records that can be accessed\n                   through the Error Record System registers plus one. Zero\n                   indicates that no records can be accessed through the Error\n                   Record System registers. Each implemented record is owned by\n                   a node. A node might own multiple records."
      },
      "ERRSELR": {
        "long_name": "Error Record Select Register",
        "purpose": "Selects an error record to be accessed through the Error Record System\nregisters.\n\nSEL, bits [0:15] - Selects the error record accessed through the ERX registers.\n                   If ERRSELR.SEL is set to a value greater than or equal to\n                   ERRIDR.NUM, then all of the following apply:\n                     -  The value read back from ERRSELR.SEL is unknown.\n                     -  One of the following occurs:\n                       -  An unknown error record is selected.\n                       -  The ERX* registers are RAZ/WI.\n                       -  ERX* register reads and writes are NOPs.\n                       -  ERX* register reads and writes are undefined."
      },
      "ERXADDR": {
        "long_name": "Selected Error Record Address Register",
        "purpose": "Accesses bits [31:0] of ERR<n>ADDR for the error record selected by ERRSELR.SEL.\n\nbits [0:31] - ERXADDR accesses bits [31:0] of ERR<n>ADDR, where n is the value\n              in ERRSELR.SEL."
      },
      "ERXADDR2": {
        "long_name": "Selected Error Record Address Register 2",
        "purpose": "Accesses bits [63:32] of ERR<n>ADDR for the error record selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXADDR2 accesses bits [63:32] of ERR<n>ADDR, where n is the value\n              in ERRSELR.SEL."
      },
      "ERXCTLR": {
        "long_name": "Selected Error Record Control Register",
        "purpose": "Accesses bits [31:0] of ERR<n>CTLR for the error record selected by ERRSELR.SEL.\n\nbits [0:31] - ERXCTLR accesses bits [31:0] of ERR<n>CTLR, where n is the value\n              in ERRSELR.SEL."
      },
      "ERXCTLR2": {
        "long_name": "Selected Error Record Control Register 2",
        "purpose": "Accesses bits [63:32] of ERR<n>CTLR for the error record selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXCTLR2 accesses bits [63:32] of ERR<n>CTLR, where n is the value\n              in ERRSELR.SEL."
      },
      "ERXFR": {
        "long_name": "Selected Error Record Feature Register",
        "purpose": "Accesses bits [31:0] of ERR<n>FR for the error record selected by ERRSELR.SEL.\n\nbits [0:31] - ERXFR accesses bits [31:0] of ERR<n>FR, where n is the value in\n              ERRSELR.SEL."
      },
      "ERXFR2": {
        "long_name": "Selected Error Record Feature Register 2",
        "purpose": "Accesses bits [63:32] of ERR<n>FR for the error record selected by ERRSELR.SEL.\n\nbits [0:31] - ERXFR2 accesses bits [63:32] of ERR<n>FR, where n is the value in\n              ERRSELR.SEL."
      },
      "ERXMISC0": {
        "long_name": " Selected Error Record Miscellaneous Register 0",
        "purpose": "Accesses bits [31:0] of ERR<n>MISC0 for the error record selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC0 accesses bits [31:0] of ERR<n>MISC0, where n is the value\n              in ERRSELR.SEL."
      },
      "ERXMISC1": {
        "long_name": " Selected Error Record Miscellaneous Register 1",
        "purpose": "Accesses bits [63:32] of ERR<n>MISC0 for the error record selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC1 accesses bits [63:32] of ERR<n>MISC0, where n is the\n              value in ERRSELR.SEL."
      },
      "ERXMISC2": {
        "long_name": " Selected Error Record Miscellaneous Register 2",
        "purpose": "Accesses bits [31:0] of ERR<n>MISC1 for the error record selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC2 accesses bits [31:0] of ERR<n>MISC1, where n is the value\n              in ERRSELR.SEL."
      },
      "ERXMISC3": {
        "long_name": " Selected Error Record Miscellaneous Register 3",
        "purpose": "Accesses bits [63:32] of ERR<n>MISC1 for the error record selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC3 accesses bits [63:32] of ERR<n>MISC1, where n is the\n              value in ERRSELR.SEL."
      },
      "ERXMISC4": {
        "long_name": " Selected Error Record Miscellaneous Register 4",
        "purpose": "Accesses bits [31:0] of ERR<n>MISC2 for the error record selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC4 accesses bits [31:0] of ERR<n>MISC2, where n is the value\n              in ERRSELR.SEL."
      },
      "ERXMISC5": {
        "long_name": " Selected Error Record Miscellaneous Register 5",
        "purpose": "Accesses bits [63:32] of ERR<n>MISC2 for the error record selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC5 accesses bits [63:32] of ERR<n>MISC2, where n is the\n              value in ERRSELR.SEL."
      },
      "ERXMISC6": {
        "long_name": " Selected Error Record Miscellaneous Register 6",
        "purpose": "Accesses bits [31:0] of ERR<n>MISC3 for the error record selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC6 accesses bits [31:0] of ERR<n>MISC3, where n is the value\n              in ERRSELR.SEL."
      },
      "ERXMISC7": {
        "long_name": " Selected Error Record Miscellaneous Register 7",
        "purpose": "Accesses bits [63:32] of ERR<n>MISC3 for the error record selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXMISC7 accesses bits [63:32] of ERR<n>MISC3, where n is the\n              value in ERRSELR.SEL."
      },
      "ERXSTATUS": {
        "long_name": "Selected Error Record Primary Status Register",
        "purpose": "Accesses bits [31:0] of ERR<n>STATUS for the error record selected by\nERRSELR.SEL.\n\nbits [0:31] - ERXSTATUS accesses bits [31:0] of ERR<n>STATUS, where n is the\n              value in ERRSELR.SEL."
      },
      "FCSEIDR": {
        "long_name": "FCSE Process ID register",
        "purpose": "Identifies whether the Fast Context Switch Extension (FCSE) is implemented.\n\nIn ARMv8, the FCSE is not implemented, so this register is RAZ/WI. Software can\naccess this register to determine that the implementation does not include the\nFCSE."
      },
      "FPEXC": {
        "long_name": "Floating-Point Exception Control register",
        "purpose": "Provides a global enable for the implemented Advanced SIMD and floating-point\nfunctionality, and reports floating-point status information.\n\nEX, bit [31]        - Exception bit.\nEN, bit [30]        - Enables access to the Advanced SIMD and floating-point\n                      functionality from all Exception levels, except that\n                      setting this field to 0 does not disable the following.\nDEX, bit [29]       - Defined synchronous exception on floating-point execution.\nFP2V, bit [28]      - FPINST2 instruction valid bit.\nVV, bit [27]        - VECITR valid bit.\nTFV, bit [26]       - Trapped Fault Valid bit.\nVECITR, bits [8:10] - Vector iteration count.\nIDF, bit [7]        - Input Denormal trapped exception bit.\nIXF, bit [4]        - Inexact trapped exception bit.\nUFF, bit [3]        - Underflow trapped exception bit.\nOFF, bit [2]        - Overflow trapped exception bit.\nDZF, bit [1]        - Divide by Zero trapped exception bit.\nIOF, bit [0]        - Invalid Operation trapped exception bit."
      },
      "FPSCR": {
        "long_name": "Floating-Point Status and Control Register",
        "purpose": "Provides floating-point system status information and control.\n\nN, bit [31]          - Negative condition flag.\nZ, bit [30]          - Zero condition flag.\nC, bit [29]          - Carry condition flag.\nV, bit [28]          - Overflow condition flag.\nQC, bit [27]         - Cumulative saturation bit, Advanced SIMD only.\nAHP, bit [26]        - Alternative half-precision control bit:\nDN, bit [25]         - Default NaN mode control bit:\nFZ, bit [24]         - Flush-to-zero mode control bit:\nRMode, bits [22:23]  - Rounding Mode control field.\nStride, bits [20:21] - It is implementation defined whether this field is RW or\n                       RAZ.\nFZ16, bit [19]       - Flush-to-zero mode control bit on half-precision data-\n                       processing instructions:\nLen, bits [16:18]    - It is implementation defined whether this field is RW or\n                       RAZ.\nIDE, bit [15]        - Input Denormal floating-point exception trap enable.\nIXE, bit [12]        - Inexact floating-point exception trap enable.\nUFE, bit [11]        - Underflow floating-point exception trap enable.\nOFE, bit [10]        - Overflow floating-point exception trap enable.\nDZE, bit [9]         - Divide by Zero floating-point exception trap enable.\nIOE, bit [8]         - Invalid Operation floating-point exception trap enable.\nIDC, bit [7]         - Input Denormal cumulative floating-point exception bit.\nIXC, bit [4]         - Inexact cumulative floating-point exception bit.\nUFC, bit [3]         - Underflow cumulative floating-point exception bit.\nOFC, bit [2]         - Overflow cumulative floating-point exception bit.\nDZC, bit [1]         - Divide by Zero cumulative floating-point exception bit.\nIOC, bit [0]         - Invalid Operation cumulative floating-point exception\n                       bit."
      },
      "FPSID": {
        "long_name": "Floating-Point System ID register",
        "purpose": "Provides top-level information about the floating-point implementation.\n\nThis register largely duplicates information held in the MIDR. ARM deprecates\nuse of it.\n\nImplementer, bits [24:31]     - Implementer codes are the same as those used for\n                                the MIDR. For an implementation by ARM this\n                                field is 0x41, the ASCII code for A.\nSW, bit [23]                  - Software bit.\nSubarchitecture, bits [16:22] - Subarchitecture version number.\nPartNum, bits [8:15]          - An implementation defined part number for the\n                                floating-point implementation, assigned by the\n                                implementer.\nVariant, bits [4:7]           - An implementation defined variant number.\n                                Typically, this field distinguishes between\n                                different production variants of a single\n                                product.\nRevision, bits [0:3]          - An implementation defined revision number for\n                                the floating-point implementation."
      },
      "HACR": {
        "long_name": "Hyp Auxiliary Configuration Register",
        "purpose": "Controls trapping to Hyp mode of implementation defined aspects of Non-secure\nEL1 or EL0 operation."
      },
      "HACTLR": {
        "long_name": "Hyp Auxiliary Control Register",
        "purpose": "Controls implementation defined features of Hyp mode operation."
      },
      "HACTLR2": {
        "long_name": "Hyp Auxiliary Control Register 2",
        "purpose": "Provides additional space to the HACTLR register to hold implementation defined\ntrap functionality."
      },
      "HADFSR": {
        "long_name": "Hyp Auxiliary Data Fault Status Register",
        "purpose": "Provides additional implementation defined syndrome information for Data Abort\nexceptions taken to Hyp mode."
      },
      "HAIFSR": {
        "long_name": "Hyp Auxiliary Instruction Fault Status Register",
        "purpose": "Provides additional implementation defined syndrome information for Prefetch\nAbort exceptions taken to Hyp mode."
      },
      "HAMAIR0": {
        "long_name": "Hyp Auxiliary Memory Attribute Indirection Register 0",
        "purpose": "Provides implementation defined memory attributes for the memory attribute\nencodings defined by HMAIR0. These implementation defined attributes can only\nprovide additional qualifiers for the memory attribute encodings, and cannot\nchange the memory attributes defined in HMAIR0."
      },
      "HAMAIR1": {
        "long_name": "Hyp Auxiliary Memory Attribute Indirection Register 1",
        "purpose": "Provides implementation defined memory attributes for the memory attribute\nencodings defined by HMAIR1. These implementation defined attributes can only\nprovide additional qualifiers for the memory attribute encodings, and cannot\nchange the memory attributes defined in HMAIR1."
      },
      "HCPTR": {
        "long_name": "Hyp Architectural Feature Trap Register",
        "purpose": "Controls:\n\n  - Trapping to Hyp mode of Non-secure access, at EL1 or EL0, to trace, and to\nAdvanced SIMD and floating-point functionality.\n  - Hyp mode access to trace, and to Advanced SIMD and floating-point\nfunctionality.\n\nAccesses to this functionality:\n  - From Non-secure modes other than Hyp mode are also affected by settings in\nthe CPACR and NSACR.\n  - From Hyp mode are also affected by settings in the NSACR.Exceptions\ngenerated by the CPACR and NSACR controls are higher priority than those\ngenerated by the HCPTR controls.\n\nTCPAC, bit [31] - Traps Non-secure EL1 accesses to the CPACR to Hyp mode.\nTAM, bit [30]   - Trap Activity Monitor access.\nTTA, bit [20]   - Traps Non-secure System register accesses to all implemented\n                  trace registers to Hyp mode.\nTASE, bit [15]  - Traps Non-secure execution of Advanced SIMD instructions to\n                  Hyp mode when the value of HCPTR.TCP10 is 0.\nTCP11, bit [11] - The value of this field is ignored.\nTCP10, bit [10] - Trap Non-secure accesses to Advanced SIMD and floating-point\n                  functionality to Hyp mode:"
      },
      "HCR": {
        "long_name": "Hyp Configuration Register",
        "purpose": "Provides configuration controls for virtualization, including defining whether\nvarious Non-secure operations are trapped to Hyp mode.\n\nTRVM, bit [30]    - Trap Reads of Virtual Memory controls.\nHCD, bit [29]     - HVC instruction disable.\nTGE, bit [27]     - Trap General Exceptions, from Non-secure EL0.\nTVM, bit [26]     - Trap Virtual Memory controls.\nTTLB, bit [25]    - Trap TLB maintenance instructions.\nTPU, bit [24]     - Trap cache maintenance instructions that operate to the\n                    Point of Unification.\nTPC, bit [23]     - Trap data or unified cache maintenance instructions that\n                    operate to the Point of Coherency.\nTSW, bit [22]     - Trap data or unified cache maintenance instructions that\n                    operate by Set/Way.\nTAC, bit [21]     - Trap Auxiliary Control Registers.\nTIDCP, bit [20]   - Trap implementation defined functionality.\nTSC, bit [19]     - Trap SMC instructions.\nTID3, bit [18]    - Trap ID group 3.\nTID2, bit [17]    - Trap ID group 2.\nTID1, bit [16]    - Trap ID group 1.\nTID0, bit [15]    - Trap ID group 0.\nTWE, bit [14]     - Traps Non-secure EL0 and EL1 execution of WFE instructions\n                    to EL2, when EL2 is enabled in the current Security state.\nTWI, bit [13]     - Traps Non-secure EL0 and EL1 execution of WFI instructions\n                    to EL2, when EL2 is enabled in the current Security state.\nDC, bit [12]      - Default Cacheability.\nBSU, bits [10:11] - Barrier Shareability upgrade.\nFB, bit [9]       - Force broadcast.\nVA, bit [8]       - Virtual SError interrupt exception.\nVI, bit [7]       - Virtual IRQ exception.\nVF, bit [6]       - Virtual FIQ exception.\nAMO, bit [5]      - SError interrupt Mask Override.\nIMO, bit [4]      - IRQ Mask Override.\nFMO, bit [3]      - FIQ Mask Override.\nPTW, bit [2]      - Protected Table Walk.\nSWIO, bit [1]     - Set/Way Invalidation Override.\nVM, bit [0]       - Virtualization enable."
      },
      "HCR2": {
        "long_name": "Hyp Configuration Register 2",
        "purpose": "Provides additional configuration controls for virtualization.\n\nTTLBIS, bit [22] - Trap TLB maintenance instructions that operate on the Inner\n                   Shareable domain.\nTOCU, bit [20]   - Trap cache maintenance instructions that operate to the Point\n                   of Unification.\nTICAB, bit [18]  - Trap ICIALLUIS cache maintenance instructions.\nTID4, bit [17]   - Trap ID group 4.\nMIOCNCE, bit [6] - Mismatched Inner/Outer Cacheable Non-Coherency Enable, for\n                   the Non-secure PL1&0 translation regime.\nTEA, bit [5]     - Route synchronous External abort exceptions from EL0 and EL1\n                   to EL2.\nTERR, bit [4]    - Trap Error record accesses from EL1 to EL2.\nID, bit [1]      - Stage 2 Instruction access cacheability disable.\nCD, bit [0]      - Stage 2 Data access cacheability disable."
      },
      "HDCR": {
        "long_name": "Hyp Debug Control Register",
        "purpose": "Controls the trapping to Hyp mode of Non-secure accesses, at EL1 or lower, to\nfunctions provided by the debug and trace architectures and the Performance\nMonitors Extension.\n\nHLP, bit [26]    - Hypervisor Long event counter enable.\nHCCD, bit [23]   - Hypervisor Cycle Counter Disable.\nTTRF, bit [19]   - Traps use of the Trace Filter Control registers at EL1 to\n                   EL2.\nHPMD, bit [17]   - Guest Performance Monitors Disable.\nTDRA, bit [11]   - Trap Debug ROM Address register access.\nTDOSA, bit [10]  - Trap debug OS-related register access.\nTDOSA, bit [10]  - Trap debug OS-related register access.\nTDA, bit [9]     - Trap debug access.\nTDE, bit [8]     - Trap Debug exceptions.\nHPME, bit [7]    - Hypervisor Performance Monitors Counters Enable.\nTPM, bit [6]     - Trap Performance Monitors accesses.\nTPMCR, bit [5]   - Trap PMCR accesses.\nHPMN, bits [0:4] - Defines the number of Performance Monitors counters that are\n                   accessible from Non-secure EL1 modes, and from Non-secure EL0\n                   modes if unprivileged access is enabled."
      },
      "HDFAR": {
        "long_name": "Hyp Data Fault Address Register",
        "purpose": "Holds the virtual address of the faulting address that caused a synchronous Data\nAbort exception that is taken to Hyp mode.\n\nbits [0:31] - VA of faulting address of synchronous Data Abort exception taken\n              to Hyp mode. On a Prefetch Abort exception, this register is\n              unknown. Any execution in a Non-secure EL1 or Non-secure EL0 mode\n              makes this register unknown."
      },
      "HIFAR": {
        "long_name": "Hyp Instruction Fault Address Register",
        "purpose": "Holds the virtual address of the faulting address that caused a synchronous\nPrefetch Abort exception that is taken to Hyp mode.\n\nbits [0:31] - VA of faulting address of synchronous Prefetch Abort exception\n              taken to Hyp mode. On a Data Abort exception, this register is\n              unknown. Any execution in a Non-secure EL1 or Non-secure EL0 mode\n              makes this register unknown."
      },
      "HMAIR0": {
        "long_name": "Hyp Memory Attribute Indirection Register 0",
        "purpose": "Along with HMAIR1, provides the memory attribute encodings corresponding to the\npossible AttrIndx values in a Long-descriptor format translation table entry for\nstage 1 translations for memory accesses from Hyp mode.\n\nAttrIndx[2] indicates the HMAIR register to be used:\n\n  - When AttrIndx[2] is 0, HMAIR0 is used.\n  - When AttrIndx[2] is 1, HMAIR1 is used.\n\nAttr<n>, bits [0:31] - The memory attribute encoding for an AttrIndx[2:0] entry\n                       in a Long descriptor format translation table entry,\n                       where:\n                         - AttrIndx[2:0] gives the value of <n> in Attr<n>.\n                         - AttrIndx[2] defines which MAIR to access. Attr7 to\n                       Attr4 are in MAIR1, and Attr3 to Attr0 are in MAIR0. Bits\n                       [7:4] are encoded as follows: R = Outer Read-Allocate\n                       policy, W = Outer Write-Allocate policy. The meaning of\n                       bits [3:0] depends on the value of bits [7:4]: R = Inner\n                       Read-Allocate policy, W = Inner Write-Allocate policy.\n                       The R and W bits in some Attr<n> fields have the\n                       following meanings:"
      },
      "HMAIR1": {
        "long_name": "Hyp Memory Attribute Indirection Register 1",
        "purpose": "Along with HMAIR0, provides the memory attribute encodings corresponding to the\npossible AttrIndx values in a Long-descriptor format translation table entry for\nstage 1 translations for memory accesses from Hyp mode.\n\nAttrIndx[2] indicates the HMAIR register to be used:\n\n  - When AttrIndx[2] is 0, HMAIR0 is used.\n  - When AttrIndx[2] is 1, HMAIR1 is used.\n\nAttr<n>, bits [0:31] - The memory attribute encoding for an AttrIndx[2:0] entry\n                       in a Long descriptor format translation table entry,\n                       where:\n                         - AttrIndx[2:0] gives the value of <n> in Attr<n>.\n                         - AttrIndx[2] defines which MAIR to access. Attr7 to\n                       Attr4 are in MAIR1, and Attr3 to Attr0 are in MAIR0. Bits\n                       [7:4] are encoded as follows: R = Outer Read-Allocate\n                       policy, W = Outer Write-Allocate policy. The meaning of\n                       bits [3:0] depends on the value of bits [7:4]: R = Inner\n                       Read-Allocate policy, W = Inner Write-Allocate policy.\n                       The R and W bits in some Attr<n> fields have the\n                       following meanings:"
      },
      "HPFAR": {
        "long_name": "Hyp IPA Fault Address Register",
        "purpose": "Holds the faulting IPA for some aborts on a stage 2 translation taken to Hyp\nmode.\n\nFIPA[39:12], bits [4:31] - Bits [39:12] of the faulting intermediate physical\n                           address."
      },
      "HRMR": {
        "long_name": "Hyp Reset Management Register",
        "purpose": "If EL2 is the highest implemented Exception level and this register is\nimplemented:\n\n  - A write to the register at EL2 can request a Warm reset.\n  - If EL2 can use AArch32 and AArch64, this register specifies the Execution\nstate that the PE boots into on a Warm reset.\n\nRR, bit [1]   - Reset Request. Setting this bit to 1 requests a Warm reset.\nAA64, bit [0] - When EL2 can use AArch64, determines which Execution state the\n                PE boots into after a Warm reset:\n                    0b0 AArch32.\n                    0b1 AArch64.\n                On coming out of the Warm reset, execution starts at the\n                implementation defined reset vector address of the specified\n                Execution state. If EL2 cannot use AArch64 this bit is RAZ/WI."
      },
      "HSCTLR": {
        "long_name": "Hyp System Control Register",
        "purpose": "Provides top level control of the system operation in Hyp mode.\n\nDSSBS, bit [31]  - Default PSTATE.SSBS value on Exception Entry.\nTE, bit [30]     - T32 Exception Enable.\nEE, bit [25]     - The value of the PSTATE.E bit on entry to Hyp mode, the\n                   endianness of stage 1 translation table walks in the EL2\n                   translation regime, and the endianness of stage 2 translation\n                   table walks in the PL1&0 translation regime.\nWXN, bit [19]    - Write permission implies XN (Execute-never). For the EL2\n                   translation regime, this bit can force all memory regions\n                   that are writable to be treated as XN.\nI, bit [12]      - Instruction access Cacheability control, for accesses at EL2:\nSED, bit [8]     - SETEND instruction disable. Disables SETEND instructions at\n                   EL2.\nITD, bit [7]     - IT Disable. Disables some uses of IT instructions at EL2.\nCP15BEN, bit [5] - System instruction memory barrier enable.\nLSMAOE, bit [4]  - Load Multiple and Store Multiple Atomicity and Ordering\n                   Enable.\nnTLSMD, bit [3]  - No Trap Load Multiple and Store Multiple to Device-nGRE\n                   /Device-nGnRE/Device-nGnRnE memory.\nC, bit [2]       - Cacheability control, for data accesses at EL2:\nA, bit [1]       - Alignment check enable.\nM, bit [0]       - MMU enable for EL2 stage 1 address translation."
      },
      "HSR": {
        "long_name": "Hyp Syndrome Register",
        "purpose": "Holds syndrome information for an exception taken to Hyp mode.\n\nEC, bits [26:31] - Exception Class. Indicates the reason for the exception that\n                   this register holds information about.\nIL, bit [25]     - Instruction length bit. Indicates the size of the instruction\n                   that has been trapped to Hyp mode.\nISS, bits [0:24] - Instruction Specific Syndrome. Architecturally, this field\n                   can be defined independently for each defined Exception\n                   class. However, in practice, some ISS encodings are used for\n                   more than one Exception class."
      },
      "HSTR": {
        "long_name": "Hyp System Trap Register",
        "purpose": "Controls trapping to Hyp mode of Non-secure accesses, at EL1 or lower, to System\nregisters in the coproc == 0b1111 encoding space:\n\n  - By the CRn value used to access the register using MCR or MRC instruction.\n  - By the CRm value used to access the register using MCRR or MRRC instruction.\n\nT<n>, bits [0:15] - Fields T14 and T4 are res0. The remaining fields control\n                    whether Non-secure EL0 and EL1 accesses, using MCR, MRC,\n                    MCRR, and MRRC instructions, to the System registers in the\n                    coproc == 0b1111 encoding space are trapped to Hyp mode:\n                        0b0 This control has no effect on Non-secure EL0 or EL1\n                    accesses to System registers.\n                        0b1 Any Non-secure EL1 MCR or MRC access with coproc ==\n                    0b1111 and CRn == <n> is trapped to Hyp mode. A Non-secure\n                    EL0 MCR or MRC access with these values is trapped to Hyp\n                    mode only if the access is not undefined when the value of\n                    this field is 0. Any Non-secure EL1 MCRR or MRRC access with\n                    coproc == 0b1111 and CRm == <n> is trapped to Hyp mode. A\n                    Non-secure EL0 MCRR or MRRC access with these values is\n                    trapped to Hyp mode only if the access is not undefined when\n                    the value of this field is 0.\n                    For example, when HSTR.T7 is 1, for instructions executed at\n                    Non-secure EL1:\n                      - An MCR or MRC instruction with coproc set to 0b1111 and\n                    <CRn> set to c7 is trapped to Hyp mode.\n                      - An MCRR or MRRC instruction with coproc set to 0b1111\n                    and <CRm> set to c7 is trapped to Hyp mode."
      },
      "HTCR": {
        "long_name": "Hyp Translation Control Register",
        "purpose": "The control register for stage 1 of the EL2 translation regime.\n\nThis stage of translation always uses the Long-descriptor translation table\nformat.\n\nHWU62, bit [28]     - Hardware Use. Indicates implementation defined hardware\n                      use of bit[62] of the stage 1 translation table Block or\n                      Page entry.\nHWU61, bit [27]     - Hardware Use. Indicates implementation defined hardware\n                      use of bit[61] of the stage 1 translation table Block or\n                      Page entry.\nHWU60, bit [26]     - Hardware Use. Indicates implementation defined hardware\n                      use of bit[60] of the stage 1 translation table Block or\n                      Page entry.\nHWU59, bit [25]     - Hardware Use. Indicates implementation defined hardware\n                      use of bit[59] of the stage 1 translation table Block or\n                      Page entry.\nHPD, bit [24]       - Hierarchical Permission Disables. This affects the\n                      hierarchical control bits, APTable, XNTable, and PXNTable,\n                      in the PL2 translation regime.\nSH0, bits [12:13]   - Shareability attribute for memory associated with\n                      translation table walks using HTTBR.\nORGN0, bits [10:11] - Outer cacheability attribute for memory associated with\n                      translation table walks using HTTBR.\nIRGN0, bits [8:9]   - Inner cacheability attribute for memory associated with\n                      translation table walks using HTTBR.\nT0SZ, bits [0:2]    - The size offset of the memory region addressed by HTTBR.\n                      The region size is 2^(32-T0SZ) bytes."
      },
      "HTPIDR": {
        "long_name": "Hyp Software Thread ID Register",
        "purpose": "Provides a location where software running in Hyp mode can store thread\nidentifying information that is not visible to Non-secure software executing at\nEL0 or EL1, for hypervisor management purposes.\n\nThe PE makes no use of this register.\n\nbits [0:31] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "HTRFCR": {
        "long_name": "Hyp Trace Filter Control Register",
        "purpose": "Provides EL2 controls for Trace.\n\nTS, bits [5:6]  - Timestamp Control. Controls which timebase is used for trace\n                  timestamps.\n                      0b00 The timestamp is controlled by TRFCR.TS.\n                      0b01 Virtual timestamp. The traced timestamp is the\n                  physical counter value minus the value of CNTVOFF.\n                      0b11 Physical timestamp. The traced timestamp is the\n                  physical counter value.\n                  When SelfHostedTraceEnabled() == FALSE, this field is ignored.\nCX, bit [3]     - VMID Trace Enable.\n                      0b0 VMID tracing is not allowed.\n                      0b1 VMID tracing is allowed.\n                  When SelfHostedTraceEnabled() == FALSE, this field is ignored.\nE2TRE, bit [1]  - EL2 Trace Enable.\n                      0b0 Tracing is prohibited at EL2.\n                      0b1 Tracing is allowed at EL2.\n                  When SelfHostedTraceEnabled() == FALSE, this field is ignored.\nE0HTRE, bit [0] - EL0 Trace Enable.\n                      0b0 Tracing is prohibited at EL0 when HCR.TGE == 1.\n                      0b1 Tracing is allowed at EL0 when HCR.TGE == 1.\n                  This field is ignored if any of the following are true:\n                    - The PE is in Secure state.\n                    - SelfHostedTraceEnabled() == FALSE.\n                    - HCR.TGE == 0."
      },
      "HTTBR": {
        "long_name": "Hyp Translation Table Base Register",
        "purpose": "Holds the base address of the translation table for the initial lookup for stage\n1 of an address translation in the EL2 translation regime, and other information\nfor this translation regime.\n\nBADDR, bits [1:47] - Translation table base address, bits[47:x], Bits [x-1:1]\n                     are res0, with the additional requirement that if\n                     bits[x-1:3] are not all zero, this is a misaligned\n                     translation table base address, with effects that are\n                     constrained unpredictable, and must be one of the\n                     following:\n                       - Register bits [x-1:3] are treated as if all the bits\n                     are zero. The value read back from these bits is either the\n                     value written or zero.\n                       - The result of the calculation of an address for a\n                     translation table walk using this register can be corrupted\n                     in those bits that are nonzero. x is determined from the\n                     value of HTCR.T0SZ as follows:\n                       - If HTCR.T0SZ is 0 or 1, x = 5 - HTCR.T0SZ.\n                       - If HTCR.T0SZ is greater than 1, x = 14 - HTCR.T0SZ. If\n                     bits[47:40] of the translation table base address are not\n                     zero, an Address size fault is generated.\nCnP, bit [0]       - Common not Private. This bit indicates whether each entry\n                     that is pointed to by HTTBR is a member of a common set\n                     that can be used by every PE in the Inner Shareable domain\n                     for which the value of HTTBR.CnP is 1."
      },
      "HVBAR": {
        "long_name": "Hyp Vector Base Address Register",
        "purpose": "Holds the vector base address for any exception that is taken to Hyp mode.\n\nbits [5:31] - Vector Base Address. Bits[31:5] of the base address of the\n              exception vectors for exceptions taken to this Exception level.\n              Bits[4:0] of an exception vector are the exception offset."
      },
      "ICC_AP0R<n>": {
        "long_name": "Interrupt Controller Active Priorities Group 0 Registers",
        "purpose": "Provides information about Group 0 active priorities."
      },
      "ICC_AP1R<n>": {
        "long_name": "Interrupt Controller Active Priorities Group 1 Registers",
        "purpose": "Provides information about Group 1 active priorities."
      },
      "ICC_ASGI1R": {
        "long_name": "Interrupt Controller Alias Software Generated Interrupt Group 1 Register",
        "purpose": "Generates Group 1 SGIs for the Security state that is not the current Security\nstate.\n\nAff3, bits [48:55]      - The affinity 3 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nRS, bits [44:47]        - RangeSelector Controls which group of 16 values is\n                          represented by the TargetList field.\nIRM, bit [40]           - Interrupt Routing Mode.\nAff2, bits [32:39]      - The affinity 2 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nINTID, bits [24:27]     - The INTID of the SGI.\nAff1, bits [16:23]      - The affinity 1 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nTargetList, bits [0:15] - Target List."
      },
      "ICC_BPR0": {
        "long_name": "Interrupt Controller Binary Point Register 0",
        "purpose": "Defines the point at which the priority value fields split into two parts, the\ngroup priority field and the subpriority field. The group priority field\ndetermines Group 0 interrupt preemption.\n\nBinaryPoint, bits [0:2] - The value of this field controls how the 8-bit\n                          interrupt priority field is split into a group\n                          priority field, that determines interrupt preemption,\n                          and a subpriority field. This is done as follows:"
      },
      "ICC_BPR1": {
        "long_name": "Interrupt Controller Binary Point Register 1",
        "purpose": "Defines the point at which the priority value fields split into two parts, the\ngroup priority field and the subpriority field. The group priority field\ndetermines Group 1 interrupt preemption.\n\nBinaryPoint, bits [0:2] - If the GIC is configured to use separate binary point\n                          fields for Group 0 and Group 1 interrupts, the value\n                          of this field controls how the 8-bit interrupt\n                          priority field is split into a group priority field,\n                          that determines interrupt preemption, and a\n                          subpriority field. For more information about\n                          priorities, see Priority grouping. Writing 0 to this\n                          field will set this field to its reset value. If EL3\n                          is implemented and ICC_MCTLR.CBPR_EL1S is 1:\n                            - Accesses to this register at EL3 not in Monitor\n                          mode access the state of ICC_BPR0.\n                            - When SCR_EL3.EEL2 is 1 and HCR_EL2.IMO is 1,\n                          Secure accesses to this register at EL1 access the\n                          state of ICV_BPR1.\n                            - Otherwise, Secure accesses to this register at EL1\n                          access the state of ICC_BPR0. If EL3 is implemented\n                          and ICC_MCTLR.CBPR_EL1NS is 1, Non-secure accesses to\n                          this register at EL1 or EL2 behave as follows,\n                          depending on the values of HCR.IMO and SCR.IRQ: If EL3\n                          is not implemented and ICC_CTLR.CBPR is 1, Non-secure\n                          accesses to this register at EL1 or EL2 behave as\n                          follows, depending on the values of HCR.IMO:"
      },
      "ICC_CTLR": {
        "long_name": "Interrupt Controller Control Register",
        "purpose": "Controls aspects of the behavior of the GIC CPU interface and provides\ninformation about the features implemented.\n\nExtRange, bit [19]   - Extended INTID range (read-only).\nRSS, bit [18]        - Range Selector Support.\nA3V, bit [15]        - Affinity 3 Valid. Read-only and writes are ignored.\nSEIS, bit [14]       - SEI Support. Read-only and writes are ignored.\nIDbits, bits [11:13] - Identifier bits. Read-only and writes are ignored.\nPRIbits, bits [8:10] - Priority bits. Read-only and writes are ignored. The\n                       number of priority bits implemented, minus one. An\n                       implementation that supports two Security states must\n                       implement at least 32 levels of physical priority (5\n                       priority bits). An implementation that supports only a\n                       single Security state must implement at least 16 levels\n                       of physical priority (4 priority bits). This field always\n                       returns the number of priority bits implemented,\n                       regardless of the Security state of the access or the\n                       value of GICD_CTLR.DS. The division between group\n                       priority and subpriority is defined in the binary point\n                       registers ICC_BPR0 and ICC_BPR1. If EL3 is implemented\n                       and using AArch32, physical accesses return the value\n                       from ICC_MCTLR.PRIbits. If EL3 is implemented and using\n                       AArch64, physical accesses return the value from\n                       ICC_CTLR_EL3.PRIbits. If EL3 is not implemented, physical\n                       accesses return the value from this field.\nPMHE, bit [6]        - Priority Mask Hint Enable.\nEOImode, bit [1]     - EOI mode for the current Security state.\nCBPR, bit [0]        - Common Binary Point Register."
      },
      "ICC_DIR": {
        "long_name": "Interrupt Controller Deactivate Interrupt Register",
        "purpose": "When interrupt priority drop is separated from interrupt deactivation, a write\nto this register deactivates the specified interrupt.\n\nINTID, bits [0:23] - The INTID of the interrupt to be deactivated. This field\n                     has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICC_CTLR.IDbits and\n                     ICC_MCTLR.IDbits. If only 16 bits are implemented, bits\n                     [23:16] of this register are res0."
      },
      "ICC_EOIR0": {
        "long_name": "Interrupt Controller End Of Interrupt Register 0",
        "purpose": "A PE writes to this register to inform the CPU interface that it has completed\nthe processing of the specified Group 0 interrupt.\n\nINTID, bits [0:23] - The INTID from the corresponding ICC_IAR0 access. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICC_CTLR.IDbits and\n                     ICC_MCTLR.IDbits. If only 16 bits are implemented, bits\n                     [23:16] of this register are res0. If the EOImode bit for\n                     the current Exception level and Security state is 0, a\n                     write to this register drops the priority for the\n                     interrupt, and also deactivates the interrupt. If the\n                     EOImode bit for the current Exception level and Security\n                     state is 1, a write to this register only drops the\n                     priority for the interrupt. Software must write to ICC_DIR\n                     to deactivate the interrupt. The appropriate EOImode bit\n                     varies as follows:\n                       - If EL3 is not implemented, the appropriate bit is\n                     ICC_CTLR.EOImode.\n                       - If EL3 is implemented and the software is executing in\n                     Monitor mode, the appropriate bit is ICC_MCTLR.EOImode_EL3.\n                       - If EL3 is implemented and the software is not executing\n                     in Monitor mode, the bit depends on the current Security\n                     state:\n                         - If the software is executing in Secure state, the bit\n                     is ICC_CTLR.EOImode in the Secure instance of ICC_CTLR.\n                     This is an alias of ICC_MCTLR.EOImode_EL1S.\n                         - If the software is executing in Non-secure state, the\n                     bit is ICC_CTLR.EOImode in the Non-secure instance of\n                     ICC_CTLR. This is an alias of ICC_MCTLR.EOImode_EL1NS."
      },
      "ICC_EOIR1": {
        "long_name": "Interrupt Controller End Of Interrupt Register 1",
        "purpose": "A PE writes to this register to inform the CPU interface that it has completed\nthe processing of the specified Group 1 interrupt.\n\nINTID, bits [0:23] - The INTID from the corresponding ICC_IAR1 access. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICC_CTLR.IDbits and\n                     ICC_MCTLR.IDbits. If only 16 bits are implemented, bits\n                     [23:16] of this register are res0. If the EOImode bit for\n                     the current Exception level and Security state is 0, a\n                     write to this register drops the priority for the\n                     interrupt, and also deactivates the interrupt. If the\n                     EOImode bit for the current Exception level and Security\n                     state is 1, a write to this register only drops the\n                     priority for the interrupt. Software must write to ICC_DIR\n                     to deactivate the interrupt. The appropriate EOImode bit\n                     varies as follows:\n                       - If EL3 is not implemented, the appropriate bit is\n                     ICC_CTLR.EOImode.\n                       - If EL3 is implemented and the software is executing in\n                     Monitor mode, the appropriate bit is ICC_MCTLR.EOImode_EL3.\n                       - If EL3 is implemented and the software is not executing\n                     in Monitor mode, the bit depends on the current Security\n                     state:\n                         - If the software is executing in Secure state, the bit\n                     is ICC_CTLR.EOImode in the Secure instance of ICC_CTLR.\n                     This is an alias of ICC_MCTLR.EOImode_EL1S.\n                         - If the software is executing in Non-secure state, the\n                     bit is ICC_CTLR.EOImode in the Non-secure instance of\n                     ICC_CTLR. This is an alias of ICC_MCTLR.EOImode_EL1NS."
      },
      "ICC_HPPIR0": {
        "long_name": "Interrupt Controller Highest Priority Pending Interrupt Register 0",
        "purpose": "Indicates the highest priority pending Group 0 interrupt on the CPU interface.\n\nINTID, bits [0:23] - The INTID of the highest priority pending interrupt, if\n                     that interrupt is observable at the current Security state\n                     and Exception level. If the highest priority pending\n                     interrupt is not observable, this field contains a special\n                     INTID to indicate the reason. These special INTIDs can be\n                     one of: 1020, 1021, or 1023. See Special INTIDs, for more\n                     information. This field has either 16 or 24 bits\n                     implemented. The number of implemented bits can be found in\n                     ICC_CTLR.IDbits and ICC_MCTLR.IDbits. If only 16 bits are\n                     implemented, bits [23:16] of this register are res0."
      },
      "ICC_HPPIR1": {
        "long_name": "Interrupt Controller Highest Priority Pending Interrupt Register 1",
        "purpose": "Indicates the highest priority pending Group 1 interrupt on the CPU interface.\n\nINTID, bits [0:23] - The INTID of the highest priority pending interrupt, if\n                     that interrupt is observable at the current Security state\n                     and Exception level. If the highest priority pending\n                     interrupt is not observable, this field contains a special\n                     INTID to indicate the reason. This special INTID can take\n                     the value 1023 only. See Special INTIDs, for more\n                     information. This field has either 16 or 24 bits\n                     implemented. The number of implemented bits can be found in\n                     ICC_CTLR.IDbits and ICC_MCTLR.IDbits. If only 16 bits are\n                     implemented, bits [23:16] of this register are res0."
      },
      "ICC_HSRE": {
        "long_name": "Interrupt Controller Hyp System Register Enable register",
        "purpose": "Controls whether the System register interface or the memory-mapped interface to\nthe GIC CPU interface is used for EL2.\n\nEnable, bit [3] - Enable. Enables lower Exception level access to ICC_SRE.\n                      0b0 Non-secure EL1 accesses to ICC_SRE trap to EL2.\n                      0b1 Non-secure EL1 accesses to ICC_SRE do not trap to EL2.\nDIB, bit [2]    - Disable IRQ bypass.\n                      0b0 IRQ bypass enabled.\n                      0b1 IRQ bypass disabled.\nDFB, bit [1]    - Disable FIQ bypass.\n                      0b0 FIQ bypass enabled.\n                      0b1 FIQ bypass disabled.\nSRE, bit [0]    - System Register Enable.\n                      0b0 The memory-mapped interface must be used. Accesses at\n                  EL2 or below to any ICH_* System register, or any EL1 or EL2\n                  ICC_* register other than ICC_SRE or ICC_HSRE, are undefined.\n                      0b1 The System register interface to the ICH_* registers\n                  and the EL1 and EL2 ICC_* registers is enabled for EL2."
      },
      "ICC_IAR0": {
        "long_name": "Interrupt Controller Interrupt Acknowledge Register 0",
        "purpose": "The PE reads this register to obtain the INTID of the signaled Group 0\ninterrupt. This read acts as an acknowledge for the interrupt.\n\nINTID, bits [0:23] - The INTID of the signaled interrupt. This is the INTID of\n                     the highest priority pending interrupt, if that interrupt\n                     is of sufficient priority for it to be signaled to the PE,\n                     and if it can be acknowledged at the current Security state\n                     and Exception level. If the highest priority pending\n                     interrupt is not observable, this field contains a special\n                     INTID to indicate the reason. These special INTIDs can be\n                     one of: 1020, 1021, or 1023. See Special INTIDs, for more\n                     information. This field has either 16 or 24 bits\n                     implemented. The number of implemented bits can be found in\n                     ICC_CTLR.IDbits and ICC_MCTLR.IDbits. If only 16 bits are\n                     implemented, bits [23:16] of this register are res0."
      },
      "ICC_IAR1": {
        "long_name": "Interrupt Controller Interrupt Acknowledge Register 1",
        "purpose": "The PE reads this register to obtain the INTID of the signaled Group 1\ninterrupt. This read acts as an acknowledge for the interrupt.\n\nINTID, bits [0:23] - The INTID of the signaled interrupt. This is the INTID of\n                     the highest priority pending interrupt, if that interrupt\n                     is of sufficient priority for it to be signaled to the PE,\n                     and if it can be acknowledged at the current Security state\n                     and Exception level. If the highest priority pending\n                     interrupt is not observable, this field contains a special\n                     INTID to indicate the reason. This special INTID can take\n                     the value 1023 only. See Special INTIDs, for more\n                     information. This field has either 16 or 24 bits\n                     implemented. The number of implemented bits can be found in\n                     ICC_CTLR.IDbits and ICC_MCTLR.IDbits. If only 16 bits are\n                     implemented, bits [23:16] of this register are res0."
      },
      "ICC_IGRPEN0": {
        "long_name": "Interrupt Controller Interrupt Group 0 Enable register",
        "purpose": "Controls whether Group 0 interrupts are enabled or not.\n\nEnable, bit [0] - Enables Group 0 interrupts.\n                      0b0 Group 0 interrupts are disabled.\n                      0b1 Group 0 interrupts are enabled.\n                  Virtual accesses to this register update ICH_VMCR.VENG0."
      },
      "ICC_IGRPEN1": {
        "long_name": "Interrupt Controller Interrupt Group 1 Enable register",
        "purpose": "Controls whether Group 1 interrupts are enabled for the current Security state.\n\nEnable, bit [0] - Enables Group 1 interrupts for the current Security state.\n                      0b0 Group 1 interrupts are disabled for the current\n                  Security state.\n                      0b1 Group 1 interrupts are enabled for the current\n                  Security state.\n                  Virtual accesses to this register update ICH_VMCR.VENG1. If\n                  EL3 is present:\n                    - This bit is a read/write alias of\n                  ICC_MGRPEN1.EnableGrp1{S, NS} as appropriate if EL3 is using\n                  AArch32, or ICC_IGRPEN1_EL3.EnableGrp1{S, NS} as appropriate\n                  if EL3 is using AArch64.\n                    - When this register is accessed at EL3, the copy of this\n                  register appropriate to the current setting of SCR.NS is\n                  accessed."
      },
      "ICC_MCTLR": {
        "long_name": "Interrupt Controller Monitor Control Register",
        "purpose": "Controls aspects of the behavior of the GIC CPU interface and provides\ninformation about the features implemented.\n\nExtRange, bit [19]     - Extended INTID range (read-only).\nRSS, bit [18]          - Range Selector Support.\nnDS, bit [17]          - Disable Security not supported.\nA3V, bit [15]          - Affinity 3 Valid.\nSEIS, bit [14]         - SEI Support.\nIDbits, bits [11:13]   - Identifier bits.\nPRIbits, bits [8:10]   - Priority bits.\nPMHE, bit [6]          - Priority Mask Hint Enable.\nRM, bit [5]            - SBZ.\nEOImode_EL1NS, bit [4] - EOI mode for interrupts handled at Non-secure EL1 and\n                         EL2.\nEOImode_EL1S, bit [3]  - EOI mode for interrupts handled at Secure EL1.\nEOImode_EL3, bit [2]   - EOI mode for interrupts handled at EL3.\nCBPR_EL1NS, bit [1]    - Common Binary Point Register, EL1 Non-secure.\nCBPR_EL1S, bit [0]     - Common Binary Point Register, EL1 Secure."
      },
      "ICC_MGRPEN1": {
        "long_name": "Interrupt Controller Monitor Interrupt Group 1 Enable register",
        "purpose": "Controls whether Group 1 interrupts are enabled or not.\n\nEnableGrp1S, bit [1]  - Enables Group 1 interrupts for the Secure state.\n                            0b0 Secure Group 1 interrupts are disabled.\n                            0b1 Secure Group 1 interrupts are enabled.\n                        The Secure ICC_IGRPEN1.Enable bit is a read/write alias\n                        of the ICC_MGRPEN1.EnableGrp1S bit. If the highest\n                        priority pending interrupt for that PE is a Group 1\n                        interrupt using 1 of N model, then the interrupt will\n                        target another PE as a result of the Enable bit changing\n                        from 1 to 0.\nEnableGrp1NS, bit [0] - Enables Group 1 interrupts for the Non-secure state.\n                            0b0 Non-secure Group 1 interrupts are disabled.\n                            0b1 Non-secure Group 1 interrupts are enabled.\n                        The Non-secure ICC_IGRPEN1.Enable bit is a read/write\n                        alias of the ICC_MGRPEN1.EnableGrp1NS bit. If the\n                        highest priority pending interrupt for that PE is a\n                        Group 1 interrupt using 1 of N model, then the interrupt\n                        will target another PE as a result of the Enable bit\n                        changing from 1 to 0."
      },
      "ICC_MSRE": {
        "long_name": "Interrupt Controller Monitor System Register Enable register",
        "purpose": "Controls whether the System register interface or the memory-mapped interface to\nthe GIC CPU interface is used for EL3.\n\nEnable, bit [3] - Enable. Enables lower Exception level access to ICC_SRE and\n                  ICC_HSRE.\n                      0b0 Secure EL1 accesses to Secure ICC_SRE trap to EL3. EL2\n                  accesses to Non-secure ICC_SRE and ICC_HSRE trap to EL3. Non-\n                  secure EL1 accesses to ICC_SRE trap to EL3, unless these\n                  accesses are trapped to EL2 as a result of ICC_HSRE.Enable ==\n                  0.\n                      0b1 Secure EL1 accesses to Secure ICC_SRE do not trap to\n                  EL3. EL2 accesses to Non-secure ICC_SRE and ICC_HSRE do not\n                  trap to EL3. Non-secure EL1 accesses to ICC_SRE do not trap to\n                  EL3.\nDIB, bit [2]    - Disable IRQ bypass.\n                      0b0 IRQ bypass enabled.\n                      0b1 IRQ bypass disabled.\nDFB, bit [1]    - Disable FIQ bypass.\n                      0b0 FIQ bypass enabled.\n                      0b1 FIQ bypass disabled.\nSRE, bit [0]    - System Register Enable.\n                      0b0 The memory-mapped interface must be used. Accesses at\n                  EL3 or below to any ICH_* System register, or any EL1, EL2, or\n                  EL3 ICC_* register other than ICC_SRE, ICC_HSRE, or ICC_MSRE,\n                  are undefined.\n                      0b1 The System register interface to the ICH_* registers\n                  and the EL1, EL2, and EL3 ICC_* registers is enabled for EL3."
      },
      "ICC_PMR": {
        "long_name": "Interrupt Controller Interrupt Priority Mask Register",
        "purpose": "Provides an interrupt priority filter. Only interrupts with a higher priority\nthan the value in this register are signaled to the PE.\n\nPriority, bits [0:7] - The priority mask level for the CPU interface. If the\n                       priority of an interrupt is higher than the value\n                       indicated by this field, the interface signals the\n                       interrupt to the PE. The possible priority field values\n                       are as follows: Unimplemented priority bits are RAZ/WI."
      },
      "ICC_RPR": {
        "long_name": "Interrupt Controller Running Priority Register",
        "purpose": "Indicates the Running priority of the CPU interface.\n\nPriority, bits [0:7] - The current running priority on the CPU interface. This\n                       is the group priority of the current active interrupt.\n                       The priority returned is the group priority as if the BPR\n                       for the current Exception level and Security state was\n                       set to the minimum value of BPR for the number of\n                       implemented priority bits. If 8 bits of priority are\n                       implemented the group priority is bits[7:1] of the\n                       priority."
      },
      "ICC_SGI0R": {
        "long_name": "Interrupt Controller Software Generated Interrupt Group 0 Register",
        "purpose": "Generates Secure Group 0 SGIs.\n\nAff3, bits [48:55]      - The affinity 3 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nRS, bits [44:47]        - RangeSelector Controls which group of 16 values is\n                          represented by the TargetList field.\nIRM, bit [40]           - Interrupt Routing Mode.\nAff2, bits [32:39]      - The affinity 2 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nINTID, bits [24:27]     - The INTID of the SGI.\nAff1, bits [16:23]      - The affinity 1 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nTargetList, bits [0:15] - Target List."
      },
      "ICC_SGI1R": {
        "long_name": "Interrupt Controller Software Generated Interrupt Group 1 Register",
        "purpose": "Generates Group 1 SGIs for the current Security state.\n\nAff3, bits [48:55]      - The affinity 3 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nRS, bits [44:47]        - RangeSelector Controls which group of 16 values is\n                          represented by the TargetList field.\nIRM, bit [40]           - Interrupt Routing Mode.\nAff2, bits [32:39]      - The affinity 2 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nINTID, bits [24:27]     - The INTID of the SGI.\nAff1, bits [16:23]      - The affinity 1 value of the affinity path of the\n                          cluster for which SGI interrupts will be generated.\nTargetList, bits [0:15] - Target List."
      },
      "ICC_SRE": {
        "long_name": "Interrupt Controller System Register Enable register",
        "purpose": "Controls whether the System register interface or the memory-mapped interface to\nthe GIC CPU interface is used for EL0 and EL1.\n\nDIB, bit [2] - Disable IRQ bypass.\n                   0b0 IRQ bypass enabled.\n                   0b1 IRQ bypass disabled.\nDFB, bit [1] - Disable FIQ bypass.\n                   0b0 FIQ bypass enabled.\n                   0b1 FIQ bypass disabled.\nSRE, bit [0] - System Register Enable.\n                   0b0 The memory-mapped interface must be used. Accesses at EL1\n               to any ICC_* System register other than ICC_SRE are undefined.\n                   0b1 The System register interface for the current Security\n               state is enabled."
      },
      "ICH_AP0R<n>": {
        "long_name": "Interrupt Controller Hyp Active Priorities Group 0 Registers",
        "purpose": "Provides information about Group 0 active priorities for EL2.\n\nP<x>, bits [0:31] - Provides the access to the virtual active priorities for\n                    Group 0 interrupts. Possible values of each bit are:\n                        0b0 There is no Group 0 interrupt active at the priority\n                    corresponding to that bit.\n                        0b1 There is a Group 0 interrupt active at the priority\n                    corresponding to that bit."
      },
      "ICH_AP1R<n>": {
        "long_name": "Interrupt Controller Hyp Active Priorities Group 1 Registers",
        "purpose": "Provides information about Group 1 active priorities for EL2.\n\nP<x>, bits [0:31] - Group 1 interrupt active priorities. Possible values of each\n                    bit are:\n                        0b0 There is no Group 1 interrupt active at the priority\n                    corresponding to that bit.\n                        0b1 There is a Group 1 interrupt active at the priority\n                    corresponding to that bit."
      },
      "ICH_EISR": {
        "long_name": "Interrupt Controller End of Interrupt Status Register",
        "purpose": "Indicates which List registers have outstanding EOI maintenance interrupts.\n\nStatus<n>, bits [0:15] - EOI maintenance interrupt status bit for List register\n                         <n>:\n                             0b0 List register <n>, ICH_LR<n>, does not have an\n                         EOI maintenance interrupt.\n                             0b1 List register <n>, ICH_LR<n>, has an EOI\n                         maintenance interrupt that has not been handled.\n                         For any ICH_LR<n>, the corresponding status bit is set\n                         to 1 if all of the following are true:\n                           - ICH_LRC<n>.State is 0b00.\n                           - ICH_LRC<n>.HW is 0.\n                           - ICH_LRC<n>.EOI (bit [9]) is 1, indicating that when\n                         the interrupt corresponding to that List register is\n                         deactivated, a maintenance interrupt is asserted."
      },
      "ICH_ELRSR": {
        "long_name": "Interrupt Controller Empty List Register Status Register",
        "purpose": "Indicates which List registers contain valid interrupts.\n\nStatus<n>, bits [0:15] - Status bit for List register <n>, ICH_LR<n>:\n                             0b0 List register ICH_LR<n>, if implemented,\n                         contains a valid interrupt. Using this List register\n                         can result in overwriting a valid interrupt.\n                             0b1 List register ICH_LR<n> does not contain a\n                         valid interrupt. The List register is empty and can be\n                         used without overwriting a valid interrupt or losing an\n                         EOI maintenance interrupt.\n                         For any List register <n>, the corresponding status bit\n                         is set to 1 if ICH_LRC<n>.State is 0b00 and either\n                         ICH_LRC<n>.HW is 1 or ICH_LRC<n>.EOI (bit [9]) is 0."
      },
      "ICH_HCR": {
        "long_name": "Interrupt Controller Hyp Control Register",
        "purpose": "Controls the environment for VMs.\n\nEOIcount, bits [27:31] - This field is incremented whenever a successful write\n                         to a virtual EOIR or DIR register would have resulted\n                         in a virtual interrupt deactivation.\nTDIR, bit [14]         - Trap Non-secure EL1 writes to ICC_DIR and ICV_DIR.\nTSEI, bit [13]         - Trap all locally generated SEIs.\nTALL1, bit [12]        - Trap all Non-secure EL1 accesses to ICC_* and ICV_*\n                         System registers for Group 1 interrupts to EL2.\nTALL0, bit [11]        - Trap all Non-secure EL1 accesses to ICC_* and ICV_*\n                         System registers for Group 0 interrupts to EL2.\nTC, bit [10]           - Trap all Non-secure EL1 accesses to System registers\n                         that are common to Group 0 and Group 1 to EL2.\nVGrp1DIE, bit [7]      - VM Group 1 Disabled Interrupt Enable.\nVGrp1EIE, bit [6]      - VM Group 1 Enabled Interrupt Enable.\nVGrp0DIE, bit [5]      - VM Group 0 Disabled Interrupt Enable.\nVGrp0EIE, bit [4]      - VM Group 0 Enabled Interrupt Enable.\nNPIE, bit [3]          - No Pending Interrupt Enable.\nLRENPIE, bit [2]       - List Register Entry Not Present Interrupt Enable.\nUIE, bit [1]           - Underflow Interrupt Enable.\nEn, bit [0]            - Enable."
      },
      "ICH_LR<n>": {
        "long_name": "Interrupt Controller List Registers",
        "purpose": "Provides interrupt context information for the virtual CPU interface.\n\nvINTID, bits [0:31] - Virtual INTID of the interrupt. If the value of vINTID is\n                      1020-1023 and ICH_LRC<n>.State!=0b00 (Inactive), behavior\n                      is unpredictable. Behavior is unpredictable if two or more\n                      List Registers specify the same vINTID when:\n                        - ICH_LRC<n>.State == 01.\n                        - ICH_LRC<n>.State == 10.\n                        - ICH_LRC<n>.State == 11. It is implementation defined\n                      how many bits are implemented, though at least 16 bits\n                      must be implemented. Unimplemented bits are res0. The\n                      number of implemented bits can be discovered from\n                      ICH_VTR.IDbits. When a VM is using memory-mapped access to\n                      the GIC, software must ensure that the correct source PE\n                      ID is provided in bits[12:10]."
      },
      "ICH_LRC<n>": {
        "long_name": "Interrupt Controller List Registers",
        "purpose": "Provides interrupt context information for the virtual CPU interface.\n\nState, bits [30:31]    - The state of the interrupt:\nHW, bit [29]           - Indicates whether this virtual interrupt maps directly\n                         to a hardware interrupt, meaning that it corresponds to\n                         a physical interrupt.\nGroup, bit [28]        - Indicates the group for this virtual interrupt.\nPriority, bits [16:23] - The priority of this interrupt.\npINTID, bits [0:12]    - Physical INTID, for hardware interrupts."
      },
      "ICH_MISR": {
        "long_name": "Interrupt Controller Maintenance Interrupt State Register",
        "purpose": "Indicates which maintenance interrupts are asserted.\n\nVGrp1D, bit [7] - vPE Group 1 Disabled.\nVGrp1E, bit [6] - vPE Group 1 Enabled.\nVGrp0D, bit [5] - vPE Group 0 Disabled.\nVGrp0E, bit [4] - vPE Group 0 Enabled.\nNP, bit [3]     - No Pending.\nLRENP, bit [2]  - List Register Entry Not Present.\nU, bit [1]      - Underflow.\nEOI, bit [0]    - End Of Interrupt."
      },
      "ICH_VMCR": {
        "long_name": "Interrupt Controller Virtual Machine Control Register",
        "purpose": "Enables the hypervisor to save and restore the virtual machine view of the GIC\nstate.\n\nVPMR, bits [24:31]  - Virtual Priority Mask. The priority mask level for the\n                      virtual CPU interface. If the priority of a pending\n                      virtual interrupt is higher than the value indicated by\n                      this field, the interface signals the virtual interrupt to\n                      the PE. This field is an alias of ICV_PMR.Priority.\nVBPR0, bits [21:23] - Virtual Binary Point Register, Group 0. Defines the point\n                      at which the priority value fields split into two parts,\n                      the group priority field and the subpriority field. The\n                      group priority field determines Group 0 interrupt\n                      preemption, and also determines Group 1 interrupt\n                      preemption if ICH_VMCR.VCBPR == 1. This field is an alias\n                      of ICV_BPR0.BinaryPoint.\nVBPR1, bits [18:20] - Virtual Binary Point Register, Group 1. Defines the point\n                      at which the priority value fields split into two parts,\n                      the group priority field and the subpriority field. The\n                      group priority field determines Group 1 interrupt\n                      preemption if ICH_VMCR.VCBPR == 0. This field is an alias\n                      of ICV_BPR1.BinaryPoint.\nVEOIM, bit [9]      - Virtual EOI mode.\nVCBPR, bit [4]      - Virtual Common Binary Point Register.\nVFIQEn, bit [3]     - Virtual FIQ enable.\nVAckCtl, bit [2]    - Virtual AckCtl.\nVENG1, bit [1]      - Virtual Group 1 interrupt enable.\nVENG0, bit [0]      - Virtual Group 0 interrupt enable."
      },
      "ICH_VTR": {
        "long_name": "Interrupt Controller VGIC Type Register",
        "purpose": "Reports supported GIC virtualisartion features.\n\nPRIbits, bits [29:31] - Priority bits. The number of virtual priority bits\n                        implemented, minus one. An implementation must implement\n                        at least 32 levels of virtual priority (5 priority\n                        bits). This field is an alias of ICV_CTLR.PRIbits.\nPREbits, bits [26:28] - The number of virtual preemption bits implemented, minus\n                        one. An implementation must implement at least 32 levels\n                        of virtual preemption priority (5 preemption bits). The\n                        value of this field must be less than or equal to the\n                        value of ICH_VTR.PRIbits.\nIDbits, bits [23:25]  - The number of virtual interrupt identifier bits\n                        supported:\nSEIS, bit [22]        - SEI Support.\nA3V, bit [21]         - Affinity 3 Valid.\nnV4, bit [20]         - Direct injection of virtual interrupts not supported.\nTDS, bit [19]         - Separate trapping of Non-secure EL1 writes to ICV_DIR\n                        supported.\nListRegs, bits [0:4]  - The number of implemented List registers, minus one. For\n                        example, a value of 0b01111 indicates that the maximum\n                        of 16 List registers are implemented."
      },
      "ICV_AP0R<n>": {
        "long_name": "Interrupt Controller Virtual Active Priorities Group 0 Registers",
        "purpose": "Provides information about virtual Group 0 active priorities."
      },
      "ICV_AP1R<n>": {
        "long_name": "Interrupt Controller Virtual Active Priorities Group 1 Registers",
        "purpose": "Provides information about virtual Group 1 active priorities."
      },
      "ICV_BPR0": {
        "long_name": "Interrupt Controller Virtual Binary Point Register 0",
        "purpose": "Defines the point at which the priority value fields split into two parts, the\ngroup priority field and the subpriority field. The group priority field\ndetermines virtual Group 0 interrupt preemption.\n\nBinaryPoint, bits [0:2] - The value of this field controls how the 8-bit\n                          interrupt priority field is split into a group\n                          priority field, that determines interrupt preemption,\n                          and a subpriority field. This is done as follows:"
      },
      "ICV_BPR1": {
        "long_name": "Interrupt Controller Virtual Binary Point Register 1",
        "purpose": "Defines the point at which the priority value fields split into two parts, the\ngroup priority field and the subpriority field. The group priority field\ndetermines virtual Group 1 interrupt preemption.\n\nBinaryPoint, bits [0:2] - If the GIC is configured to use separate binary point\n                          fields for virtual Group 0 and virtual Group 1\n                          interrupts, the value of this field controls how the\n                          8-bit interrupt priority field is split into a group\n                          priority field, that determines interrupt preemption,\n                          and a subpriority field. This is done as follows:\n                          Writing 0 to this field will set this field to its\n                          reset value. If ICV_CTLR.CBPR is set to 1, Non-secure\n                          EL1 reads return ICV_BPR0 + 1 saturated to 0b111. Non-\n                          secure EL1 writes are ignored."
      },
      "ICV_CTLR": {
        "long_name": "Interrupt Controller Virtual Control Register",
        "purpose": "Controls aspects of the behavior of the GIC virtual CPU interface and provides\ninformation about the features implemented.\n\nRSS, bit [18]        - Range Selector Support.\nA3V, bit [15]        - Affinity 3 Valid. Read-only and writes are ignored.\nSEIS, bit [14]       - SEI Support. Read-only and writes are ignored.\nIDbits, bits [11:13] - Identifier bits. Read-only and writes are ignored.\nPRIbits, bits [8:10] - Priority bits. Read-only and writes are ignored. The\n                       number of priority bits implemented, minus one. An\n                       implementation must implement at least 32 levels of\n                       physical priority (5 priority bits). This field always\n                       returns the number of priority bits implemented. The\n                       division between group priority and subpriority is\n                       defined in the binary point registers ICV_BPR0 and\n                       ICV_BPR1.\nEOImode, bit [1]     - Virtual EOI mode.\nCBPR, bit [0]        - Common Binary Point Register."
      },
      "ICV_DIR": {
        "long_name": "Interrupt Controller Deactivate Virtual Interrupt Register",
        "purpose": "When interrupt priority drop is separated from interrupt deactivation, a write\nto this register deactivates the specified virtual interrupt.\n\nINTID, bits [0:23] - The INTID of the virtual interrupt to be deactivated. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR.IDbits. If only\n                     16 bits are implemented, bits [23:16] of this register are\n                     res0."
      },
      "ICV_EOIR0": {
        "long_name": "Interrupt Controller Virtual End Of Interrupt Register 0",
        "purpose": "A PE writes to this register to inform the CPU interface that it has completed\nthe processing of the specified virtual Group 0 interrupt.\n\nINTID, bits [0:23] - The INTID from the corresponding ICV_IAR0 access. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR.IDbits. If only\n                     16 bits are implemented, bits [23:16] of this register are\n                     res0. If the ICV_CTLR.EOImode bit is 0, a write to this\n                     register drops the priority for the virtual interrupt, and\n                     also deactivates the virtual interrupt. If the\n                     ICV_CTLR.EOImode bit is 1, a write to this register only\n                     drops the priority for the virtual interrupt. Software must\n                     write to ICV_DIR to deactivate the virtual interrupt."
      },
      "ICV_EOIR1": {
        "long_name": "Interrupt Controller Virtual End Of Interrupt Register 1",
        "purpose": "A PE writes to this register to inform the CPU interface that it has completed\nthe processing of the specified virtual Group 1 interrupt.\n\nINTID, bits [0:23] - The INTID from the corresponding ICV_IAR1 access. This\n                     field has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR.IDbits. If only\n                     16 bits are implemented, bits [23:16] of this register are\n                     res0. If the ICV_CTLR.EOImode bit is 0, a write to this\n                     register drops the priority for the virtual interrupt, and\n                     also deactivates the virtual interrupt. If the\n                     ICV_CTLR.EOImode bit is 1, a write to this register only\n                     drops the priority for the virtual interrupt. Software must\n                     write to ICV_DIR to deactivate the virtual interrupt."
      },
      "ICV_HPPIR0": {
        "long_name": "Interrupt Controller Virtual Highest Priority Pending Interrupt Register 0",
        "purpose": "Indicates the highest priority pending virtual Group 0 interrupt on the virtual\nCPU interface.\n\nINTID, bits [0:23] - The INTID of the highest priority pending virtual\n                     interrupt. If the highest priority pending interrupt is not\n                     observable, this field contains a special INTID to indicate\n                     the reason. This special INTID can take the value 1023\n                     only. See Special INTIDs, for more information. This field\n                     has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR.IDbits. If only\n                     16 bits are implemented, bits [23:16] of this register are\n                     res0."
      },
      "ICV_HPPIR1": {
        "long_name": "Interrupt Controller Virtual Highest Priority Pending Interrupt Register 1",
        "purpose": "Indicates the highest priority pending virtual Group 1 interrupt on the virtual\nCPU interface.\n\nINTID, bits [0:23] - The INTID of the highest priority pending virtual\n                     interrupt. If the highest priority pending interrupt is not\n                     observable, this field contains a special INTID to indicate\n                     the reason. This special INTID can take the value 1023\n                     only. See Special INTIDs, for more information. This field\n                     has either 16 or 24 bits implemented. The number of\n                     implemented bits can be found in ICV_CTLR.IDbits. If only\n                     16 bits are implemented, bits [23:16] of this register are\n                     res0."
      },
      "ICV_IAR0": {
        "long_name": "Interrupt Controller Virtual Interrupt Acknowledge Register 0",
        "purpose": "The PE reads this register to obtain the INTID of the signaled virtual Group 0\ninterrupt. This read acts as an acknowledge for the interrupt.\n\nINTID, bits [0:23] - The INTID of the signaled virtual interrupt. This is the\n                     INTID of the highest priority pending virtual interrupt, if\n                     that interrupt is of sufficient priority for it to be\n                     signaled to the PE, and if it can be acknowledged. If the\n                     highest priority pending interrupt is not observable, this\n                     field contains a special INTID to indicate the reason. This\n                     special INTID can take the value 1023 only. See Special\n                     INTIDs, for more information. This field has either 16 or\n                     24 bits implemented. The number of implemented bits can be\n                     found in ICV_CTLR.IDbits. If only 16 bits are implemented,\n                     bits [23:16] of this register are res0."
      },
      "ICV_IAR1": {
        "long_name": "Interrupt Controller Virtual Interrupt Acknowledge Register 1",
        "purpose": "The PE reads this register to obtain the INTID of the signaled virtual Group 1\ninterrupt. This read acts as an acknowledge for the interrupt.\n\nINTID, bits [0:23] - The INTID of the signaled virtual interrupt. This is the\n                     INTID of the highest priority pending virtual interrupt, if\n                     that interrupt is of sufficient priority for it to be\n                     signaled to the PE, and if it can be acknowledged. If the\n                     highest priority pending interrupt is not observable, this\n                     field contains a special INTID to indicate the reason. This\n                     special INTID can take the value 1023 only. See Special\n                     INTIDs, for more information. This field has either 16 or\n                     24 bits implemented. The number of implemented bits can be\n                     found in ICV_CTLR.IDbits. If only 16 bits are implemented,\n                     bits [23:16] of this register are res0."
      },
      "ICV_IGRPEN0": {
        "long_name": "Interrupt Controller Virtual Interrupt Group 0 Enable register",
        "purpose": "Controls whether virtual Group 0 interrupts are enabled or not.\n\nEnable, bit [0] - Enables virtual Group 0 interrupts.\n                      0b0 Virtual Group 0 interrupts are disabled.\n                      0b1 Virtual Group 0 interrupts are enabled."
      },
      "ICV_IGRPEN1": {
        "long_name": "Interrupt Controller Virtual Interrupt Group 1 Enable register",
        "purpose": "Controls whether virtual Group 1 interrupts are enabled for the current Security\nstate.\n\nEnable, bit [0] - Enables virtual Group 1 interrupts.\n                      0b0 Virtual Group 1 interrupts are disabled.\n                      0b1 Virtual Group 1 interrupts are enabled."
      },
      "ICV_PMR": {
        "long_name": "Interrupt Controller Virtual Interrupt Priority Mask Register",
        "purpose": "Provides a virtual interrupt priority filter. Only virtual interrupts with a\nhigher priority than the value in this register are signaled to the PE.\n\nPriority, bits [0:7] - The priority mask level for the virtual CPU interface. If\n                       the priority of a virtual interrupt is higher than the\n                       value indicated by this field, the interface signals the\n                       virtual interrupt to the PE. The possible priority field\n                       values are as follows: Unimplemented priority bits are\n                       RAZ/WI."
      },
      "ICV_RPR": {
        "long_name": "Interrupt Controller Virtual Running Priority Register",
        "purpose": "Indicates the Running priority of the virtual CPU interface.\n\nPriority, bits [0:7] - The current running priority on the virtual CPU\n                       interface. This is the group priority of the current\n                       active virtual interrupt. The priority returned is the\n                       group priority as if the BPR for the current Exception\n                       level and Security state was set to the minimum value of\n                       BPR for the number of implemented priority bits. If 8\n                       bits of priority are implemented the group priority is\n                       bits[7:1] of the priority."
      },
      "ID_AFR0": {
        "long_name": "Auxiliary Feature Register 0",
        "purpose": "Provides information about the implementation defined features of the PE in\nAArch32 state.\n\nMust be interpreted with the Main ID Register, MIDR.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3."
      },
      "ID_DFR0": {
        "long_name": "Debug Feature Register 0",
        "purpose": "Provides top level information about the debug system in AArch32 state.\n\nMust be interpreted with the Main ID Register, MIDR.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nTraceFilt, bits [28:31] - ARMv8.4 Self-hosted Trace Extension version.\nPerfMon, bits [24:27]   - Performance Monitors Extension version.\nMProfDbg, bits [20:23]  - M Profile Debug.\nMMapTrc, bits [16:19]   - Memory Mapped Trace.\nCopTrc, bits [12:15]    - Support for System registers-based trace model, using\n                          registers in the coproc == 0b1110 encoding space.\nMMapDbg, bits [8:11]    - Memory Mapped Debug.\nCopSDbg, bits [4:7]     - Support for  a System registers-based Secure debug\n                          model, using registers in the coproc = 0b1110 encoding\n                          space, for an A profile processor that includes EL3.\nCopDbg, bits [0:3]      - Support for System registers-based debug model, using\n                          registers in the coproc == 0b1110 encoding space, for\n                          A and R profile processors."
      },
      "ID_ISAR0": {
        "long_name": "Instruction Set Attribute Register 0",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR1, ID_ISAR2, ID_ISAR3, ID_ISAR4, and ID_ISAR5.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nDivide, bits [24:27]    - Indicates the implemented Divide instructions.\nDebug, bits [20:23]     - Indicates the implemented Debug instructions.\nCoproc, bits [16:19]    - Indicates the implemented System register access\n                          instructions.\nCmpBranch, bits [12:15] - Indicates the implemented combined Compare and Branch\n                          instructions in the T32 instruction set.\nBitField, bits [8:11]   - Indicates the implemented BitField instructions.\nBitCount, bits [4:7]    - Indicates the implemented Bit Counting instructions.\nSwap, bits [0:3]        - Indicates the implemented Swap instructions in the A32\n                          instruction set."
      },
      "ID_ISAR1": {
        "long_name": "Instruction Set Attribute Register 1",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0, ID_ISAR2, ID_ISAR3, ID_ISAR4, and ID_ISAR5.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nJazelle, bits [28:31]   - Indicates the implemented Jazelle extension\n                          instructions.\nInterwork, bits [24:27] - Indicates the implemented Interworking instructions.\nImmediate, bits [20:23] - Indicates the implemented data-processing instructions\n                          with long immediates.\nIfThen, bits [16:19]    - Indicates the implemented If-Then instructions in the\n                          T32 instruction set.\nExtend, bits [12:15]    - Indicates the implemented Extend instructions.\nExcept_AR, bits [8:11]  - Indicates the implemented A and R profile exception-\n                          handling instructions.\nExcept, bits [4:7]      - Indicates the implemented exception-handling\n                          instructions in the A32 instruction set.\nEndian, bits [0:3]      - Indicates the implemented Endian instructions."
      },
      "ID_ISAR2": {
        "long_name": "Instruction Set Attribute Register 2",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0, ID_ISAR1, ID_ISAR3, ID_ISAR4, and ID_ISAR5.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nReversal, bits [28:31]      - Indicates the implemented Reversal instructions.\nPSR_AR, bits [24:27]        - Indicates the implemented A and R profile\n                              instructions to manipulate the PSR.\nMultU, bits [20:23]         - Indicates the implemented advanced unsigned\n                              Multiply instructions.\nMultS, bits [16:19]         - Indicates the implemented advanced signed Multiply\n                              instructions.\nMult, bits [12:15]          - Indicates the implemented additional Multiply\n                              instructions.\nMultiAccessInt, bits [8:11] - Indicates the support for interruptible multi-\n                              access instructions.\nMemHint, bits [4:7]         - Indicates the implemented Memory Hint\n                              instructions.\nLoadStore, bits [0:3]       - Indicates the implemented additional load/store\n                              instructions."
      },
      "ID_ISAR3": {
        "long_name": "Instruction Set Attribute Register 3",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0, ID_ISAR1, ID_ISAR2, ID_ISAR4, and ID_ISAR5. \n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nT32EE, bits [28:31]     - Indicates the implemented T32EE instructions.\nTrueNOP, bits [24:27]   - Indicates the implemented true NOP instructions.\nT32Copy, bits [20:23]   - Indicates the support for T32 non flag-setting MOV\n                          instructions.\nTabBranch, bits [16:19] - Indicates the implemented Table Branch instructions in\n                          the T32 instruction set.\nSynchPrim, bits [12:15] - Used in conjunction with ID_ISAR4.SynchPrim_frac to\n                          indicate the implemented Synchronization Primitive\n                          instructions.\nSVC, bits [8:11]        - Indicates the implemented SVC instructions.\nSIMD, bits [4:7]        - Indicates the implemented SIMD instructions.\nSaturate, bits [0:3]    - Indicates the implemented Saturate instructions."
      },
      "ID_ISAR4": {
        "long_name": "Instruction Set Attribute Register 4",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0, ID_ISAR1, ID_ISAR2, ID_ISAR3, and ID_ISAR5.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nSWP_frac, bits [28:31]       - Indicates support for the memory system locking\n                               the bus for SWP or SWPB instructions.\nPSR_M, bits [24:27]          - Indicates the implemented M profile instructions\n                               to modify the PSRs.\nSynchPrim_frac, bits [20:23] - Used in conjunction with ID_ISAR3.SynchPrim to\n                               indicate the implemented Synchronization\n                               Primitive instructions.\nBarrier, bits [16:19]        - Indicates the implemented Barrier instructions in\n                               the A32 and T32 instruction sets.\nSMC, bits [12:15]            - Indicates the implemented SMC instructions.\nWriteback, bits [8:11]       - Indicates the support for Writeback addressing\n                               modes.\nWithShifts, bits [4:7]       - Indicates the support for instructions with\n                               shifts.\nUnpriv, bits [0:3]           - Indicates the implemented unprivileged\n                               instructions."
      },
      "ID_ISAR5": {
        "long_name": "Instruction Set Attribute Register 5",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0, ID_ISAR1, ID_ISAR2, ID_ISAR3, and ID_ISAR4.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nVCMA, bits [28:31]  - Indicates AArch32 support for complex number addition and\n                      multiplication where numbers are stored in vectors.\nRDM, bits [24:27]   - Indicates whether the VQRDMLAH and VQRDMLSH instructions\n                      are implemented in AArch32 state.\nCRC32, bits [16:19] - Indicates whether the CRC32 instructions are implemented\n                      in AArch32 state.\nSHA2, bits [12:15]  - Indicates whether the SHA2 instructions are implemented in\n                      AArch32 state.\nSHA1, bits [8:11]   - Indicates whether the SHA1 instructions are implemented in\n                      AArch32 state.\nAES, bits [4:7]     - Indicates whether the AES instructions are implemented in\n                      AArch32 state.\nSEVL, bits [0:3]    - Indicates whether the SEVL instruction is implemented in\n                      AArch32 state."
      },
      "ID_ISAR6": {
        "long_name": "Instruction Set Attribute Register 6",
        "purpose": "Provides information about the instruction sets implemented by the PE in AArch32\nstate.\n\nMust be interpreted with ID_ISAR0, ID_ISAR1, ID_ISAR2, ID_ISAR3, ID_ISAR4 and\nID_ISAR5.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nSPECRES, bits [16:19] - Speculation invalidation instruction support in AArch32\n                        state.\nSB, bits [12:15]      - SB instruction support in AArch32 state.\nFHM, bits [8:11]      - Indicates whether VFMAL and VFMSL instructions are\n                        implemented.\nDP, bits [4:7]        - Indicates the support for dot product instructions in\n                        AArch32 state.\nJSCVT, bits [0:3]     - Indicates whether the Javascript conversion instruction\n                        is implemented in AArch32 state."
      },
      "ID_MMFR0": {
        "long_name": "Memory Model Feature Register 0",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR1, ID_MMFR2, ID_MMFR3, and ID_MMFR4.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nInnerShr, bits [28:31] - Innermost Shareability. Indicates the innermost\n                         shareability domain implemented.\nFCSE, bits [24:27]     - Indicates whether the implementation includes the FCSE.\nAuxReg, bits [20:23]   - Auxiliary Registers. Indicates support for Auxiliary\n                         registers.\nTCM, bits [16:19]      - Indicates support for TCMs and associated DMAs.\nShareLvl, bits [12:15] - Shareability Levels. Indicates the number of\n                         shareability levels implemented.\nOuterShr, bits [8:11]  - Outermost Shareability. Indicates the outermost\n                         shareability domain implemented.\nPMSA, bits [4:7]       - Indicates support for a PMSA.\nVMSA, bits [0:3]       - Indicates support for a VMSA."
      },
      "ID_MMFR1": {
        "long_name": "Memory Model Feature Register 1",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR0, ID_MMFR2, ID_MMFR3, and ID_MMFR4.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nBPred, bits [28:31]    - Branch Predictor.\nL1TstCln, bits [24:27] - Level 1 cache Test and Clean.\nL1Uni, bits [20:23]    - Level 1 Unified cache.\nL1Hvd, bits [16:19]    - Level 1 Harvard cache.\nL1UniSW, bits [12:15]  - Level 1 Unified cache by Set/Way.\nL1HvdSW, bits [8:11]   - Level 1 Harvard cache by Set/Way.\nL1UniVA, bits [4:7]    - Level 1 Unified cache by Virtual Address.\nL1HvdVA, bits [0:3]    - Level 1 Harvard cache by Virtual Address."
      },
      "ID_MMFR2": {
        "long_name": "Memory Model Feature Register 2",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR0, ID_MMFR1, ID_MMFR3, and ID_MMFR4.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nHWAccFlg, bits [28:31] - Hardware Access Flag.\nWFIStall, bits [24:27] - Wait For Interrupt Stall.\nMemBarr, bits [20:23]  - Memory Barrier.\nUniTLB, bits [16:19]   - Unified TLB.\nHvdTLB, bits [12:15]   - If the Unified TLB field (UniTLB, bits [19:16]) is not\n                         0000, then the meaning of this field is implementation\n                         defined.\nL1HvdRng, bits [8:11]  - Level 1 Harvard cache Range.\nL1HvdBG, bits [4:7]    - Level 1 Harvard cache Background fetch.\nL1HvdFG, bits [0:3]    - Level 1 Harvard cache Foreground fetch."
      },
      "ID_MMFR3": {
        "long_name": "Memory Model Feature Register 3",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR0, ID_MMFR1, ID_MMFR2, and ID_MMFR4.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nSupersec, bits [28:31]  - Supersections. On a VMSA implementation, indicates\n                          whether Supersections are supported.\nCMemSz, bits [24:27]    - Cached Memory Size. Indicates the physical memory size\n                          supported by the caches.\nCohWalk, bits [20:23]   - Coherent Walk. Indicates whether Translation table\n                          updates require a clean to the Point of Unification.\nPAN, bits [16:19]       - Privileged Access Never. Indicates support for the PAN\n                          bit in CPSR, SPSR, and DSPSR in AArch32 state.\nMaintBcst, bits [12:15] - Maintenance Broadcast. Indicates whether Cache, TLB,\n                          and branch predictor operations are broadcast.\nBPMaint, bits [8:11]    - Branch Predictor Maintenance. Indicates the supported\n                          branch predictor maintenance operations in an\n                          implementation with hierarchical cache maintenance\n                          operations.\nCMaintSW, bits [4:7]    - Cache Maintenance by Set/Way. Indicates the supported\n                          cache maintenance operations by set/way, in an\n                          implementation with hierarchical caches.\nCMaintVA, bits [0:3]    - Cache Maintenance by  Virtual Address. Indicates the\n                          supported cache maintenance operations by VA, in an\n                          implementation with hierarchical caches."
      },
      "ID_MMFR4": {
        "long_name": "Memory Model Feature Register 4",
        "purpose": "Provides information about the implemented memory model and memory management\nsupport in AArch32 state.\n\nMust be interpreted with ID_MMFR0, ID_MMFR1, ID_MMFR2, and ID_MMFR3.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nEVT, bits [28:31]   - If EL2 is implemented, indicates support for the TICAB,\n                      TOCU and TID4 traps.\nCCIDX, bits [24:27] - Support for use of the revised CCSIDR format and the\n                      presence of the CCSIDR2 is indicated.\nLSM, bits [20:23]   - Indicates support for LSMAOE and nTLSMD bits in HSCTLR and\n                      SCTLR.\nHPDS, bits [16:19]  - Hierarchical permission disables bits in translation\n                      tables.\nCnP, bits [12:15]   - Common not Private translations.\nXNX, bits [8:11]    - Support for execute-never control distinction by Exception\n                      level at stage 2.\nAC2, bits [4:7]     - Indicates the extension of the ACTLR and HACTLR registers\n                      using ACTLR2 and HACTLR2.\nSpecSEI, bits [0:3] - Describes whether the PE can generate SError interrupt\n                      exceptions from speculative reads of memory, including\n                      speculative instruction fetches."
      },
      "ID_PFR0": {
        "long_name": "Processor Feature Register 0",
        "purpose": "Gives top-level information about the instruction sets and other features\nsupported by the PE in AArch32 state.\n\nMust be interpreted with ID_PFR1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nRAS, bits [28:31]    - RAS Extension version.\nDIT, bits [24:27]    - Data Independent Timing.\nAMU, bits [20:23]    - Activity Monitors Extension.\nCSV2, bits [16:19]   - Speculative use of out of context branch targets.\nState3, bits [12:15] - T32EE instruction set support.\nState2, bits [8:11]  - Jazelle extension support.\nState1, bits [4:7]   - T32 instruction set support.\nState0, bits [0:3]   - A32 instruction set support."
      },
      "ID_PFR1": {
        "long_name": "Processor Feature Register 1",
        "purpose": "Gives information about the AArch32 programmers' model.\n\nMust be interpreted with ID_PFR0.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nGIC, bits [28:31]            - System register GIC CPU interface.\nVirt_frac, bits [24:27]      - Virtualization fractional field. When the\n                               Virtualization field is 0b0000, determines the\n                               support for features from the ARMv7\n                               Virtualization Extensions.\nSec_frac, bits [20:23]       - Security fractional field. When the Security\n                               field is 0b0000, determines the support for\n                               features from the ARMv7 Security Extensions.\nGenTimer, bits [16:19]       - Generic Timer support.\nVirtualization, bits [12:15] - Virtualization support.\nMProgMod, bits [8:11]        - M profile programmers' model support.\nSecurity, bits [4:7]         - Security support.\nProgMod, bits [0:3]          - Support for the standard programmers' model for\n                               ARMv4 and later. Model must support User, FIQ,\n                               IRQ, Supervisor, Abort, Undefined, and System\n                               modes."
      },
      "ID_PFR2": {
        "long_name": "Processor Feature Register 2",
        "purpose": "Gives information about the AArch32 programmers' model.\n\nMust be interpreted with ID_PFR0 and ID_PFR1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nRAS_frac, bits [8:11] - RAS Extension fractional field.\nSSBS, bits [4:7]      - Speculative Store Bypassing controls in AArch64 state.\nCSV3, bits [0:3]      - Speculative use of faulting data."
      },
      "IFAR": {
        "long_name": "Instruction Fault Address Register",
        "purpose": "Holds the virtual address of the faulting address that caused a synchronous\nPrefetch Abort exception.\n\nbits [0:31] - VA of faulting address of synchronous Prefetch Abort exception."
      },
      "IFSR": {
        "long_name": "Instruction Fault Status Register",
        "purpose": "Holds status information about the last instruction fault.\n\nFnV, bit [16]  - FAR not Valid, for a synchronous External abort other than a\n                 synchronous External abort on a translation table walk.\nExT, bit [12]  - External abort type. This bit can be used to provide an\n                 implementation defined classification of External aborts. In an\n                 implementation that does not provide any classification of\n                 External aborts, this bit is res0. For aborts other than\n                 External aborts this bit always returns 0.\nFS, bit [10]   - Fault Status bits. Bits [10] and [3:0] are interpreted\n                 together.\nLPAE, bit [9]  - On taking a Data Abort exception, this bit is set as follows:\nFS, bits [0:3] - Fault Status bits. Bits [10] and [3:0] are interpreted\n                 together."
      },
      "ISR": {
        "long_name": "Interrupt Status Register",
        "purpose": "Shows the pending status of the IRQ, FIQ, or SError.\n\nWhen executing at EL2, EL3, or Secure EL1, when SCR_EL3.EEL2 == 0b0, this shows\nthe pending status of the physical interrupts.\n\nWhen executing at Non-secure EL1, or at Secure EL1, when SCR_EL3.EEL2 == 0b01:\n\n  - If the HCR.{IMO,FMO,AMO} bit has a value of 1, the corresponding ISR.{I,F,A}\nbit shows the pending status of the virtual IRQ, FIQ, or SError.\n  - If the HCR.{IMO,FMO,AMO} bit has a value of 0, the corresponding ISR.{I,F,A}\nbit shows the pending status of the physical IRQ, FIQ, or SError.\n\nA, bit [8] - SError interrupt pending bit:\n                 0b0 No pending SError interrupt.\n                 0b1 An SError interrupt is pending.\n             If the SError interrupt is edge-triggered, this field is cleared to\n             zero when the physical SError interrupt is taken.\nI, bit [7] - IRQ pending bit. Indicates whether an IRQ interrupt is pending:\n                 0b0 No pending IRQ.\n                 0b1 An IRQ interrupt is pending.\nF, bit [6] - FIQ pending bit. Indicates whether an FIQ interrupt is pending.\n                 0b0 No pending FIQ.\n                 0b1 An FIQ interrupt is pending."
      },
      "JIDR": {
        "long_name": "Jazelle ID Register",
        "purpose": "A Jazelle register, which identified the Jazelle architecture version.\n\n0, bits [0:31] - RO, RAZ at EL1, EL2, and EL3. It is implementation defined\n                 whether this field is RAZ or undefined at EL0."
      },
      "JMCR": {
        "long_name": "Jazelle Main Configuration Register",
        "purpose": "A Jazelle register, which provides control of the Jazelle extension.\n\n0, bits [0:31] - RAZ/WI at EL1, EL2, and EL3. It is implementation defined\n                 whether this field is RAZ/WI or undefined at EL0."
      },
      "JOSCR": {
        "long_name": "Jazelle OS Control Register",
        "purpose": "A Jazelle register, which provides operating system control of the Jazelle\nExtension.\n\n0, bits [0:31] - RAZ/WI at EL1, EL2, and EL3. It is implementation defined\n                 whether this field is RAZ/WI or undefined at EL0."
      },
      "MAIR0": {
        "long_name": "Memory Attribute Indirection Register 0",
        "purpose": "Along with MAIR1, provides the memory attribute encodings corresponding to the\npossible AttrIndx values in a Long-descriptor format translation table entry for\nstage 1 translations.\n\nAttrIndx[2] indicates the MAIR register to be used:\n\n  - When AttrIndx[2] is 0, MAIR0 is used.\n  - When AttrIndx[2] is 1, MAIR1 is used.\n\nAttr<n>, bits [0:31] - The memory attribute encoding for an AttrIndx[2:0] entry\n                       in a Long descriptor format translation table entry,\n                       where:\n                         - AttrIndx[2:0] gives the value of <n> in Attr<n>.\n                         - AttrIndx[2] defines which MAIR to access. Attr7 to\n                       Attr4 are in MAIR1, and Attr3 to Attr0 are in MAIR0. Bits\n                       [7:4] are encoded as follows: R = Outer Read-Allocate\n                       policy, W = Outer Write-Allocate policy. The meaning of\n                       bits [3:0] depends on the value of bits [7:4]: R = Inner\n                       Read-Allocate policy, W = Inner Write-Allocate policy.\n                       The R and W bits in some Attr<n> fields have the\n                       following meanings:"
      },
      "MAIR1": {
        "long_name": "Memory Attribute Indirection Register 1",
        "purpose": "Along with MAIR0, provides the memory attribute encodings corresponding to the\npossible AttrIndx values in a Long-descriptor format translation table entry for\nstage 1 translations.\n\nAttrIndx[2] indicates the MAIR register to be used:\n\n  - When AttrIndx[2] is 0, MAIR0 is used.\n  - When AttrIndx[2] is 1, MAIR1 is used.\n\nAttr<n>, bits [0:31] - The memory attribute encoding for an AttrIndx[2:0] entry\n                       in a Long descriptor format translation table entry,\n                       where:\n                         - AttrIndx[2:0] gives the value of <n> in Attr<n>.\n                         - AttrIndx[2] defines which MAIR to access. Attr7 to\n                       Attr4 are in MAIR1, and Attr3 to Attr0 are in MAIR0. Bits\n                       [7:4] are encoded as follows: R = Outer Read-Allocate\n                       policy, W = Outer Write-Allocate policy. The meaning of\n                       bits [3:0] depends on the value of bits [7:4]: R = Inner\n                       Read-Allocate policy, W = Inner Write-Allocate policy.\n                       The R and W bits in some Attr<n> fields have the\n                       following meanings:"
      },
      "MIDR": {
        "long_name": "Main ID Register",
        "purpose": "Provides identification information for the PE, including an implementer code\nfor the device and a device ID number.\n\nImplementer, bits [24:31]  - The Implementer code. This field must hold an\n                             implementer code that has been assigned by ARM.\n                             Assigned codes include the following: ARM can\n                             assign codes that are not published in this manual.\n                             All values not assigned by ARM are reserved and\n                             must not be used.\nVariant, bits [20:23]      - An implementation defined variant number.\n                             Typically, this field is used to distinguish\n                             between different product variants, or major\n                             revisions of a product.\nArchitecture, bits [16:19] - The permitted values of this field are:\nPartNum, bits [4:15]       - An implementation defined primary part number for\n                             the device. On processors implemented by ARM, if\n                             the top four bits of the primary part number are\n                             0x0 or 0x7, the variant and architecture are\n                             encoded differently.\nRevision, bits [0:3]       - An implementation defined revision number for the\n                             device."
      },
      "MPIDR": {
        "long_name": "Multiprocessor Affinity Register",
        "purpose": "In a multiprocessor system, provides an additional PE identification mechanism\nfor scheduling purposes.\n\nM, bit [31]        - Indicates whether this implementation includes the\n                     functionality introduced by the ARMv7 Multiprocessing\n                     Extensions.\nU, bit [30]        - Indicates a Uniprocessor system, as distinct from PE 0 in a\n                     multiprocessor system.\nMT, bit [24]       - Indicates whether the lowest level of affinity consists of\n                     logical PEs that are implemented using a multithreading\n                     type approach. See the description of Aff0 for more\n                     information about affinity levels.\nAff2, bits [16:23] - Affinity level 2. See the description of Aff0 for more\n                     information.\nAff1, bits [8:15]  - Affinity level 1. See the description of Aff0 for more\n                     information.\nAff0, bits [0:7]   - Affinity level 0. This is the affinity level that is most\n                     significant for determining PE behavior. Higher affinity\n                     levels are increasingly less significant in determining PE\n                     behavior. The assigned value of the MPIDR.{Aff2, Aff1,\n                     Aff0} or MPIDR_EL1.{Aff3, Aff2, Aff1, Aff0} set of fields\n                     of each PE must be unique within the system as a whole."
      },
      "MVBAR": {
        "long_name": "Monitor Vector Base Address Register",
        "purpose": "When EL3 is implemented and can use AArch32, holds the vector base address for\nany exception that is taken to Monitor mode.\n\nSecure software must program the MVBAR with the required initial value as part\nof the PE boot sequence.\n\nbits [5:31] - Vector Base Address. Bits[31:5] of the base address of the\n              exception vectors for exceptions taken to this Exception level.\n              Bits[4:0] of an exception vector are the exception offset."
      },
      "MVFR0": {
        "long_name": "Media and VFP Feature Register 0",
        "purpose": "Describes the features provided by the AArch32 Advanced SIMD and Floating-point\nimplementation.\n\nMust be interpreted with MVFR1 and MVFR2.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nFPRound, bits [28:31]  - Floating-Point Rounding modes.\nFPShVec, bits [24:27]  - Short Vectors.\nFPSqrt, bits [20:23]   - Square Root.\nFPDivide, bits [16:19] - Indicates whether the floating-point implementation\n                         provides support for VFP divide operations.\nFPTrap, bits [12:15]   - Floating Point Exception Trapping.\nFPDP, bits [8:11]      - Double Precision.\nFPSP, bits [4:7]       - Single Precision.\nSIMDReg, bits [0:3]    - Advanced SIMD registers."
      },
      "MVFR1": {
        "long_name": "Media and VFP Feature Register 1",
        "purpose": "Describes the features provided by the AArch32 Advanced SIMD and Floating-point\nimplementation.\n\nMust be interpreted with MVFR0 and MVFR2.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nSIMDFMAC, bits [28:31] - Advanced SIMD Fused Multiply-Accumulate.\nFPHP, bits [24:27]     - Floating Point Half Precision.\nSIMDHP, bits [20:23]   - Advanced SIMD Half Precision.\nSIMDSP, bits [16:19]   - Advanced SIMD Single Precision.\nSIMDInt, bits [12:15]  - Advanced SIMD Integer.\nSIMDLS, bits [8:11]    - Advanced SIMD Load/Store.\nFPDNaN, bits [4:7]     - Default NaN mode.\nFPFtZ, bits [0:3]      - Flush to Zero mode."
      },
      "MVFR2": {
        "long_name": "Media and VFP Feature Register 2",
        "purpose": "Describes the features provided by the AArch32 Advanced SIMD and Floating-point\nimplementation.\n\nMust be interpreted with MVFR0 and MVFR1.\n\nFor general information about the interpretation of the ID registers see\n'Principles of the ID scheme for fields in ID registers' in the ARMv8 ARM,\nsection G7.1.3.\n\nFPMisc, bits [4:7]   - Indicates whether the floating-point implementation\n                       provides support for miscellaneous VFP features.\nSIMDMisc, bits [0:3] - Indicates whether the Advanced SIMD implementation\n                       provides support for miscellaneous Advanced SIMD\n                       features."
      },
      "NMRR": {
        "long_name": "Normal Memory Remap Register",
        "purpose": "Provides additional mapping controls for memory regions that are mapped as\nNormal memory by their entry in the PRRR.\n\nUsed in conjunction with the PRRR.\n\nOR<n>, bits [16:31] - Outer Cacheable property mapping for memory attributes n,\n                      if the region is mapped as Normal memory by the PRRR.TR<n>\n                      entry. n is the value of the TEX[0], C, and B bits\n                      concatenated. The possible values of this field are:\n                          0b00 Region is Non-cacheable.\n                          0b01 Region is Write-Back, Write-Allocate.\n                          0b10 Region is Write-Through, no Write-Allocate.\n                          0b11 Region is Write-Back, no Write-Allocate.\n                      The meaning of the field with n = 6 is implementation\n                      defined and might differ from the meaning given here. This\n                      is because the meaning of the attribute combination\n                      {TEX[0] = 1, C = 1, B = 0} is implementation defined.\nIR<n>, bits [0:15]  - Inner Cacheable property mapping for memory attributes n,\n                      if the region is mapped as Normal memory by the PRRR.TR<n>\n                      entry. n is the value of the TEX[0], C, and B bits\n                      concatenated. The possible values of this field are:\n                          0b00 Region is Non-cacheable.\n                          0b01 Region is Write-Back, Write-Allocate.\n                          0b10 Region is Write-Through, no Write-Allocate.\n                          0b11 Region is Write-Back, no Write-Allocate.\n                      The meaning of the field with n = 6 is implementation\n                      defined and might differ from the meaning given here. This\n                      is because the meaning of the attribute combination\n                      {TEX[0] = 1, C = 1, B = 0} is implementation defined."
      },
      "NSACR": {
        "long_name": "Non-Secure Access Control Register",
        "purpose": "When EL3 is implemented and can use AArch32, defines the Non-secure access\npermissions to Trace, Advanced SIMD and floating-point functionality. Also\nincludes implementation defined bits that can define Non-secure access\npermissions for implementation defined functionality.\n\nNSTRCDIS, bit [20] - Disables Non-secure System register accesses to all\n                     implemented trace registers.\nNSASEDIS, bit [15] - Disables Non-secure access to the Advanced SIMD\n                     functionality.\ncp11, bit [11]     - The value of this field is ignored. If this field is\n                     programmed with a different value to the cp10 field then\n                     this field is unknown on a direct read of the NSACR. If the\n                     implementation does not include Advanced SIMD and floating-\n                     point functionality, this field is res0.\ncp10, bit [10]     - Enable Non-secure access to the Advanced SIMD and floating-\n                     point features."
      },
      "PAR": {
        "long_name": "Physical Address Register",
        "purpose": "Returns the output address (OA) from an Address translation instruction that\nexecuted successfully, or fault information if the instruction did not execute\nsuccessfully.\n\nPA, bits [12:31]       - Output address. The output address (OA) corresponding\n                         to the supplied input address. This field returns\n                         address bits[31:12].\nLPAE, bit [11]         - When updating the PAR with the result of the\n                         translation operation, this bit is set as follows:\nNOS, bit [10]          - Not Outer Shareable.\nNS, bit [9]            - Non-secure. The NS attribute for a translation table\n                         entry from a Secure translation regime. For a result\n                         from a Secure translation regime, this bit reflects the\n                         Security state of the physical address space of the\n                         translation. This means it reflects the effect of the\n                         NSTable bits of earlier levels of the translation table\n                         walk if those NSTable bits have an effect on the\n                         translation. For a result from a Non-secure translation\n                         regime, this bit is unknown.\nSH, bit [7]            - Shareability.\nInner[2:0], bits [4:6] - Inner cacheability attribute for the region.\nOuter[1:0], bits [2:3] - Outer cacheability attribute for the region.\nSS, bit [1]            - Supersection.\nF, bit [0]             - Indicates whether the instruction performed a\n                         successful address translation."
      },
      "PMCCFILTR": {
        "long_name": "Performance Monitors Cycle Count Filter Register",
        "purpose": "Determines the modes in which the Cycle Counter, PMCCNTR, increments.\n\nP, bit [31]   - Privileged filtering bit. Controls counting in EL1. If EL3 is\n                implemented, then counting in Non-secure EL1 is further\n                controlled by the NSK bit. The possible values of this bit are:\n                    0b0 Count cycles in EL1.\n                    0b1 Do not count cycles in EL1.\nU, bit [30]   - User filtering bit. Controls counting in EL0. If EL3 is\n                implemented, then counting in Non-secure EL0 is further\n                controlled by the NSU bit. The possible values of this bit are:\n                    0b0 Count cycles in EL0.\n                    0b1 Do not count cycles in EL0.\nNSK, bit [29] - Non-secure EL1 (kernel) modes filtering bit. Controls counting\n                in Non-secure EL1. If EL3 is not implemented, this bit is res0.\n                If the value of this bit is equal to the value of P, cycles in\n                Non-secure EL1 are counted. Otherwise, cycles in Non-secure EL1\n                are not counted.\nNSU, bit [28] - Non-secure EL0 (Unprivileged) filtering. Controls counting in\n                Non-secure EL0. If EL3 is not implemented, this bit is res0. If\n                the value of this bit is equal to the value of U, cycles in Non-\n                secure EL0 are counted. Otherwise, cycles in Non-secure EL0 are\n                not counted.\nNSH, bit [27] - Non-secure EL2 (Hyp mode) filtering bit. Controls counting in\n                Non-secure EL2. If EL2 is not implemented, this bit is res0.\n                    0b0 Do not count cycles in EL2.\n                    0b1 Count cycles in EL2."
      },
      "PMCCNTR": {
        "long_name": "Performance Monitors Cycle Count Register",
        "purpose": "Holds the value of the processor Cycle Counter, CCNT, that counts processor\nclock cycles. See 'Time as measured by the Performance Monitors cycle counter'\nin the ARMv8 ARM, section D5 for more information.\n\nPMCCFILTR determines the modes and states in which the PMCCNTR can increment.\n\nCCNT, bits [0:31] - Cycle count. Depending on the values of PMCR.{LC,D}, this\n                    field increments in one of the following ways:\n                      - Every processor clock cycle.\n                      - Every 64th processor clock cycle. Writing 1 to PMCR.C\n                    sets this field to 0."
      },
      "PMCEID0": {
        "long_name": "Performance Monitors Common Event Identification register 0",
        "purpose": "Defines which common architectural events and common microarchitectural  events\nare implemented, or counted, using PMU events in the range 0x0000 to 0x001F\n\nWhen the value of a bit in the register is 1 the corresponding common event is\nimplemented and counted.\n\nARM recommends that, if a common event is never counted, the value of the\ncorresponding register bit is 0.\n\nFor more information about the common events and the use of the PMCEIDn\nregisters see The section describing 'Event numbers and common events' in\nchapter D5 'The Performance Monitors Extension' of the ARM Architecture\nReference Manual, for ARMv8-A architecture profile.\n\nID<n>, bits [0:31] - ID[n] corresponds to common event n. For each bit:\n                         0b0 The common event is not implemented, or not\n                     counted.\n                         0b1 The common event is implemented.\n                     A bit that corresponds to a reserved event number is\n                     reserved. The value might be used in a future revision of\n                     the architecture to identify an additional common event.\n                     Such an event might be added retrospectively to an earlier\n                     version of the PMU architecture, provided the event does\n                     not require any additional PMU features and has an event\n                     number that can be represented in the PMCEID<n> registers\n                     of that earlier version of the PMU architecture."
      },
      "PMCEID1": {
        "long_name": "Performance Monitors Common Event Identification register 1",
        "purpose": "Defines which common architectural events and common microarchitectural  events\nare implemented, or counted, using PMU events in the range 0x0020 to 0x003F.\n\nWhen the value of a bit in the register is 1 the corresponding common event is\nimplemented and counted.\n\nARM recommends that, if a common event is never counted, the value of the\ncorresponding register bit is 0.\n\nFor more information about the common events and the use of the PMCEIDn\nregisters see The section describing 'Event numbers and common events' in\nchapter D5 'The Performance Monitors Extension' of the ARM Architecture\nReference Manual, for ARMv8-A architecture profile.\n\nID<n>, bits [0:31] - ID[n] corresponds to common event (0x0020 + n). For each\n                     bit:\n                         0b0 The common event is not implemented, or not\n                     counted.\n                         0b1 The common event is implemented.\n                     A bit that corresponds to a reserved event number is\n                     reserved. The value might be used in a future revision of\n                     the architecture to identify an additional common event.\n                     Such an event might be added retrospectively to an earlier\n                     version of the PMU architecture, provided the event does\n                     not require any additional PMU features and has an event\n                     number that can be represented in the PMCEID<n> registers\n                     of that earlier version of the PMU architecture."
      },
      "PMCEID2": {
        "long_name": "Performance Monitors Common Event Identification register 2",
        "purpose": "Defines which common architectural events and common microarchitectural  events\nare implemented, or counted, using PMU events in the range 0x4000 to 0x401F.\n\nWhen the value of a bit in the register is 1 the corresponding common event is\nimplemented and counted.\n\nARM recommends that, if a common event is never counted, the value of the\ncorresponding register bit is 0.\n\nFor more information about the common events and the use of the PMCEIDn\nregisters see The section describing 'Event numbers and common events' in\nchapter D5 'The Performance Monitors Extension' of the ARM Architecture\nReference Manual, for ARMv8-A architecture profile.\n\nIDhi<n>, bits [0:31] - IDhi[n] corresponds to common event (0x4000 + n). For\n                       each bit:\n                           0b0 The common event is not implemented, or not\n                       counted.\n                           0b1 The common event is implemented.\n                       A bit that corresponds to a reserved event number is\n                       reserved. The value might be used in a future revision of\n                       the architecture to identify an additional common event.\n                       Such an event might be added retrospectively to an\n                       earlier version of the PMU architecture, provided the\n                       event does not require any additional PMU features and\n                       has an event number that can be represented in the\n                       PMCEID<n> registers of that earlier version of the PMU\n                       architecture."
      },
      "PMCEID3": {
        "long_name": "Performance Monitors Common Event Identification register 3",
        "purpose": "Defines which common architectural events and common microarchitectural  events\nare implemented, or counted, using PMU events in the range 0x4020 to 0x403F.\n\nWhen the value of a bit in the register is 1 the corresponding common event is\nimplemented and counted.\n\nARM recommends that, if a common event is never counted, the value of the\ncorresponding register bit is 0.\n\nFor more information about the common events and the use of the PMCEIDn\nregisters see The section describing 'Event numbers and common events' in\nchapter D5 'The Performance Monitors Extension' of the ARM Architecture\nReference Manual, for ARMv8-A architecture profile.\n\nIDhi<n>, bits [0:31] - IDhi[n] corresponds to common event (0x4020 + n). For\n                       each bit:\n                           0b0 The common event is not implemented, or not\n                       counted.\n                           0b1 The common event is implemented.\n                       A bit that corresponds to a reserved event number is\n                       reserved. The value might be used in a future revision of\n                       the architecture to identify an additional common event.\n                       Such an event might be added retrospectively to an\n                       earlier version of the PMU architecture, provided the\n                       event does not require any additional PMU features and\n                       has an event number that can be represented in the\n                       PMCEID<n> registers of that earlier version of the PMU\n                       architecture."
      },
      "PMCNTENCLR": {
        "long_name": "Performance Monitors Count Enable Clear register",
        "purpose": "Disables the Cycle Count Register, PMCCNTR, and any implemented event counters\nPMEVCNTR<n>. Reading this register shows which counters are enabled.\n\nPMCNTENCLR is used in conjunction with the PMCNTENSET register.\n\nC, bit [31]       - PMCCNTR disable bit. Disables the cycle counter register.\n                    Possible values are:\n                        0b0 When read, means the cycle counter is disabled. When\n                    written, has no effect.\n                        0b1 When read, means the cycle counter is enabled. When\n                    written, disables the cycle counter.\nP<n>, bits [0:30] - Event counter disable bit for PMEVCNTR<n>. Bits [30:N] are\n                    RAZ/WI. When EL2 is implemented and enabled in the current\n                    Security state, in EL1 and EL0, N is the value in\n                    MDCR_EL2.HPMN if EL2 is using AArch64, or in HDCR.HPMN if\n                    EL2 is using AArch32. Otherwise, N is the value in PMCR.N.\n                    Possible values of each bit are:\n                        0b0 When read, means that PMEVCNTR<n> is disabled. When\n                    written, has no effect.\n                        0b1 When read, means that PMEVCNTR<n> is enabled. When\n                    written, disables PMEVCNTR<n>."
      },
      "PMCNTENSET": {
        "long_name": "Performance Monitors Count Enable Set register",
        "purpose": "Enables the Cycle Count Register, PMCCNTR, and any implemented event counters\nPMEVCNTR<n>. Reading this register shows which counters are enabled.\n\nPMCNTENSET is used in conjunction with the PMCNTENCLR register.\n\nC, bit [31]       - PMCCNTR enable bit. Enables the cycle counter register.\n                    Possible values are:\n                        0b0 When read, means the cycle counter is disabled. When\n                    written, has no effect.\n                        0b1 When read, means the cycle counter is enabled. When\n                    written, enables the cycle counter.\nP<n>, bits [0:30] - Event counter enable bit for PMEVCNTR<n>. Bits [30:N] are\n                    RAZ/WI. When EL2 is implemented and enabled in the current\n                    Security state, in EL1 and EL0, N is the value in\n                    MDCR_EL2.HPMN if EL2 is using AArch64, or in HDCR.HPMN if\n                    EL2 is using AArch32. Otherwise, N is the value in PMCR.N.\n                    Possible values of each bit are:\n                        0b0 When read, means that PMEVCNTR<n> is disabled. When\n                    written, has no effect.\n                        0b1 When read, means that PMEVCNTR<n> event counter is\n                    enabled. When written, enables PMEVCNTR<n>."
      },
      "PMCR": {
        "long_name": "Performance Monitors Control Register",
        "purpose": "Provides details of the Performance Monitors implementation, including the\nnumber of counters implemented, and configures and controls the counters.\n\nIMP, bits [24:31]    - Implementer code.\nIDCODE, bits [16:23] - Identification code.\nN, bits [11:15]      - An RO field that indicates the number of event counters\n                       implemented.\nLP, bit [7]          - Long event counter enable.\nLC, bit [6]          - Long cycle counter enable.\nDP, bit [5]          - Disable cycle counter when event counting is prohibited.\nX, bit [4]           - Enable export of events in an implementation defined\n                       event stream.\nD, bit [3]           - Clock divider.\nC, bit [2]           - Cycle counter reset.\nP, bit [1]           - Event counter reset.\nE, bit [0]           - Enable."
      },
      "PMEVCNTR<n>": {
        "long_name": "Performance Monitors Event Count Registers",
        "purpose": "Holds event counter n, which counts events, where n is 0 to 30.\n\nbits [0:31] - Event counter n. Value of event counter n, where n is the number\n              of this register and is a number from 0 to 30. If ARMv8.5-PMU is\n              implemented, the event counter is 64 bits and only the least-\n              significant part of the event counter is accessible in AArch32\n              state:\n                -  Reads from PMEVCNTR<n> return bits [31:0] of the counter.\n                -  Writes to PMEVCNTR<n> update bits [31:0] and leave bits\n              [63:32] unchanged.\n                -  There is no means to access bits [63:32] directly from\n              AArch32 state. If ARMv8.5-PMU is not implemented, the event\n              counter is 32 bits."
      },
      "PMEVTYPER<n>": {
        "long_name": "Performance Monitors Event Type Registers",
        "purpose": "Configures event counter n, where n is 0 to 30.\n\nP, bit [31]                   - Privileged filtering bit.\nU, bit [30]                   - User filtering bit.\nNSK, bit [29]                 - Non-secure EL1 (kernel) modes filtering bit.\nNSU, bit [28]                 - Non-secure EL0 (Unprivileged) filtering.\nNSH, bit [27]                 - Non-secure EL2 (Hyp mode) filtering bit.\nMT, bit [25]                  - Multithreading.\nevtCount[15:10], bits [10:15] - Extension to evtCount[9:0].\nevtCount[9:0], bits [0:9]     - Event to count."
      },
      "PMINTENCLR": {
        "long_name": "Performance Monitors Interrupt Enable Clear register",
        "purpose": "Disables the generation of interrupt requests on overflows from the Cycle Count\nRegister, PMCCNTR, and the event counters PMEVCNTR<n>. Reading the register\nshows which overflow interrupt requests are enabled.\n\nPMINTENCLR is used in conjunction with the PMINTENSET register.\n\nC, bit [31]       - PMCCNTR overflow interrupt request disable bit. Possible\n                    values are:\n                        0b0 When read, means the cycle counter overflow\n                    interrupt request is disabled. When written, has no effect.\n                        0b1 When read, means the cycle counter overflow\n                    interrupt request is enabled. When written, disables the\n                    cycle count overflow interrupt request.\nP<n>, bits [0:30] - Event counter overflow interrupt request disable bit for\n                    PMEVCNTR<n>. Bits [30:N] are RAZ/WI. When EL2 is implemented\n                    and enabled in the current Security state, in EL1 and EL0, N\n                    is the value in MDCR_EL2.HPMN if EL2 is using AArch64, or in\n                    HDCR.HPMN if EL2 is using AArch32. Otherwise, N is the value\n                    in PMCR.N. Possible values are:\n                        0b0 When read, means that the PMEVCNTR<n> event counter\n                    interrupt request is disabled. When written, has no effect.\n                        0b1 When read, means that the PMEVCNTR<n> event counter\n                    interrupt request is enabled. When written, disables the\n                    PMEVCNTR<n> interrupt request."
      },
      "PMINTENSET": {
        "long_name": "Performance Monitors Interrupt Enable Set register",
        "purpose": "Enables the generation of interrupt requests on overflows from the Cycle Count\nRegister, PMCCNTR, and the event counters PMEVCNTR<n>. Reading the register\nshows which overflow interrupt requests are enabled.\n\nPMINTENSET is used in conjunction with the PMINTENCLR register.\n\nC, bit [31]       - PMCCNTR overflow interrupt request enable bit. Possible\n                    values are:\n                        0b0 When read, means the cycle counter overflow\n                    interrupt request is disabled. When written, has no effect.\n                        0b1 When read, means the cycle counter overflow\n                    interrupt request is enabled. When written, enables the\n                    cycle count overflow interrupt request.\nP<n>, bits [0:30] - Event counter overflow interrupt request enable bit for\n                    PMEVCNTR<n>. When EL2 is implemented and enabled in the\n                    current Security state, in EL1 and EL0, N is the value in\n                    MDCR_EL2.HPMN if EL2 is using AArch64, or in HDCR.HPMN if\n                    EL2 is using AArch32. Otherwise, N is the value in PMCR.N.\n                    Bits [30:N] are RAZ/WI. Possible values are:\n                        0b0 When read, means that the PMEVCNTR<n> event counter\n                    interrupt request is disabled. When written, has no effect.\n                        0b1 When read, means that the PMEVCNTR<n> event counter\n                    interrupt request is enabled. When written, enables the\n                    PMEVCNTR<n> interrupt request."
      },
      "PMMIR": {
        "long_name": "Performance Monitors Machine Identification Register",
        "purpose": "Describes Performance Monitors parameters specific to the implementation to\nsoftware.\n\nSLOTS, bits [0:7] - Operation width. The largest value by which the STALL_SLOT\n                    event might increment by in a single cycle. If the\n                    STALL_SLOT event is not implemented, this field might read\n                    as zero."
      },
      "PMOVSR": {
        "long_name": "Performance Monitors Overflow Flag Status Register",
        "purpose": "Contains the state of the overflow bit for the Cycle Count Register, PMCCNTR,\nand each of the implemented event counters PMEVCNTR<n>. Writing to this register\nclears these bits.\n\nC, bit [31]       - Cycle counter overflow clear bit. Possible values are:\n                        0b0 When read, means the cycle counter has not\n                    overflowed since this bit was last cleared. When written,\n                    has no effect.\n                        0b1 When read, means the cycle counter has overflowed\n                    since this bit was last cleared. When written, clears the\n                    cycle counter overflow bit to 0.\nP<n>, bits [0:30] - Event counter overflow clear bit for PMEVCNTR<n>. Bits\n                    [30:N] are RAZ/WI. When EL2 is implemented and enabled in\n                    the current Security state, in EL1 and EL0, N is the value\n                    in MDCR_EL2.HPMN if EL2 is using AArch64, or in HDCR.HPMN if\n                    EL2 is using AArch32. Otherwise, N is the value in PMCR.N.\n                    Possible values of each bit are:\n                        0b0 When read, means that PMEVCNTR<n> has not overflowed\n                    since this bit was last cleared. When written, has no\n                    effect.\n                        0b1 When read, means that PMEVCNTR<n> has overflowed\n                    since this bit was last cleared. When written, clears the\n                    PMEVCNTR<n> overflow bit to 0."
      },
      "PMOVSSET": {
        "long_name": "Performance Monitors Overflow Flag Status Set register",
        "purpose": "Sets the state of the overflow bit for the Cycle Count Register, PMCCNTR, and\neach of the implemented event counters PMEVCNTR<n>.\n\nC, bit [31]       - Cycle counter overflow set bit.\n                        0b0 When read, means the cycle counter has not\n                    overflowed since this bit was last cleared. When written,\n                    has no effect.\n                        0b1 When read, means the cycle counter has overflowed\n                    since this bit was last cleared. When written, sets the\n                    cycle counter overflow bit to 1.\n                    PMCR.LC controls whether an overflow is detected from\n                    unsigned overflow of PMCCNTR[31:0] or unsigned overflow of\n                    PMCCNTR[63:0].\nP<n>, bits [0:30] - Event counter overflow set bit for PMEVCNTR<n>. Bits [30:N]\n                    are RAZ/WI. When EL2 is implemented and enabled in the\n                    current Security state, in EL1 and EL0, N is the value in\n                    MDCR_EL2.HPMN if EL2 is using AArch64, or in HDCR.HPMN if\n                    EL2 is using AArch32. Otherwise, N is the value in PMCR.N.\n                        0b0 When read, means that PMEVCNTR<n> has not overflowed\n                    since this bit was last cleared. When written, has no\n                    effect.\n                        0b1 When read, means that PMEVCNTR<n> has overflowed\n                    since this bit was last . When written, sets the PMEVCNTR<n>\n                    overflow bit to 1.\n                    If ARMv8.5-PMU is implemented, MDCR_EL2.HLP, HDCR.HLP, and\n                    PMCR.LP control whether an overflow is detected from\n                    unsigned overflow of PMEVCNTR<n>[31:0] or unsigned overflow\n                    of PMEVCNTR<n>[63:0]. PMEVCNTR<n>[63:32] cannot be accessed\n                    directly in AArch32 state."
      },
      "PMSELR": {
        "long_name": "Performance Monitors Event Counter Selection Register",
        "purpose": "Selects the current event counter PMEVCNTR<n> or the cycle counter, CCNT.\n\nPMSELR is used in conjunction with PMXEVTYPER to determine the event that\nincrements a selected event counter, and the modes and states in which the\nselected counter increments.\n\nIt is also used in conjunction with PMXEVCNTR, to determine the value of a\nselected event counter.\n\nSEL, bits [0:4] - Selects event counter, PMEVCNTR<n>, where n is the value held\n                  in this field."
      },
      "PMSWINC": {
        "long_name": "Performance Monitors Software Increment register",
        "purpose": "Increments a counter that is configured to count the Software increment event,\nevent 0x00. For more information, see  'SW_INCR' in the ARMv8 ARM, section D5.\n\nP<n>, bits [0:30] - Event counter software increment bit for PMEVCNTR<n>. Bits\n                    [30:N] are WI. When EL2 is implemented and enabled in the\n                    current Security state, in EL1 and EL0, N is the value in\n                    MDCR_EL2.HPMN if EL2 is using AArch64, or in HDCR.HPMN if\n                    EL2 is using AArch32. Otherwise, N is the value in PMCR.N.\n                    The effects of writing to this bit are:\n                        0b0 No action. The write to this bit is ignored.\n                        0b1 If PMEVCNTR<n> is enabled and configured to count\n                    the software increment event, increments PMEVCNTR<n> by 1.\n                    If PMEVCNTR<n> is disabled, or not configured to count the\n                    software increment event, the write to this bit is ignored."
      },
      "PMUSERENR": {
        "long_name": "Performance Monitors User Enable Register",
        "purpose": "Enables or disables User mode access to the Performance Monitors.\n\nER, bit [3] - Event counter read trap control:\n                  0b0 EL0 reads of the PMXEVCNTR and PMEVCNTR<n>, and EL0 RW\n              access to the PMSELR, are trapped to Undefined mode if\n              PMUSERENR.EN is also 0.\n                  0b1 Overrides PMUSERENR.EN and enables RO access to PMXEVCNTR\n              and PMEVCNTR<n>, and RW access to PMSELR.\nCR, bit [2] - Cycle counter read trap control:\n                  0b0 EL0 reads of the PMCCNTR are trapped to Undefined mode if\n              PMUSERENR.EN is also 0.\n                  0b1 Overrides PMUSERENR.EN and enables access to PMCCNTR.\nSW, bit [1] - Software increment write trap control:\n                  0b0 EL0 writes to the PMSWINC are trapped to Undefined mode if\n              PMUSERENR.EN is also 0.\n                  0b1 Overrides PMUSERENR.EN and enables access to PMSWINC.\nEN, bit [0] - Traps EL0 accesses to the Performance Monitors registers to\n              Undefined mode:\n                  0b0 While at EL0, PMUSERENR is always RO. Accesses to the\n              other Performance Monitors registers are trapped to Undefined\n              mode, unless enabled by one of PMUSERENR.{ER, CR, SW}.\n                  0b1 While at EL0, software can access all PMU registers except\n              PMINTENSET and PMINTENCLR."
      },
      "PMXEVCNTR": {
        "long_name": "Performance Monitors Selected Event Count Register",
        "purpose": "Reads or writes the value of the selected event counter, PMEVCNTR<n>. PMSELR.SEL\ndetermines which event counter is selected.\n\nPMEVCNTR<n>, bits [0:31] - Value of the selected event counter, PMEVCNTR<n>,\n                           where n is the value stored in PMSELR.SEL."
      },
      "PMXEVTYPER": {
        "long_name": "Performance Monitors Selected Event Type Register",
        "purpose": "When PMSELR.SEL selects an event counter, this accesses a PMEVTYPER<n> register.\nWhen PMSELR.SEL selects the cycle counter, this accesses PMCCFILTR.\n\nbits [0:31] - Event type register or PMCCFILTR. When PMSELR.SEL == 31, this\n              register accesses PMCCFILTR. Otherwise, this register accesses\n              PMEVTYPER<n> where n is the value in PMSELR.SEL."
      },
      "PRRR": {
        "long_name": "Primary Region Remap Register",
        "purpose": "Controls the top level mapping of the TEX[0], C, and B memory region attributes.\n\nNOS<n>, bits [24:31] - Not Outer Shareable.\nNS1, bit [19]        - Mapping of S = 1 attribute for Normal memory regions.\nNS0, bit [18]        - Mapping of S = 0 attribute for Normal memory regions.\nDS1, bit [17]        - Mapping of S = 1 attribute for Device memory.\nDS0, bit [16]        - Mapping of S = 0 attribute for Device memory.\nTR<n>, bits [0:15]   - TR<n> is the primary TEX mapping for memory attributes n,\n                       and defines the mapped memory type for a region with\n                       attributes n."
      },
      "REVIDR": {
        "long_name": "Revision ID Register",
        "purpose": "Provides implementation-specific minor revision information."
      },
      "RMR": {
        "long_name": "Reset Management Register",
        "purpose": "If EL1 or EL3 is the highest implemented Exception level and this register is\nimplemented:\n\n  - A write to the register at the highest implemented Exception level can\nrequest a Warm reset.\n  - If the highest implemented Exception level can use AArch32 and AArch64, this\nregister specifies the Execution state that the PE boots into on a Warm reset.\n\nRR, bit [1]   - Reset Request. Setting this bit to 1 requests a Warm reset.\nAA64, bit [0] - When the highest implemented Exception level can use AArch64,\n                determines which Execution state the PE boots into after a Warm\n                reset:\n                    0b0 AArch32.\n                    0b1 AArch64.\n                On coming out of the Warm reset, execution starts at the\n                implementation defined reset vector address of the specified\n                Execution state. If the highest implemented Exception level\n                cannot use AArch64 this bit is RAZ/WI."
      },
      "RVBAR": {
        "long_name": "Reset Vector Base Address Register",
        "purpose": "If EL3 is not implemented, contains the implementation defined address that\nexecution starts from after reset when executing in AArch32 state.\n\nbits [1:31] - Reset Address[31:1]. Bits [31:1] of the implementation defined\n              address that execution starts from after reset when executing in\n              32-bit state."
      },
      "SCR": {
        "long_name": "Secure Configuration Register",
        "purpose": "When EL3 is implemented and can use AArch32, defines the configuration of the\ncurrent Security state. It specifies:\n\n  - The Security state, either Secure or Non-secure.\n  - What mode the PE branches to if an IRQ, FIQ, or External abort occurs.\n  - Whether the CPSR.F or CPSR.A bits can be modified when SCR.NS==1.\n\nTERR, bit [15] - Trap Error record accesses. Generate a Monitor Trap exception\n                 on accesses to the following registers from modes other than\n                 Monitor mode: ERRIDR, ERRSELR, ERXADDR, ERXADDR2, ERXCTLR,\n                 ERXCTLR2, ERXFR, ERXFR2, ERXMISC0, ERXMISC1, ERXMISC2,\n                 ERXMISC3, and ERXSTATUS. When ARMv8.4-RAS is implemented,\n                 ERXMISC4, ERXMISC5, ERXMISC6, ERXMISC7.\nTWE, bit [13]  - Traps WFE instructions to Monitor mode.\nTWI, bit [12]  - Traps WFI instructions to Monitor mode.\nSIF, bit [9]   - Secure instruction fetch. When the PE is in Secure state, this\n                 bit disables instruction fetch from Non-secure memory.\nHCE, bit [8]   - Hypervisor Call instruction enable. If EL2 is enabled in the\n                 current Security state, enables execution of HVC instructions\n                 at EL1 and EL2.\nSCD, bit [7]   - Secure Monitor Call disable. Disables SMC instructions.\nnET, bit [6]   - Not Early Termination. This bit disables early termination.\nAW, bit [5]    - \nFW, bit [4]    - \nEA, bit [3]    - External Abort handler. This bit controls which mode takes\n                 External aborts.\nFIQ, bit [2]   - FIQ handler. This bit controls which mode takes FIQ exceptions.\nIRQ, bit [1]   - IRQ handler. This bit controls which mode takes IRQ exceptions.\nNS, bit [0]    - Non-secure bit."
      },
      "SCTLR": {
        "long_name": "System Control Register",
        "purpose": "Provides the top level control of the system, including its memory system.\n\nDSSBS, bit [31]  - Default PSTATE.SSBS value on Exception Entry.\nTE, bit [30]     - T32 Exception Enable.\nAFE, bit [29]    - Access Flag Enable.\nTRE, bit [28]    - TEX remap enable.\nEE, bit [25]     - The value of the PSTATE.E bit on branch to an exception\n                   vector or coming out of reset, and the endianness of stage 1\n                   translation table walks in the PL1&0 translation regime.\nSPAN, bit [23]   - Set Privileged Access Never, on taking an exception to EL1\n                   from either Secure or Non-secure state, or to EL3 from Secure\n                   state when EL3 is using AArch32.\nUWXN, bit [20]   - Unprivileged write permission implies PL1 XN (Execute-never).\nWXN, bit [19]    - Write permission implies XN (Execute-never).\nnTWE, bit [18]   - Traps EL0 execution of WFE instructions to Undefined mode.\nnTWI, bit [16]   - Traps EL0 execution of WFI instructions to Undefined mode.\nV, bit [13]      - Vectors bit.\nI, bit [12]      - Instruction access Cacheability control, for accesses at EL1\n                   and EL0:\nEnRCTX, bit [10] - Enable EL0 Access to the AArch32 CFPRCTX, DVPRCTX and CPPRCTX\n                   instructions.\nSED, bit [8]     - SETEND instruction disable.\nITD, bit [7]     - IT Disable.\nUNK, bit [6]     - Writes to this bit are IGNORED.\nCP15BEN, bit [5] - System instruction memory barrier enable.\nLSMAOE, bit [4]  - Load Multiple and Store Multiple Atomicity and Ordering\n                   Enable.\nnTLSMD, bit [3]  - No Trap Load Multiple and Store Multiple to Device-nGRE\n                   /Device-nGnRE/Device-nGnRnE memory.\nC, bit [2]       - Cacheability control, for data accesses at EL1 and EL0:\nA, bit [1]       - Alignment check enable.\nM, bit [0]       - MMU enable for EL1 and EL0 stage 1 address translation."
      },
      "SDCR": {
        "long_name": "Secure Debug Control Register",
        "purpose": "Provides EL3 configuration options for self-hosted debug, trace, and the\nPerformance Monitors Extension.\n\nSCCD, bit [23]    - Secure Cycle Counter Disable.\nEPMAD, bit [21]   - External debug interface Performance Monitors registers\n                    disable.\nEPMAD, bit [21]   - External debug interface Performance Monitors registers\n                    disable.\nEDAD, bit [20]    - External debug register Non-secure access disable.\nEDAD, bit [20]    - External debug access disable.\nEDAD, bit [20]    - External debug access disable.\nTTRF, bit [19]    - Trap Trace Filter controls.\nSTE, bit [18]     - Secure Trace Enable.\nSPME, bit [17]    - Secure Performance Monitors enable.\nSPME, bit [17]    - Secure Performance Monitors event counting is prohibited\n                    unless ExternalSecureNoninvasiveDebugEnabled() ==TRUE, which\n                    means this field is overridden by the implementation defined\n                    authentication interface.\nSPD, bits [14:15] - AArch32 Secure privileged debug."
      },
      "SDER": {
        "long_name": "Secure Debug Enable Register",
        "purpose": "Controls invasive and non-invasive debug in the Secure EL0 mode.\n\nSUNIDEN, bit [1] - Secure User Non-Invasive Debug Enable:\n                       0b0 Performance Monitors event counting prohibited in\n                   Secure EL0 unless allowed by AArc64-MDCR_EL3.SPME, SDCR.SPME.\n                   In an ARMv8.0 or ARMv8.1 implementation, event counting can\n                   also be allowed using the implementation defined\n                   authentication interface\n                   ExternalSecureNoninvasiveDebugEnabled().\n                       0b1 Performance Monitors event counting allowed in Secure\n                   EL0.\nSUIDEN, bit [0]  - Secure User Invasive Debug Enable:\n                       0b0 Debug exceptions other than Breakpoint Instruction\n                   exceptions from Secure EL0 are disabled, unless enabled by\n                   MDCR_EL3.SPD32 or SDCR.SPD.\n                       0b1 Debug exceptions from Secure EL0 are enabled."
      },
      "SPSR": {
        "long_name": "Saved Program Status Register",
        "purpose": "Holds the saved process state for the current mode.\n\nN, bit [31]           - Set to the value of PSTATE.N on taking an exception to\n                        the current mode, and copied to PSTATE.N on executing an\n                        exception return operation in the current mode.\nZ, bit [30]           - Set to the value of PSTATE.Z on taking an exception to\n                        the current mode, and copied to PSTATE.Z on executing an\n                        exception return operation in the current mode.\nC, bit [29]           - Set to the value of PSTATE.C on taking an exception to\n                        the current mode, and copied to PSTATE.C on executing an\n                        exception return operation in the current mode.\nV, bit [28]           - Set to the value of PSTATE.V on taking an exception to\n                        the current mode, and copied to PSTATE.V on executing an\n                        exception return operation in the current mode.\nQ, bit [27]           - Set to the value of PSTATE.Q on taking an exception to\n                        the current mode, and copied to PSTATE.Q on executing an\n                        exception return operation in the current mode.\nIT[1:0], bits [25:26] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nJ, bit [24]           - res0.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state bit.\nGE, bits [16:19]      - Greater than or Equal flags, for parallel addition and\n                        subtraction.\nIT[7:2], bits [10:15] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nE, bit [9]            - Endianness state bit.\nA, bit [8]            - SError interrupt mask bit.\nI, bit [7]            - IRQ mask bit.\nF, bit [6]            - FIQ mask bit.\nT, bit [5]            - T32 Instruction set state bit.\nM[4], bit [4]         - Execution state that the exception was taken from.\nM[3:0], bits [0:3]    - AArch32 mode that an exception was taken from."
      },
      "SPSR_abt": {
        "long_name": "Saved Program Status Register (Abort mode)",
        "purpose": "Holds the saved process state when an exception is taken to Abort mode.\n\nN, bit [31]           - Set to the value of CPSR.N on taking an exception to\n                        Abort mode, and copied to CPSR.N on executing an\n                        exception return operation in Abort mode.\nZ, bit [30]           - Set to the value of CPSR.Z on taking an exception to\n                        Abort mode, and copied to CPSR.Z on executing an\n                        exception return operation in Abort mode.\nC, bit [29]           - Set to the value of CPSR.C on taking an exception to\n                        Abort mode, and copied to CPSR.C on executing an\n                        exception return operation in Abort mode.\nV, bit [28]           - Set to the value of CPSR.V on taking an exception to\n                        Abort mode, and copied to CPSR.V on executing an\n                        exception return operation in Abort mode.\nQ, bit [27]           - Set to the value of CPSR.Q on taking an exception to\n                        Abort mode, and copied to CPSR.Q on executing an\n                        exception return operation in Abort mode.\nIT[1:0], bits [25:26] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nJ, bit [24]           - res0.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.This bit is set to the value of\n                        CPSR.DIT on taking an exception to Abort mode, and\n                        copied to CPSR.DIT on executing an exception return\n                        operation in Abort mode.\nIL, bit [20]          - Illegal Execution state bit.\nGE, bits [16:19]      - Greater than or Equal flags, for parallel addition and\n                        subtraction.\nIT[7:2], bits [10:15] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nE, bit [9]            - Endianness state bit.\nA, bit [8]            - SError interrupt mask bit.\nI, bit [7]            - IRQ mask bit.\nF, bit [6]            - FIQ mask bit.\nT, bit [5]            - T32 Instruction set state bit.\nM[4], bit [4]         - Execution state that the exception was taken from.\nM[3:0], bits [0:3]    - AArch32 mode that an exception was taken from."
      },
      "SPSR_fiq": {
        "long_name": "Saved Program Status Register (FIQ mode)",
        "purpose": "Holds the saved process state when an exception is taken to FIQ mode.\n\nN, bit [31]           - Set to the value of CPSR.N on taking an exception to FIQ\n                        mode, and copied to CPSR.N on executing an exception\n                        return operation in FIQ mode.\nZ, bit [30]           - Set to the value of CPSR.Z on taking an exception to FIQ\n                        mode, and copied to CPSR.Z on executing an exception\n                        return operation in FIQ mode.\nC, bit [29]           - Set to the value of CPSR.C on taking an exception to FIQ\n                        mode, and copied to CPSR.C on executing an exception\n                        return operation in FIQ mode.\nV, bit [28]           - Set to the value of CPSR.V on taking an exception to FIQ\n                        mode, and copied to CPSR.V on executing an exception\n                        return operation in FIQ mode.\nQ, bit [27]           - Set to the value of CPSR.Q on taking an exception to FIQ\n                        mode, and copied to CPSR.Q on executing an exception\n                        return operation in FIQ mode.\nIT[1:0], bits [25:26] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nJ, bit [24]           - res0.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state bit.\nGE, bits [16:19]      - Greater than or Equal flags, for parallel addition and\n                        subtraction.\nIT[7:2], bits [10:15] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nE, bit [9]            - Endianness state bit.\nA, bit [8]            - SError interrupt mask bit.\nI, bit [7]            - IRQ mask bit.\nF, bit [6]            - FIQ mask bit.\nT, bit [5]            - T32 Instruction set state bit.\nM[4], bit [4]         - Execution state that the exception was taken from.\nM[3:0], bits [0:3]    - AArch32 mode that an exception was taken from."
      },
      "SPSR_hyp": {
        "long_name": "Saved Program Status Register (Hyp mode)",
        "purpose": "Holds the saved process state when an exception is taken to Hyp mode.\n\nN, bit [31]           - Set to the value of CPSR.N on taking an exception to Hyp\n                        mode, and copied to CPSR.N on executing an exception\n                        return operation in Hyp mode.\nZ, bit [30]           - Set to the value of CPSR.Z on taking an exception to Hyp\n                        mode, and copied to CPSR.Z on executing an exception\n                        return operation in Hyp mode.\nC, bit [29]           - Set to the value of CPSR.C on taking an exception to Hyp\n                        mode, and copied to CPSR.C on executing an exception\n                        return operation in Hyp mode.\nV, bit [28]           - Set to the value of CPSR.V on taking an exception to Hyp\n                        mode, and copied to CPSR.V on executing an exception\n                        return operation in Hyp mode.\nQ, bit [27]           - Set to the value of CPSR.Q on taking an exception to Hyp\n                        mode, and copied to CPSR.Q on executing an exception\n                        return operation in Hyp mode.\nIT[1:0], bits [25:26] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nJ, bit [24]           - res0.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.This bit is set to the value of\n                        CPSR.DIT on taking an exception to Hyp mode, and copied\n                        to CPSR.DIT on executing an exception return operation\n                        in Hyp mode.\nIL, bit [20]          - Illegal Execution state bit.\nGE, bits [16:19]      - Greater than or Equal flags, for parallel addition and\n                        subtraction.\nIT[7:2], bits [10:15] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nE, bit [9]            - Endianness state bit.\nA, bit [8]            - SError interrupt mask bit.\nI, bit [7]            - IRQ mask bit.\nF, bit [6]            - FIQ mask bit.\nT, bit [5]            - T32 Instruction set state bit.\nM[4], bit [4]         - Execution state that the exception was taken from.\nM[3:0], bits [0:3]    - AArch32 mode that an exception was taken from."
      },
      "SPSR_irq": {
        "long_name": "Saved Program Status Register (IRQ mode)",
        "purpose": "Holds the saved process state when an exception is taken to IRQ mode.\n\nN, bit [31]           - Set to the value of CPSR.N on taking an exception to IRQ\n                        mode, and copied to CPSR.N on executing an exception\n                        return operation in IRQ mode.\nZ, bit [30]           - Set to the value of CPSR.Z on taking an exception to IRQ\n                        mode, and copied to CPSR.Z on executing an exception\n                        return operation in IRQ mode.\nC, bit [29]           - Set to the value of CPSR.C on taking an exception to IRQ\n                        mode, and copied to CPSR.C on executing an exception\n                        return operation in IRQ mode.\nV, bit [28]           - Set to the value of CPSR.V on taking an exception to IRQ\n                        mode, and copied to CPSR.V on executing an exception\n                        return operation in IRQ mode.\nQ, bit [27]           - Set to the value of CPSR.Q on taking an exception to IRQ\n                        mode, and copied to CPSR.Q on executing an exception\n                        return operation in IRQ mode.\nIT[1:0], bits [25:26] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nJ, bit [24]           - res0.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state bit.\nGE, bits [16:19]      - Greater than or Equal flags, for parallel addition and\n                        subtraction.\nIT[7:2], bits [10:15] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nE, bit [9]            - Endianness state bit.\nA, bit [8]            - SError interrupt mask bit.\nI, bit [7]            - IRQ mask bit.\nF, bit [6]            - FIQ mask bit.\nT, bit [5]            - T32 Instruction set state bit.\nM[4], bit [4]         - Execution state that the exception was taken from.\nM[3:0], bits [0:3]    - AArch32 mode that an exception was taken from."
      },
      "SPSR_mon": {
        "long_name": "Saved Program Status Register (Monitor mode)",
        "purpose": "Holds the saved process state when an exception is taken to Monitor mode.\n\nN, bit [31]           - Set to the value of CPSR.N on taking an exception to\n                        Monitor mode, and copied to CPSR.N on executing an\n                        exception return operation in Monitor mode.\nZ, bit [30]           - Set to the value of CPSR.Z on taking an exception to\n                        Monitor mode, and copied to CPSR.Z on executing an\n                        exception return operation in Monitor mode.\nC, bit [29]           - Set to the value of CPSR.C on taking an exception to\n                        Monitor mode, and copied to CPSR.C on executing an\n                        exception return operation in Monitor mode.\nV, bit [28]           - Set to the value of CPSR.V on taking an exception to\n                        Monitor mode, and copied to CPSR.V on executing an\n                        exception return operation in Monitor mode.\nQ, bit [27]           - Set to the value of CPSR.Q on taking an exception to\n                        Monitor mode, and copied to CPSR.Q on executing an\n                        exception return operation in Monitor mode.\nIT[1:0], bits [25:26] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nJ, bit [24]           - res0.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state bit.\nGE, bits [16:19]      - Greater than or Equal flags, for parallel addition and\n                        subtraction.\nIT[7:2], bits [10:15] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nE, bit [9]            - Endianness state bit.\nA, bit [8]            - SError interrupt mask bit.\nI, bit [7]            - IRQ mask bit.\nF, bit [6]            - FIQ mask bit.\nT, bit [5]            - T32 Instruction set state bit.\nM[4], bit [4]         - Execution state that the exception was taken from.\nM[3:0], bits [0:3]    - AArch32 mode that an exception was taken from."
      },
      "SPSR_svc": {
        "long_name": "Saved Program Status Register (Supervisor mode)",
        "purpose": "Holds the saved process state when an exception is taken to Supervisor mode.\n\nN, bit [31]           - Set to the value of CPSR.N on taking an exception to\n                        Supervisor mode, and copied to CPSR.N on executing an\n                        exception return operation in Supervisor mode.\nZ, bit [30]           - Set to the value of CPSR.Z on taking an exception to\n                        Supervisor mode, and copied to CPSR.Z on executing an\n                        exception return operation in Supervisor mode.\nC, bit [29]           - Set to the value of CPSR.C on taking an exception to\n                        Supervisor mode, and copied to CPSR.C on executing an\n                        exception return operation in Supervisor mode.\nV, bit [28]           - Set to the value of CPSR.V on taking an exception to\n                        Supervisor mode, and copied to CPSR.V on executing an\n                        exception return operation in Supervisor mode.\nQ, bit [27]           - Set to the value of CPSR.Q on taking an exception to\n                        Supervisor mode, and copied to CPSR.Q on executing an\n                        exception return operation in Supervisor mode.\nIT[1:0], bits [25:26] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nJ, bit [24]           - res0.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state bit.\nGE, bits [16:19]      - Greater than or Equal flags, for parallel addition and\n                        subtraction.\nIT[7:2], bits [10:15] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nE, bit [9]            - Endianness state bit.\nA, bit [8]            - SError interrupt mask bit.\nI, bit [7]            - IRQ mask bit.\nF, bit [6]            - FIQ mask bit.\nT, bit [5]            - T32 Instruction set state bit.\nM[4], bit [4]         - Execution state that the exception was taken from.\nM[3:0], bits [0:3]    - AArch32 mode that an exception was taken from."
      },
      "SPSR_und": {
        "long_name": "Saved Program Status Register (Undefined mode)",
        "purpose": "Holds the saved process state when an exception is taken to Undefined mode.\n\nN, bit [31]           - Set to the value of CPSR.N on taking an exception to\n                        Undefined mode, and copied to CPSR.N on executing an\n                        exception return operation in Undefined mode.\nZ, bit [30]           - Set to the value of CPSR.Z on taking an exception to\n                        Undefined mode, and copied to CPSR.Z on executing an\n                        exception return operation in Undefined mode.\nC, bit [29]           - Set to the value of CPSR.C on taking an exception to\n                        Undefined mode, and copied to CPSR.C on executing an\n                        exception return operation in Undefined mode.\nV, bit [28]           - Set to the value of CPSR.V on taking an exception to\n                        Undefined mode, and copied to CPSR.V on executing an\n                        exception return operation in Undefined mode.\nQ, bit [27]           - Set to the value of CPSR.Q on taking an exception to\n                        Undefined mode, and copied to CPSR.Q on executing an\n                        exception return operation in Undefined mode.\nIT[1:0], bits [25:26] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nJ, bit [24]           - res0.\nPAN, bit [22]         - Privileged Access Never.\nDIT, bit [21]         - Data Independent Timing.\nIL, bit [20]          - Illegal Execution state bit.\nGE, bits [16:19]      - Greater than or Equal flags, for parallel addition and\n                        subtraction.\nIT[7:2], bits [10:15] - IT block state bits for the T32 IT (If-Then)\n                        instruction.\nE, bit [9]            - Endianness state bit.\nA, bit [8]            - SError interrupt mask bit.\nI, bit [7]            - IRQ mask bit.\nF, bit [6]            - FIQ mask bit.\nT, bit [5]            - T32 Instruction set state bit.\nM[4], bit [4]         - Execution state that the exception was taken from.\nM[3:0], bits [0:3]    - AArch32 mode that an exception was taken from."
      },
      "TCMTR": {
        "long_name": "TCM Type Register",
        "purpose": "Provides information about the implementation of the TCM."
      },
      "TLBTR": {
        "long_name": "TLB Type Register",
        "purpose": "Provides information about the TLB implementation. The register must define\nwhether the implementation provides separate instruction and data TLBs, or a\nunified TLB. Normally, the implementation defined information in this register\nincludes the number of lockable entries in the TLB.\n\nnU, bit [0] - Not Unified TLB. Indicates whether the implementation has a\n              unified TLB:\n                  0b0 Unified TLB.\n                  0b1 Separate Instruction and Data TLBs."
      },
      "TPIDRPRW": {
        "long_name": "PL1 Software Thread ID Register",
        "purpose": "Provides a location where software executing at EL1 or higher can store thread\nidentifying information that is not visible to software executing at EL0, for OS\nmanagement purposes.\n\nThe PE makes no use of this register.\n\nbits [0:31] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "TPIDRURO": {
        "long_name": "PL0 Read-Only Software Thread ID Register",
        "purpose": "Provides a location where software executing at EL1 or higher can store thread\nidentifying information that is visible to software executing at EL0, for OS\nmanagement purposes.\n\nThe PE makes no use of this register.\n\nbits [0:31] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "TPIDRURW": {
        "long_name": "PL0 Read/Write Software Thread ID Register",
        "purpose": "Provides a location where software executing at EL0 can store thread identifying\ninformation, for OS management purposes.\n\nThe PE makes no use of this register.\n\nbits [0:31] - Thread ID. Thread identifying information stored by software\n              running at this Exception level."
      },
      "TRFCR": {
        "long_name": "Trace Filter Control Register",
        "purpose": "Provides EL1 controls for Trace.\n\nTS, bits [5:6] - Timestamp Control. Controls which timebase is used for trace\n                 timestamps.\n                     0b01 Virtual timestamp. The traced timestamp is the\n                 physical counter value minus the value of CNTVOFF.\n                     0b11 Physical timestamp. The traced timestamp is the\n                 physical counter value.\n                 All other values are reserved. This field is ignored if any of\n                 the following are true:\n                   - SelfHostedTraceEnabled() == FALSE.\n                   - HTRFCR.TS is not 0b00.\nE1TRE, bit [1] - EL1 Trace Enable.\n                     0b0 Tracing is prohibited in PL1 modes.\n                     0b1 Tracing is allowed in PL1 modes.\n                 When SelfHostedTraceEnabled() == FALSE, this field is ignored.\nE0TRE, bit [0] - EL0 Trace Enable.\n                     0b0 Tracing is prohibited at EL0.\n                     0b1 Tracing is allowed at EL0.\n                 This field is ignored if any of the following are true:\n                   - SelfHostedTraceEnabled() == FALSE.\n                   - EL2 is implemented and enabled in the current security\n                 state and HCR.TGE == 1."
      },
      "TTBCR": {
        "long_name": "Translation Table Base Control Register",
        "purpose": "The control register for stage 1 of the PL1&0 translation regime. Its controls\ninclude:\n\n  - Where the VA range is split between addresses translated using TTBR0 and\naddresses translated using TTBR1.\n  - The translation table format used by this stage of translation.\n\nIn ARMv8.2, when the value of TTBCR.{EAE, T2E} is {1, 1}, TTBCR is used with\nTTBCR2.\n\nEAE, bit [31] - Extended Address Enable.\nPD1, bit [5]  - Translation table walk disable for translations using TTBR1.\n                This bit controls whether a translation table walk is performed\n                on a TLB miss, for an address that is translated using TTBR1.\nPD0, bit [4]  - Translation table walk disable for translations using TTBR0.\n                This bit controls whether a translation table walk is performed\n                on a TLB miss for an address that is translated using TTBR0.\nN, bits [0:2] - Indicate the width of the base address held in TTBR0. In TTBR0,\n                the base address field is bits[31:14-N]. The value of N also\n                determines:\n                  - Whether TTBR0 or TTBR1 is used as the base address for\n                translation table walks.\n                  - The size of the translation table pointed to by TTBR0. N can\n                take any value from 0 to 7, that is, from 0b000 to 0b111. When N\n                has its reset value of 0, the translation table base is\n                compatible with ARMv5 and ARMv6."
      },
      "TTBCR2": {
        "long_name": "Translation Table Base Control Register 2",
        "purpose": "The second control register for stage 1 of the PL1&0 translation regime.\n\nIf ARMv8.2-AA32HPD is not implemented then  this register is not implemented and\nits encoding is unallocated. Otherwise:\n\n  - When the value of TTBCR.{EAE, T2E} is not {1, 1} the contents of TTBCR2 are\ntreated as zero for all purposes other than reading or writing the register.\n  - When the value of TTBCR.{EAE, T2E} is {1, 1} TTBCR2 is used with TTBCR.\n\nHWU162, bit [18] - Hardware Use.\nHWU161, bit [17] - Hardware Use.\nHWU160, bit [16] - Hardware Use.\nHWU159, bit [15] - Hardware Use.\nHWU062, bit [14] - Hardware Use.\nHWU061, bit [13] - Hardware Use.\nHWU060, bit [12] - Hardware Use.\nHWU059, bit [11] - Hardware Use.\nHPD1, bit [10]   - Hierarchical Permission Disables.\nHPD0, bit [9]    - Hierarchical Permission Disables."
      },
      "TTBR0": {
        "long_name": "Translation Table Base Register 0",
        "purpose": "Holds the base address of the translation table for the initial lookup for stage\n1 of the translation of an address from the lower VA range in the PL1&0\ntranslation regime, and other information for this translation regime.\n\nTTB0, bits [7:31] - Translation table base address, bits[31:x], where x is\n                    14-(TTBCR.N). Register bits [x-1:7] are res0, with the\n                    additional requirement that if these bits are not all zero,\n                    this is a misaligned translation table base address, with\n                    effects that are constrained unpredictable, and must be one\n                    of the following:\n                      - Register bits [x-1:7] are treated as if all the bits are\n                    zero. The value read back from these bits is either the\n                    value written or zero.\n                      - The result of the calculation of an address for a\n                    translation table walk using this register can be corrupted\n                    in those bits that are nonzero.\nIRGN, bit [6]     - Inner region bits. Bits [0,6] of this register together\n                    indicate the Inner Cacheability attributes for the memory\n                    associated with the translation table walks.\nNOS, bit [5]      - Not Outer Shareable.\nRGN, bits [3:4]   - Region bits.\nIMP, bit [2]      - The effect of this bit is implementation defined. If the\n                    translation table implementation does not include any\n                    implementation defined features this bit is res0.\nS, bit [1]        - Shareable.\nIRGN, bit [0]     - Inner region bits. Bits [0,6] of this register together\n                    indicate the Inner Cacheability attributes for the memory\n                    associated with the translation table walks."
      },
      "TTBR1": {
        "long_name": "Translation Table Base Register 1",
        "purpose": "Holds the base address of the translation table for the initial lookup for stage\n1 of the translation of an address from the higher VA range in the PL1&0\ntranslation regime, and other information for this translation regime.\n\nTTB1, bits [7:31] - Translation table base address, bits[31:14]. Register bits\n                    [13:7] are res0, with the additional requirement that if\n                    these bits are not all zero, this is a misaligned\n                    translation table base address, with effects that are\n                    constrained unpredictable, and must be one of the following:\n                      - Register bits [13:7] are treated as if all the bits are\n                    zero. The value read back from these bits is either the\n                    value written or zero.\n                      - The result of the calculation of an address for a\n                    translation table walk using this register can be corrupted\n                    in those bits that are nonzero.\nIRGN, bit [6]     - Inner region bits. IRGN[1:0] indicate the Inner Cacheability\n                    attributes for the memory associated with the translation\n                    table walks.\nNOS, bit [5]      - Not Outer Shareable.\nRGN, bits [3:4]   - Region bits.\nIMP, bit [2]      - The effect of this bit is implementation defined. If the\n                    translation table implementation does not include any\n                    implementation defined features this bit is res0.\nS, bit [1]        - Shareable.\nIRGN, bit [0]     - Inner region bits. IRGN[1:0] indicate the Inner Cacheability\n                    attributes for the memory associated with the translation\n                    table walks."
      },
      "VBAR": {
        "long_name": "Vector Base Address Register",
        "purpose": "When high exception vectors are not selected, holds the vector base address for\nexceptions that are not taken to Monitor mode or to Hyp mode.\n\nSoftware must program VBAR(NS) with the required initial value as part of the PE\nboot sequence.\n\nbits [5:31] - Vector Base Address. Bits[31:5] of the base address of the\n              exception vectors for exceptions taken to this Exception level.\n              Bits[4:0] of an exception vector are the exception offset."
      },
      "VDFSR": {
        "long_name": "Virtual SError Exception Syndrome Register",
        "purpose": "Provides the syndrome value reported to software on taking a virtual SError\ninterrupt exception to EL1, or on executing an ESB instruction at EL1.\n\nWhen a virtual SError interrupt is taken, the syndrome value is reported in\nDFSR.{AET, ExT} and the remainder of the DFSR is set as defined by VMSAv8-32.\nFor more information, see The AArch32 Virtual Memory System Architecture.\n\nIf the virtual SError interrupt is deferred by an ESB instruction, then the\nsyndrome value is written to VDISR.\n\nAET, bits [14:15] - When a virtual SError interrupt is taken to EL1 using\n                    AArch32, DFSR[15:4] is set to VDFSR.AET. When a virtual\n                    SError interrupt is deferred by an ESB instruction,\n                    VDISR[15:4] is set to VDFSR.AET.\nExT, bit [12]     - When a virtual SError interrupt is taken to EL1 using\n                    AArch32, DFSR[12] is set to VDFSR.ExT. When a virtual SError\n                    interrupt is deferred by an ESB instruction, VDISR[12] is\n                    set to VDFSR.ExT."
      },
      "VDISR": {
        "long_name": "Virtual Deferred Interrupt Status Register",
        "purpose": "Records that an SError interrupt has been consumed by an ESB instruction.\n\nA, bit [31]       - Set to 1 when an ESB instruction defers a virtual SError\n                    interrupt.\nAET, bits [14:15] - The value copied from VDFSR.AET.\nExT, bit [12]     - The value copied from VDFSR.ExT.\nFS, bit [10]      - Fault status code. Set to 0b10110 when an ESB instruction\n                    defers a virtual SError interrupt. The possible values of\n                    this field are:\n                        0b10110 Asynchronous SError interrupt.\n                    All other values are reserved. Reserved values might be\n                    defined in a future version of the architecture.\nLPAE, bit [9]     - Format. Set to TTBCR.EAE when an ESB instruction defers a\n                    virtual SError interrupt.\n                        0b0 Using the Short-descriptor translation table format.\nFS, bits [0:3]    - Fault status code. Set to 0b10110 when an ESB instruction\n                    defers a virtual SError interrupt. The possible values of\n                    this field are:\n                        0b10110 Asynchronous SError interrupt.\n                    All other values are reserved. Reserved values might be\n                    defined in a future version of the architecture."
      },
      "VMPIDR": {
        "long_name": "Virtualization Multiprocessor ID Register",
        "purpose": "Holds the value of the Virtualization Multiprocessor ID. This is the value\nreturned by Non-secure EL1 reads of MPIDR.\n\nM, bit [31]        - Indicates whether this implementation includes the\n                     functionality introduced by the ARMv7 Multiprocessing\n                     Extensions.\nU, bit [30]        - Indicates a Uniprocessor system, as distinct from PE 0 in a\n                     multiprocessor system.\nMT, bit [24]       - Indicates whether the lowest level of affinity consists of\n                     logical PEs that are implemented using a multithreading\n                     type approach. See the description of Aff0 for more\n                     information about affinity levels.\nAff2, bits [16:23] - Affinity level 2. See the description of Aff0 for more\n                     information.\nAff1, bits [8:15]  - Affinity level 1. See the description of Aff0 for more\n                     information.\nAff0, bits [0:7]   - Affinity level 0. This is the affinity level that is most\n                     significant for determining PE behavior. Higher affinity\n                     levels are increasingly less significant in determining PE\n                     behavior. The assigned value of the MPIDR.{Aff2, Aff1,\n                     Aff0} or MPIDR_EL1.{Aff3, Aff2, Aff1, Aff0} set of fields\n                     of each PE must be unique within the system as a whole."
      },
      "VPIDR": {
        "long_name": "Virtualization Processor ID Register",
        "purpose": "Holds the value of the Virtualization Processor ID. This is the value returned\nby Non-secure EL1 reads of MIDR.\n\nImplementer, bits [24:31]  - The Implementer code. This field must hold an\n                             implementer code that has been assigned by ARM.\n                             Assigned codes include the following: ARM can\n                             assign codes that are not published in this manual.\n                             All values not assigned by ARM are reserved and\n                             must not be used.\nVariant, bits [20:23]      - An implementation defined variant number.\n                             Typically, this field is used to distinguish\n                             between different product variants, or major\n                             revisions of a product.\nArchitecture, bits [16:19] - The permitted values of this field are:\nPartNum, bits [4:15]       - An implementation defined primary part number for\n                             the device. On processors implemented by ARM, if\n                             the top four bits of the primary part number are\n                             0x0 or 0x7, the variant and architecture are\n                             encoded differently.\nRevision, bits [0:3]       - An implementation defined revision number for the\n                             device."
      },
      "VTCR": {
        "long_name": "Virtualization Translation Control Register",
        "purpose": "The control register for stage 2 of the Non-secure PL1&0 translation regime.\n\nThis stage of translation always uses the Long-descriptor translation table\nformat.\n\nHWU62, bit [28]     - Hardware Use.\nHWU61, bit [27]     - Hardware Use.\nHWU60, bit [26]     - Hardware Use.\nHWU59, bit [25]     - Hardware Use.\nSH0, bits [12:13]   - Shareability attribute for memory associated with\n                      translation table walks using VTTBR.\nORGN0, bits [10:11] - Outer cacheability attribute for memory associated with\n                      translation table walks using VTTBR.\nIRGN0, bits [8:9]   - Inner cacheability attribute for memory associated with\n                      translation table walks using VTTBR.\nSL0, bits [6:7]     - Starting level for translation table walks using VTTBR.\nS, bit [4]          - Sign extension bit.\nT0SZ, bits [0:3]    - The size offset of the memory region addressed by VTTBR."
      },
      "VTTBR": {
        "long_name": "Virtualization Translation Table Base Register",
        "purpose": "Holds the base address of the translation table for the initial lookup for stage\n2 of an address translation in the Non-secure PL1&0 translation regime, and\nother information for this translation regime.\n\nVMID, bits [48:55] - The VMID for the translation table.\nBADDR, bits [1:47] - Translation table base address, bits[47:x], Bits [x-1:1]\n                     are res0, with the additional requirement that if\n                     bits[x-1:3] are not all zero, this is a misaligned\n                     translation table base address, with effects that are\n                     constrained unpredictable, and must be one of the\n                     following:\n                       - Register bits [x-1:3] are treated as if all the bits\n                     are zero. The value read back from these bits is either the\n                     value written or zero.\n                       - The result of the calculation of an address for a\n                     translation table walk using this register can be corrupted\n                     in those bits that are nonzero. x is determined from the\n                     value of VTCR.SL0 and VTCR.T0SZ as follows:\n                       - If VTCR.SL0 is 0b00, meaning that lookup starts at\n                     level 2, then x is 14 - VTCR.T0SZ.\n                       - If VTCR.SL0 is 0b01, meaning that lookup starts at\n                     level 1, then x is 5 - VTCR.T0SZ.\n                       - If VTCR.SL0 is either 0b10 or 0b11 then a stage 2 level\n                     1 Translation fault is generated. If bits[47:40] of the\n                     translation table base address are not zero, an Address\n                     size fault is generated.\nCnP, bit [0]       - Common not Private. This bit indicates whether each entry\n                     that is pointed to by VTTBR is a member of a common set\n                     that can be used by every PE in the Inner Shareable domain\n                     for which the value of VTTBR.CnP is 1."
      }
    }
  }
}